<!DOCTYPE html><html lang="zh-CN"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>events 事件触发器 | Node.js API 文档</title>
<link rel="icon" sizes="32x32" type="image/png" href="//img.nodejs.cn/favicon.png">
<link href="./_static/css/api.css?t=20220728214329" rel="stylesheet">
</head>
<body class="alt apidoc api_page_events" id="page_api">
<div id="content" class="clearfix">
<div id="column2" class="interior">
<div id="intro" class="interior">
<a href="/" rel="nofollow">
Node.js 中文网
</a>
</div>
<div class="line"></div>
<ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events active" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>
</div>
<div id="column1" data-id="events" class="interior">
<header class="header">
<div class="header-container">
<h1>Node.js v12.22.12 文档</h1>
<button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
<svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
<path fill="none" d="M0 0h24v24H0z"></path>
<path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
<path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
</svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
<path d="M0 0h24v24H0z" fill="none"></path>
<path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
</svg>
</button>
</div>
<div id="gtoc">
<ul>
<li class="pinned-header">Node.js 12.22.12</li>
<li class="picker-header" id="header_toc">
<a href="#">
<span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
目录
</a>
<div class="picker"><div class="toc"><ul>
<li><span class="stability_2"><a href="#events">events 事件触发器</a></span>
<ul>
<li><a href="#passing-arguments-and-this-to-listeners">将参数和 this 传给监听器</a></li>
<li><a href="#asynchronous-vs-synchronous">异步 VS 同步</a></li>
<li><a href="#handling-events-only-once">仅处理事件一次</a></li>
<li><a href="#error-events">错误事件</a></li>
<li><span class="stability_1"><a href="#capture-rejections-of-promises">捕捉 Promise 拒绝</a></span></li>
<li><a href="#class-eventemitter"><code>EventEmitter</code> 类</a>
<ul>
<li><a href="#event-newlistener">'newListener' 事件</a></li>
<li><a href="#event-removelistener"><code>'removeListener'</code> 事件</a></li>
<li><span class="stability_0"><a href="#eventemitterlistenercountemitter-eventname"><code>EventEmitter.listenerCount(emitter, eventName)</code></a></span></li>
<li><a href="#eventemitterdefaultmaxlisteners"><code>EventEmitter.defaultMaxListeners</code></a></li>
<li><a href="#eventemittererrormonitor"><code>EventEmitter.errorMonitor</code></a></li>
<li><a href="#emitteraddlistenereventname-listener"><code>emitter.addListener(eventName, listener)</code></a></li>
<li><a href="#emitteremiteventname-args"><code>emitter.emit(eventName[, ...args])</code></a></li>
<li><a href="#emittereventnames"><code>emitter.eventNames()</code></a></li>
<li><a href="#emittergetmaxlisteners"><code>emitter.getMaxListeners()</code></a></li>
<li><a href="#emitterlistenercounteventname"><code>emitter.listenerCount(eventName)</code></a></li>
<li><a href="#emitterlistenerseventname"><code>emitter.listeners(eventName)</code></a></li>
<li><a href="#emitteroffeventname-listener"><code>emitter.off(eventName, listener)</code></a></li>
<li><a href="#emitteroneventname-listener"><code>emitter.on(eventName, listener)</code></a></li>
<li><a href="#emitteronceeventname-listener"><code>emitter.once(eventName, listener)</code></a></li>
<li><a href="#emitterprependlistenereventname-listener"><code>emitter.prependListener(eventName, listener)</code></a></li>
<li><a href="#emitterprependoncelistenereventname-listener"><code>emitter.prependOnceListener(eventName, listener)</code></a></li>
<li><a href="#emitterremovealllistenerseventname"><code>emitter.removeAllListeners([eventName])</code></a></li>
<li><a href="#emitterremovelistenereventname-listener"><code>emitter.removeListener(eventName, listener)</code></a></li>
<li><a href="#emittersetmaxlistenersn"><code>emitter.setMaxListeners(n)</code></a></li>
<li><a href="#emitterrawlistenerseventname"><code>emitter.rawListeners(eventName)</code></a></li>
<li><span class="stability_1"><a href="#emittersymbolfornodejsrejectionerr-eventname-args"><code>emitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])</code></a></span></li>
</ul>
</li>
<li><a href="#eventsonceemitter-name"><code>events.once(emitter, name)</code></a>
<ul>
<li><a href="#awaiting-multiple-events-emitted-on-processnexttick">等待 process.nextTick() 上触发的多个事件</a></li>
</ul>
</li>
<li><span class="stability_1"><a href="#eventscapturerejections"><code>events.captureRejections</code></a></span></li>
<li><span class="stability_1"><a href="#eventscapturerejectionsymbol">events.captureRejectionSymbol</a></span></li>
<li><a href="#eventsonemitter-eventname">events.on(emitter, eventName)</a></li>
</ul>
</li>
</ul></div></div>
</li>
<li class="picker-header">
<a href="#">
<span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
索引
</a>
<div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>
<li>
<a href="index.html">首页</a>
</li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events active">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
</li>
<li class="picker-header">
<a href="#">
<span class="collapsed-arrow">&#x25ba;</span><span class="expanded-arrow">&#x25bc;</span>
其他版本
</a>
<div class="picker"><ol id="alt-docs">
<li><a href="/api/events.html">18.7.0</a></li><li><a href="/api-v16/events.html">16.16.0</a></li><li><a href="/api-v14/events.html">14.20.0</a></li><li><a href="/api-v12/events.html">12.22.12</a></li>
</ol></div>
</li>
<li>
<a href="http://api.nodejs.cn/?v=12">文档搜索</a>
</li>
</ul>
</div>
<hr>
</header>
<details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#events">events 事件触发器</a></span>
<ul>
<li><a href="#passing-arguments-and-this-to-listeners">将参数和 this 传给监听器</a></li>
<li><a href="#asynchronous-vs-synchronous">异步 VS 同步</a></li>
<li><a href="#handling-events-only-once">仅处理事件一次</a></li>
<li><a href="#error-events">错误事件</a></li>
<li><span class="stability_1"><a href="#capture-rejections-of-promises">捕捉 Promise 拒绝</a></span></li>
<li><a href="#class-eventemitter"><code>EventEmitter</code> 类</a>
<ul>
<li><a href="#event-newlistener">'newListener' 事件</a></li>
<li><a href="#event-removelistener"><code>'removeListener'</code> 事件</a></li>
<li><span class="stability_0"><a href="#eventemitterlistenercountemitter-eventname"><code>EventEmitter.listenerCount(emitter, eventName)</code></a></span></li>
<li><a href="#eventemitterdefaultmaxlisteners"><code>EventEmitter.defaultMaxListeners</code></a></li>
<li><a href="#eventemittererrormonitor"><code>EventEmitter.errorMonitor</code></a></li>
<li><a href="#emitteraddlistenereventname-listener"><code>emitter.addListener(eventName, listener)</code></a></li>
<li><a href="#emitteremiteventname-args"><code>emitter.emit(eventName[, ...args])</code></a></li>
<li><a href="#emittereventnames"><code>emitter.eventNames()</code></a></li>
<li><a href="#emittergetmaxlisteners"><code>emitter.getMaxListeners()</code></a></li>
<li><a href="#emitterlistenercounteventname"><code>emitter.listenerCount(eventName)</code></a></li>
<li><a href="#emitterlistenerseventname"><code>emitter.listeners(eventName)</code></a></li>
<li><a href="#emitteroffeventname-listener"><code>emitter.off(eventName, listener)</code></a></li>
<li><a href="#emitteroneventname-listener"><code>emitter.on(eventName, listener)</code></a></li>
<li><a href="#emitteronceeventname-listener"><code>emitter.once(eventName, listener)</code></a></li>
<li><a href="#emitterprependlistenereventname-listener"><code>emitter.prependListener(eventName, listener)</code></a></li>
<li><a href="#emitterprependoncelistenereventname-listener"><code>emitter.prependOnceListener(eventName, listener)</code></a></li>
<li><a href="#emitterremovealllistenerseventname"><code>emitter.removeAllListeners([eventName])</code></a></li>
<li><a href="#emitterremovelistenereventname-listener"><code>emitter.removeListener(eventName, listener)</code></a></li>
<li><a href="#emittersetmaxlistenersn"><code>emitter.setMaxListeners(n)</code></a></li>
<li><a href="#emitterrawlistenerseventname"><code>emitter.rawListeners(eventName)</code></a></li>
<li><span class="stability_1"><a href="#emittersymbolfornodejsrejectionerr-eventname-args"><code>emitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])</code></a></span></li>
</ul>
</li>
<li><a href="#eventsonceemitter-name"><code>events.once(emitter, name)</code></a>
<ul>
<li><a href="#awaiting-multiple-events-emitted-on-processnexttick">等待 process.nextTick() 上触发的多个事件</a></li>
</ul>
</li>
<li><span class="stability_1"><a href="#eventscapturerejections"><code>events.captureRejections</code></a></span></li>
<li><span class="stability_1"><a href="#eventscapturerejectionsymbol">events.captureRejectionSymbol</a></span></li>
<li><a href="#eventsonemitter-eventname">events.on(emitter, eventName)</a></li>
</ul>
</li>
</ul></details>
<div id="apicontent">
<h2>events 事件触发器<span><a class="mark" href="#events" id="events">#</a></span><a aria-hidden="true" class="legacy" id="events_events"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="">
<a href="events/events.html" class="tip_trans">中英对照</a>
</p>
<p></p><div class="api_stability api_stability_2"><a href="/api/documentation.html#stability-index">稳定性: 2</a> - 稳定</div><p></p>
<p><strong>源代码:</strong> <a rel="nofollow" href="https://github.com/nodejs/node/blob/v12.22.12/lib/events.js">lib/events.js</a></p>
<p>Node.js 的大部分核心 API 都是围绕惯用的异步事件驱动架构构建的，在该架构中，某些类型的对象（称为"触发器"）触发命名事件，使 <code>Function</code> 对象（"监听器"）被调用。</p>
<p>例如：<a href="net.html#net_class_net_server"><code>net.Server</code></a> 对象在每次有连接时触发事件；<a href="fs.html#fs_class_fs_readstream"><code>fs.ReadStream</code></a> 在打开文件时触发事件；<a href="stream.html">流</a>在每当有数据可供读取时触发事件。</p>
<p>所有触发事件的对象都是 <code>EventEmitter</code> 类的实例。
这些对象暴露了 <code>eventEmitter.on()</code> 函数，允许将一个或多个函数绑定到对象触发的命名事件。
通常，事件名称是驼峰式字符串，但也可以使用任何有效的 JavaScript 属性键。</p>
<p>当 <code>EventEmitter</code> 对象触发事件时，所有绑定到该特定事件的函数都会被同步地调用。</p>
<p>以下示例展示了使用单个监听器的简单的 <code>EventEmitter</code> 实例。
<code>eventEmitter.on()</code> 方法用于注册监听器，<code>eventEmitter.emit()</code> 方法用于触发事件。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEmitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> {}

<span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'an event occurred!'</span>);
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);</code></pre>
<section><h3>将参数和 this 传给监听器<span><a class="mark" href="#passing-arguments-and-this-to-listeners" id="passing-arguments-and-this-to-listeners">#</a></span><a aria-hidden="true" class="legacy" id="events_passing_arguments_and_this_to_listeners"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#passing-arguments-and-this-to-listeners">
<a href="events/passing_arguments_and_this_to_listeners.html" class="tip_trans">中英对照</a>
</p>
<p><code>eventEmitter.emit()</code> 方法允许将任意一组参数传给监听器函数。
记住，当调用普通的监听器函数时，标准的 <code>this</code> 关键字会被有意地设置为引用监听器绑定到的 <code>EventEmitter</code> 实例。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, <span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span> === myEmitter);
  <span class="hljs-comment">// 打印:</span>
  <span class="hljs-comment">//   a b MyEmitter {</span>
  <span class="hljs-comment">//     domain: null,</span>
  <span class="hljs-comment">//     _events: { event: [Function] },</span>
  <span class="hljs-comment">//     _eventsCount: 1,</span>
  <span class="hljs-comment">//     _maxListeners: undefined } true</span>
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);</code></pre>
<p>可以使用 ES6 箭头函数作为监听器，但是，这样做时，<code>this</code> 关键字将不再引用 <code>EventEmitter</code> 实例：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b, <span class="hljs-variable language_">this</span>);
  <span class="hljs-comment">// 打印: a b {}</span>
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);</code></pre>
</section><section><h3>异步 VS 同步<span><a class="mark" href="#asynchronous-vs-synchronous" id="asynchronous-vs-synchronous">#</a></span><a aria-hidden="true" class="legacy" id="events_asynchronous_vs_synchronous"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#asynchronous-vs-synchronous">
<a href="events/asynchronous_vs_synchronous.html" class="tip_trans">中英对照</a>
</p>
<p><code>EventEmitter</code> 按照注册的顺序同步地调用所有监听器。
这确保了事件的正确排序，并有助于避免竞争条件和逻辑错误。
在适当的时候，监听器函数可以使用 <code>setImmediate()</code> 或 <code>process.nextTick()</code> 方法切换到异步的操作模式：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
  <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'this happens asynchronously'</span>);
  });
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>);</code></pre>
</section><section><h3>仅处理事件一次<span><a class="mark" href="#handling-events-only-once" id="handling-events-only-once">#</a></span><a aria-hidden="true" class="legacy" id="events_handling_events_only_once"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#handling-events-only-once">
<a href="events/handling_events_only_once.html" class="tip_trans">中英对照</a>
</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
<span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>;
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++m);
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);
<span class="hljs-comment">// 打印: 1</span>
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);
<span class="hljs-comment">// 打印: 2</span></code></pre>
<p>使用 <code>eventEmitter.once()</code> 方法，可以注册一个监听器，该监听器最多为特定事件调用一次。
一旦事件被触发，则监听器就会被注销然后被调用。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
<span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>;
myEmitter.<span class="hljs-title function_">once</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++m);
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);
<span class="hljs-comment">// 打印: 1</span>
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);
<span class="hljs-comment">// 忽略</span></code></pre>
</section><section><h3>错误事件<span><a class="mark" href="#error-events" id="error-events">#</a></span><a aria-hidden="true" class="legacy" id="events_error_events"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#error-events">
<a href="events/error_events.html" class="tip_trans">中英对照</a>
</p>
<p>当 <code>EventEmitter</code> 实例中发生错误时，典型的操作是触发 <code>'error'</code> 事件。
这些在 Node.js 中被视为特殊情况。</p>
<p>如果 <code>EventEmitter</code> 没有为 <code>'error'</code> 事件注册至少一个监听器，并且触发 <code>'error'</code> 事件，则会抛出错误，打印堆栈跟踪，然后退出 Node.js 进程。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'whoops!'</span>));
<span class="hljs-comment">// 抛出错误并使 Node.js 崩溃</span></code></pre>
<p>为了防止 Node.js 进程崩溃，可以使用 <a href="domain.html"><code>domain</code></a> 模块。
（但请注意，不推荐使用 <code>domain</code> 模块。）</p>
<p>作为最佳实践，应始终为 <code>'error'</code> 事件添加监听器。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'whoops! there was an error'</span>);
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'whoops!'</span>));
<span class="hljs-comment">// 打印: whoops! there was an error</span></code></pre>
<p>通过使用符号 <code>errorMonitor</code> 安装监听器，可以在不消费触发的错误的情况下监视 <code>'error'</code> 事件。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">errorMonitor</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-title class_">MyMonitoringTool</span>.<span class="hljs-title function_">log</span>(err);
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'whoops!'</span>));
<span class="hljs-comment">// 仍然抛出错误并使 Node.js 崩溃</span></code></pre>
</section><section><h3>捕捉 Promise 拒绝<span><a class="mark" href="#capture-rejections-of-promises" id="capture-rejections-of-promises">#</a></span><a aria-hidden="true" class="legacy" id="events_capture_rejections_of_promises"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#capture-rejections-of-promises">
<a href="events/capture_rejections_of_promises.html" class="tip_trans">中英对照</a>
</p>
<p></p><div class="api_stability api_stability_1"><a href="/api/documentation.html#stability-index">稳定性: 1</a> - captureRejections 是实验的。</div><p></p>
<p>将 <code>async</code> 函数与事件句柄一起使用是有问题的，因为它会在抛出异常的情况下导致未处理的拒绝：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();
ee.<span class="hljs-title function_">on</span>(<span class="hljs-string">'something'</span>, <span class="hljs-keyword">async</span> (value) =&gt; {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'kaboom'</span>);
});</code></pre>
<p><code>EventEmitter</code> 构造函数中的 <code>captureRejections</code> 选项或全局的设置可以改变这种行为，在 <code>Promise</code> 上安装 <code>.then(undefined, handler)</code> 句柄。
此句柄将异常异步地路由到 <a href="/api-v12/events.html#events_emitter_symbol_for_nodejs_rejection_err_eventname_args"><code>Symbol.for('nodejs.rejection')</code></a> 方法（如果有）或 <a href="/api-v12/events.html#events_error_events"><code>'error'</code></a> 事件句柄（如果没有）。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ee1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>({ <span class="hljs-attr">captureRejections</span>: <span class="hljs-literal">true</span> });
ee1.<span class="hljs-title function_">on</span>(<span class="hljs-string">'something'</span>, <span class="hljs-keyword">async</span> (value) =&gt; {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'kaboom'</span>);
});

ee1.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);

<span class="hljs-keyword">const</span> ee2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>({ <span class="hljs-attr">captureRejections</span>: <span class="hljs-literal">true</span> });
ee2.<span class="hljs-title function_">on</span>(<span class="hljs-string">'something'</span>, <span class="hljs-keyword">async</span> (value) =&gt; {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'kaboom'</span>);
});

ee2[<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">'nodejs.rejection'</span>)] = <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>;</code></pre>
<p>设置 <code>EventEmitter.captureRejections = true</code> 将更改 <code>EventEmitter</code> 的所有新实例的默认值。</p>
<pre><code class="language-js"><span class="hljs-title class_">EventEmitter</span>.<span class="hljs-property">captureRejections</span> = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> ee1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();
ee1.<span class="hljs-title function_">on</span>(<span class="hljs-string">'something'</span>, <span class="hljs-keyword">async</span> (value) =&gt; {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'kaboom'</span>);
});

ee1.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);</code></pre>
<p>由 <code>captureRejections</code> 行为生成的 <code>'error'</code> 事件没有捕获句柄以避免无限的错误循环：建议不要使用 <code>async</code> 函数作为 <code>'error'</code> 事件句柄。</p>
</section><section><h3><code>EventEmitter</code> 类<span><a class="mark" href="#class-eventemitter" id="class-eventemitter">#</a></span><a aria-hidden="true" class="legacy" id="events_class_eventemitter"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#class-eventemitter">
<a href="events/class_eventemitter.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.16.0</td>
<td><p>添加了捕获拒绝的选项。</p></td></tr>
<tr><td>v0.1.26</td>
<td><p><span>新增于: v0.1.26</span></p></td></tr>
</tbody></table>
</details>
</div>
<p><code>EventEmitter</code> 类由 <code>events</code> 模块定义和暴露：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);</code></pre>
<p>所有的 <code>EventEmitter</code>，当添加新的监听器时触发事件 <code>'newListener'</code>，当删除现有的监听器时触发事件 <code>'removeListener'</code>。</p>
<p>它支持以下的选项：</p>
<ul>
<li><code>captureRejections</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type" target="_blank">&lt;boolean&gt;</a> 启用<a href="/api-v12/events.html#events_capture_rejections_of_promises">自动捕获 promise 拒绝</a>。</li>
</ul>
<h4>'newListener' 事件<span><a class="mark" href="#event-newlistener" id="event-newlistener">#</a></span><a aria-hidden="true" class="legacy" id="events_event_newlistener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-newlistener">
<a href="events/event_newlistener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.1.26</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 正在监听的事件的名称</li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a> 事件处理函数</li>
</ul>
<p>在将监听器添加到其内部监听器数组之前，<code>EventEmitter</code> 实例将触发自身的 <code>'newListener'</code> 事件。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
<span class="hljs-comment">// 只做一次，这样就不会永远循环</span>
myEmitter.<span class="hljs-title function_">once</span>(<span class="hljs-string">'newListener'</span>, <span class="hljs-function">(<span class="hljs-params">event, listener</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (event === <span class="hljs-string">'event'</span>) {
    <span class="hljs-comment">// 在前面插入新的监听器</span>
    myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'B'</span>);
    });
  }
});
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'A'</span>);
});
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   B</span>
<span class="hljs-comment">//   A</span></code></pre>
<h4><code>'removeListener'</code> 事件<span><a class="mark" href="#event-removelistener" id="event-removelistener">#</a></span><a aria-hidden="true" class="legacy" id="events_event_removelistener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#event-removelistener">
<a href="events/event_removelistener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.1.0, v4.7.0</td>
<td><p>对于使用 <code>.once()</code> 绑定的监听器，<code>listener</code> 参数现在生成原始的监听器函数。</p></td></tr>
<tr><td>v0.9.3</td>
<td><p><span>新增于: v0.9.3</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 事件名称</li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a> 事件处理函数</li>
</ul>
<p>在移除 <code>listener</code> 后触发 <code>'removeListener'</code> 事件。</p>
<h4><code>EventEmitter.listenerCount(emitter, eventName)</code><span><a class="mark" href="#eventemitterlistenercountemitter-eventname" id="eventemitterlistenercountemitter-eventname">#</a></span><a aria-hidden="true" class="legacy" id="events_eventemitter_listenercount_emitter_eventname"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#eventemitterlistenercountemitter-eventname">
<a href="events/eventemitter_listenercount_emitter_eventname.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.9.12</span><span>弃用于: v3.2.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="/api/documentation.html#stability-index">稳定性: 0</a> - 弃用: 改为使用 <a href="/api-v12/events.html#events_emitter_listenercount_eventname"><code>emitter.listenerCount()</code></a> 。</div><p></p>
<ul>
<li><code>emitter</code> <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a> 要查询的触发器</li>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 事件名称</li>
</ul>
<p>返回在给定 <code>emitter</code> 上注册的给定 <code>eventName</code> 的监听器数量的类方法。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {});
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">EventEmitter</span>.<span class="hljs-title function_">listenerCount</span>(myEmitter, <span class="hljs-string">'event'</span>));
<span class="hljs-comment">// 打印: 2</span></code></pre>
<h4><code>EventEmitter.defaultMaxListeners</code><span><a class="mark" href="#eventemitterdefaultmaxlisteners" id="eventemitterdefaultmaxlisteners">#</a></span><a aria-hidden="true" class="legacy" id="events_eventemitter_defaultmaxlisteners"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#eventemitterdefaultmaxlisteners">
<a href="events/eventemitter_defaultmaxlisteners.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.11.2</span>
</div>
<p>默认情况下，最多可为任何单个事件注册 <code>10</code> 个监听器。
可以使用 <a href="/api-v12/events.html#events_emitter_setmaxlisteners_n"><code>emitter.setMaxListeners(n)</code></a> 方法为单个 <code>EventEmitter</code> 实例更改此限制。
要更改所有 <code>EventEmitter</code> 实例的默认值，则可以使用 <code>EventEmitter.defaultMaxListeners</code> 属性。</p>
<p>设置 <code>EventEmitter.defaultMaxListeners</code> 时要小心，因为更改会影响所有 <code>EventEmitter</code> 实例，包括在进行更改之前创建的实例。
但是，调用 <a href="/api-v12/events.html#events_emitter_setmaxlisteners_n"><code>emitter.setMaxListeners(n)</code></a> 仍然优先于 <code>EventEmitter.defaultMaxListeners</code>。</p>
<p>这不是硬性限制。
<code>EventEmitter</code> 实例将允许添加更多监听器，但会向标准错误输出跟踪警告，指示已检测到"可能的 EventEmitter 内存泄漏"。
对于任何单个 <code>EventEmitter</code>，可以使用 <code>emitter.getMaxListeners()</code> 和 <code>emitter.setMaxListeners()</code> 方法来暂时避免此警告：</p>
<pre><code class="language-js">emitter.<span class="hljs-title function_">setMaxListeners</span>(emitter.<span class="hljs-title function_">getMaxListeners</span>() + <span class="hljs-number">1</span>);
emitter.<span class="hljs-title function_">once</span>(<span class="hljs-string">'event'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 做些事情</span>
  emitter.<span class="hljs-title function_">setMaxListeners</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(emitter.<span class="hljs-title function_">getMaxListeners</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
});</code></pre>
<p>触发的警告可以使用 <a href="process.html#process_event_warning"><code>process.on('warning')</code></a> 进行检查，并将具有额外的 <code>emitter</code>、<code>type</code> 和 <code>count</code> 属性，分别是指事件触发器实例、事件名称和绑定监听器的数量。
其 <code>name</code> 属性设置为 <code>'MaxListenersExceededWarning'</code>。</p>
<h4><code>EventEmitter.errorMonitor</code><span><a class="mark" href="#eventemittererrormonitor" id="eventemittererrormonitor">#</a></span><a aria-hidden="true" class="legacy" id="events_eventemitter_errormonitor"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#eventemittererrormonitor">
<a href="events/eventemitter_errormonitor.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v12.17.0</span>
</div>
<p>此符号应用于安装仅监视 <code>'error'</code> 事件的监听器。
在调用常规 <code>'error'</code> 监听器之前调用使用此符号安装的监听器。</p>
<p>一旦触发 <code>'error'</code> 事件，使用此符号安装监听器不会改变行为，因此如果未安装常规 <code>'error'</code> 监听器，则进程仍将崩溃。</p>
<h4><code>emitter.addListener(eventName, listener)</code><span><a class="mark" href="#emitteraddlistenereventname-listener" id="emitteraddlistenereventname-listener">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_addlistener_eventname_listener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitteraddlistenereventname-listener">
<a href="events/emitter_addlistener_eventname_listener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.1.26</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a></li>
</ul>
<p><code>emitter.on(eventName, listener)</code> 的别名。</p>
<h4><code>emitter.emit(eventName[, ...args])</code><span><a class="mark" href="#emitteremiteventname-args" id="emitteremiteventname-args">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_emit_eventname_args"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitteremiteventname-args">
<a href="events/emitter_emit_eventname_args.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.1.26</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li><code>...args</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type" target="_blank">&lt;any&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type" target="_blank">&lt;boolean&gt;</a></li>
</ul>
<p>按注册顺序同步地调用为名为 <code>eventName</code> 的事件注册的每个监听器，并将提供的参数传给每个监听器。</p>
<p>如果事件有监听器，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-comment">// 第一个监听器</span>
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">firstListener</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Helloooo! first listener'</span>);
});
<span class="hljs-comment">// 第二个监听器</span>
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">secondListener</span>(<span class="hljs-params">arg1, arg2</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`event with parameters <span class="hljs-subst">${arg1}</span>, <span class="hljs-subst">${arg2}</span> in second listener`</span>);
});
<span class="hljs-comment">// 第三个监听器</span>
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">thirdListener</span>(<span class="hljs-params">...args</span>) {
  <span class="hljs-keyword">const</span> parameters = args.<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`event with parameters <span class="hljs-subst">${parameters}</span> in third listener`</span>);
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myEmitter.<span class="hljs-title function_">listeners</span>(<span class="hljs-string">'event'</span>));

myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);

<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">// [</span>
<span class="hljs-comment">//   [Function: firstListener],</span>
<span class="hljs-comment">//   [Function: secondListener],</span>
<span class="hljs-comment">//   [Function: thirdListener]</span>
<span class="hljs-comment">// ]</span>
<span class="hljs-comment">// Helloooo! first listener</span>
<span class="hljs-comment">// event with parameters 1, 2 in second listener</span>
<span class="hljs-comment">// event with parameters 1, 2, 3, 4, 5 in third listener</span></code></pre>
<h4><code>emitter.eventNames()</code><span><a class="mark" href="#emittereventnames" id="emittereventnames">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_eventnames"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emittereventnames">
<a href="events/emitter_eventnames.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v6.0.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/ZJSz23" rel="nofollow" class="type" target="_blank">&lt;Array&gt;</a></li>
</ul>
<p>返回列出触发器已为其注册监听器的事件的数组。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">const</span> myEE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();
myEE.<span class="hljs-title function_">on</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-function">() =&gt;</span> {});
myEE.<span class="hljs-title function_">on</span>(<span class="hljs-string">'bar'</span>, <span class="hljs-function">() =&gt;</span> {});

<span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'symbol'</span>);
myEE.<span class="hljs-title function_">on</span>(sym, <span class="hljs-function">() =&gt;</span> {});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myEE.<span class="hljs-title function_">eventNames</span>());
<span class="hljs-comment">// 打印: [ 'foo', 'bar', Symbol(symbol) ]</span></code></pre>
<h4><code>emitter.getMaxListeners()</code><span><a class="mark" href="#emittergetmaxlisteners" id="emittergetmaxlisteners">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_getmaxlisteners"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emittergetmaxlisteners">
<a href="events/emitter_getmaxlisteners.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v1.0.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type" target="_blank">&lt;integer&gt;</a></li>
</ul>
<p>返回 <code>EventEmitter</code> 的当前最大监听器数的值，该值由 <a href="/api-v12/events.html#events_emitter_setmaxlisteners_n"><code>emitter.setMaxListeners(n)</code></a> 设置或默认为 <a href="/api-v12/events.html#events_eventemitter_defaultmaxlisteners"><code>EventEmitter.defaultMaxListeners</code></a>。</p>
<h4><code>emitter.listenerCount(eventName)</code><span><a class="mark" href="#emitterlistenercounteventname" id="emitterlistenercounteventname">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_listenercount_eventname"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitterlistenercounteventname">
<a href="events/emitter_listenercount_eventname.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v3.2.0</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 正在监听的事件的名称</li>
<li>返回: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type" target="_blank">&lt;integer&gt;</a></li>
</ul>
<p>返回监听名为 <code>eventName</code> 的事件的监听器数量。</p>
<h4><code>emitter.listeners(eventName)</code><span><a class="mark" href="#emitterlistenerseventname" id="emitterlistenerseventname">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_listeners_eventname"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitterlistenerseventname">
<a href="events/emitter_listeners_eventname.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v7.0.0</td>
<td><p>对于使用 <code>.once()</code> 绑定的监听器，现在返回原始监听器而不是封装函数。</p></td></tr>
<tr><td>v0.1.26</td>
<td><p><span>新增于: v0.1.26</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function[]&gt;</a></li>
</ul>
<p>返回名为 <code>eventName</code> 的事件的监听器数组的副本。</p>
<pre><code class="language-js">server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'someone connected!'</span>);
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(util.<span class="hljs-title function_">inspect</span>(server.<span class="hljs-title function_">listeners</span>(<span class="hljs-string">'connection'</span>)));
<span class="hljs-comment">// 打印: [ [Function] ]</span></code></pre>
<h4><code>emitter.off(eventName, listener)</code><span><a class="mark" href="#emitteroffeventname-listener" id="emitteroffeventname-listener">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_off_eventname_listener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitteroffeventname-listener">
<a href="events/emitter_off_eventname_listener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v10.0.0</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a></li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p><a href="/api-v12/events.html#events_emitter_removelistener_eventname_listener"><code>emitter.removeListener()</code></a> 的别名。</p>
<h4><code>emitter.on(eventName, listener)</code><span><a class="mark" href="#emitteroneventname-listener" id="emitteroneventname-listener">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_on_eventname_listener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitteroneventname-listener">
<a href="events/emitter_on_eventname_listener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.1.101</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 事件的名称。</li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a> 回调函数</li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>将 <code>listener</code> 函数添加到名为 <code>eventName</code> 的事件的监听器数组的末尾。
不检查是否已添加 <code>listener</code>。
多次调用传入相同的 <code>eventName</code> 和 <code>listener</code> 组合将导致多次添加和调用 <code>listener</code>。</p>
<pre><code class="language-js">server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'someone connected!'</span>);
});</code></pre>
<p>返回对 <code>EventEmitter</code> 的引用，以便可以链式调用。</p>
<p>默认情况下，事件监听器按添加顺序调用。
<code>emitter.prependListener()</code> 方法可用作将事件监听器添加到监听器数组开头的替代方法。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();
myEE.<span class="hljs-title function_">on</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'a'</span>));
myEE.<span class="hljs-title function_">prependListener</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'b'</span>));
myEE.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'foo'</span>);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   b</span>
<span class="hljs-comment">//   a</span></code></pre>
<h4><code>emitter.once(eventName, listener)</code><span><a class="mark" href="#emitteronceeventname-listener" id="emitteronceeventname-listener">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_once_eventname_listener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitteronceeventname-listener">
<a href="events/emitter_once_eventname_listener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.3.0</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 事件的名称。</li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a> 回调函数</li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>为名为 <code>eventName</code> 的事件添加单次的 <code>listener</code> 函数。
下次触发 <code>eventName</code> 时，将移除此监听器，然后再调用。</p>
<pre><code class="language-js">server.<span class="hljs-title function_">once</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Ah, we have our first user!'</span>);
});</code></pre>
<p>返回对 <code>EventEmitter</code> 的引用，以便可以链式调用。</p>
<p>默认情况下，事件监听器按添加顺序调用。
<code>emitter.prependOnceListener()</code> 方法可用作将事件监听器添加到监听器数组开头的替代方法。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();
myEE.<span class="hljs-title function_">once</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'a'</span>));
myEE.<span class="hljs-title function_">prependOnceListener</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'b'</span>));
myEE.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'foo'</span>);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   b</span>
<span class="hljs-comment">//   a</span></code></pre>
<h4><code>emitter.prependListener(eventName, listener)</code><span><a class="mark" href="#emitterprependlistenereventname-listener" id="emitterprependlistenereventname-listener">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_prependlistener_eventname_listener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitterprependlistenereventname-listener">
<a href="events/emitter_prependlistener_eventname_listener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v6.0.0</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 事件的名称。</li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a> 回调函数</li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>将 <code>listener</code> 函数添加到名为 <code>eventName</code> 的事件的监听器数组的开头。
不检查是否已添加 <code>listener</code>。
多次调用传入相同的 <code>eventName</code> 和 <code>listener</code> 组合将导致多次添加和调用 <code>listener</code>。</p>
<pre><code class="language-js">server.<span class="hljs-title function_">prependListener</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'someone connected!'</span>);
});</code></pre>
<p>返回对 <code>EventEmitter</code> 的引用，以便可以链式调用。</p>
<h4><code>emitter.prependOnceListener(eventName, listener)</code><span><a class="mark" href="#emitterprependoncelistenereventname-listener" id="emitterprependoncelistenereventname-listener">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_prependoncelistener_eventname_listener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitterprependoncelistenereventname-listener">
<a href="events/emitter_prependoncelistener_eventname_listener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v6.0.0</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 事件的名称。</li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a> 回调函数</li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>将名为 <code>eventName</code> 的事件的单次 <code>listener</code> 函数添加到监听器数组的开头。
下次触发 <code>eventName</code> 时，将移除此监听器，然后再调用。</p>
<pre><code class="language-js">server.<span class="hljs-title function_">prependOnceListener</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Ah, we have our first user!'</span>);
});</code></pre>
<p>返回对 <code>EventEmitter</code> 的引用，以便可以链式调用。</p>
<h4><code>emitter.removeAllListeners([eventName])</code><span><a class="mark" href="#emitterremovealllistenerseventname" id="emitterremovealllistenerseventname">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_removealllisteners_eventname"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitterremovealllistenerseventname">
<a href="events/emitter_removealllisteners_eventname.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.1.26</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>删除所有监听器，或指定 <code>eventName</code> 的监听器。</p>
<p>删除在代码其他地方添加的监听器是不好的做法，特别是当 <code>EventEmitter</code> 实例是由其他组件或模块（例如套接字或文件流）创建时。</p>
<p>返回对 <code>EventEmitter</code> 的引用，以便可以链式调用。</p>
<h4><code>emitter.removeListener(eventName, listener)</code><span><a class="mark" href="#emitterremovelistenereventname-listener" id="emitterremovelistenereventname-listener">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_removelistener_eventname_listener"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitterremovelistenereventname-listener">
<a href="events/emitter_removelistener_eventname_listener.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.1.26</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li><code>listener</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a></li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>从名为 <code>eventName</code> 的事件的监听器数组中移除指定的 <code>listener</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">stream</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'someone connected!'</span>);
};
server.<span class="hljs-title function_">on</span>(<span class="hljs-string">'connection'</span>, callback);
<span class="hljs-comment">// ...</span>
server.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'connection'</span>, callback);</code></pre>
<p><code>removeListener()</code> 最多从监听器数组中删除一个监听器实例。
如果任何单个监听器已多次添加到指定 <code>eventName</code> 的监听器数组中，则必须多次调用 <code>removeListener()</code> 以删除每个实例。</p>
<p>这意味着在触发之后和最后一个监听器完成执行之前的任何 <code>removeListener()</code> 或 <code>removeAllListeners()</code> 调用都不会从正在进行的 <code>emit()</code> 中删除它们。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEmitter</span>();

<span class="hljs-keyword">const</span> <span class="hljs-title function_">callbackA</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'A'</span>);
  myEmitter.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'event'</span>, callbackB);
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">callbackB</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'B'</span>);
};

myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, callbackA);

myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'event'</span>, callbackB);

<span class="hljs-comment">// callbackA 删除监听器 callbackB，但它仍将被调用。</span>
<span class="hljs-comment">// 触发时的内部监听器数组 [callbackA, callbackB]</span>
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   A</span>
<span class="hljs-comment">//   B</span>

<span class="hljs-comment">// callbackB 现在被删除了。</span>
<span class="hljs-comment">// 内部监听器数组 [callbackA]</span>
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'event'</span>);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   A</span></code></pre>
<p>由于使用内部数组管理监听器，因此调用此方法将更改在移除监听器后注册的任何监听器的位置索引。
这不会影响调用监听器的顺序，但这意味着需要重新创建 <code>emitter.listeners()</code> 方法返回的监听器数组的任何副本。</p>
<p>当单个函数被多次添加为单个事件的句柄时（如下例所示），则 <code>removeListener()</code> 将删除最近添加的实例。
在示例中，删除了 <code>once('ping')</code> 监听器：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">pong</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'pong'</span>);
}

ee.<span class="hljs-title function_">on</span>(<span class="hljs-string">'ping'</span>, pong);
ee.<span class="hljs-title function_">once</span>(<span class="hljs-string">'ping'</span>, pong);
ee.<span class="hljs-title function_">removeListener</span>(<span class="hljs-string">'ping'</span>, pong);

ee.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'ping'</span>);
ee.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'ping'</span>);</code></pre>
<p>返回对 <code>EventEmitter</code> 的引用，以便可以链式调用。</p>
<h4><code>emitter.setMaxListeners(n)</code><span><a class="mark" href="#emittersetmaxlistenersn" id="emittersetmaxlistenersn">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_setmaxlisteners_n"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emittersetmaxlistenersn">
<a href="events/emitter_setmaxlisteners_n.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v0.3.5</span>
</div>
<ul>
<li><code>n</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type" target="_blank">&lt;integer&gt;</a></li>
<li>返回: <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>默认情况下，如果为特定事件添加了 <code>10</code> 个以上的监听器，则 <code>EventEmitter</code> 将打印警告。
这是一个有用的默认值，有助于查找内存泄漏。
<code>emitter.setMaxListeners()</code> 方法允许修改此特定 <code>EventEmitter</code> 实例的限制。
该值可以设置为 <code>Infinity</code>（或 <code>0</code>）以指示无限数量的监听器。</p>
<p>返回对 <code>EventEmitter</code> 的引用，以便可以链式调用。</p>
<h4><code>emitter.rawListeners(eventName)</code><span><a class="mark" href="#emitterrawlistenerseventname" id="emitterrawlistenerseventname">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_rawlisteners_eventname"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emitterrawlistenerseventname">
<a href="events/emitter_rawlisteners_eventname.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v9.4.0</span>
</div>
<ul>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function[]&gt;</a></li>
</ul>
<p>返回名为 <code>eventName</code> 的事件的监听器数组的副本，包括任何封装器（例如由 <code>.once()</code> 创建的封装器）。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();
emitter.<span class="hljs-title function_">once</span>(<span class="hljs-string">'log'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'log once'</span>));

<span class="hljs-comment">// 返回具有函数 `onceWrapper` 的新数组，</span>
<span class="hljs-comment">// 该函数具有属性 `listener`，其中包含上面绑定的原始监听器</span>
<span class="hljs-keyword">const</span> listeners = emitter.<span class="hljs-title function_">rawListeners</span>(<span class="hljs-string">'log'</span>);
<span class="hljs-keyword">const</span> logFnWrapper = listeners[<span class="hljs-number">0</span>];

<span class="hljs-comment">// 将"log once"记录到控制台并且不会解除 `once` 事件的绑定</span>
logFnWrapper.<span class="hljs-title function_">listener</span>();

<span class="hljs-comment">// 将"log once"记录到控制台并删除监听器</span>
<span class="hljs-title function_">logFnWrapper</span>();

emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'log'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'log persistently'</span>));
<span class="hljs-comment">// 将返回新数组，其中包含由上面的 `.on()` 绑定的函数</span>
<span class="hljs-keyword">const</span> newListeners = emitter.<span class="hljs-title function_">rawListeners</span>(<span class="hljs-string">'log'</span>);

<span class="hljs-comment">// 记录"log persistently"两次</span>
newListeners[<span class="hljs-number">0</span>]();
emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'log'</span>);</code></pre>
<h4><code>emitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])</code><span><a class="mark" href="#emittersymbolfornodejsrejectionerr-eventname-args" id="emittersymbolfornodejsrejectionerr-eventname-args">#</a></span><a aria-hidden="true" class="legacy" id="events_emitter_symbol_for_nodejs_rejection_err_eventname_args"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#emittersymbolfornodejsrejectionerr-eventname-args">
<a href="events/emitter_symbol_for_nodejs_rejection_err_eventname_args.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v12.16.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="/api/documentation.html#stability-index">稳定性: 1</a> - captureRejections 是实验的。</div><p></p>
<ul>
<li><code>err</code> 错误</li>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a></li>
<li><code>...args</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type" target="_blank">&lt;any&gt;</a></li>
</ul>
<p><code>Symbol.for('nodejs.rejection')</code> 方法被调用，以防在触发事件时发生 promise 拒绝，并且在触发器上启用了 <a href="/api-v12/events.html#events_capture_rejections_of_promises"><code>captureRejections</code></a>。
可以使用 <a href="/api-v12/events.html#events_events_capturerejectionsymbol"><code>events.captureRejectionSymbol</code></a> 代替 <code>Symbol.for('nodejs.rejection')</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">EventEmitter</span>, captureRejectionSymbol } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">EventEmitter</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>({ <span class="hljs-attr">captureRejections</span>: <span class="hljs-literal">true</span> });
  }

  [captureRejectionSymbol](err, event, ...args) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'rejection happened for'</span>, event, <span class="hljs-string">'with'</span>, err, ...args);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">destroy</span>(err);
  }

  <span class="hljs-title function_">destroy</span>(<span class="hljs-params">err</span>) {
    <span class="hljs-comment">// 把这里的资源卸除。</span>
  }
}</code></pre>
</section><section><h3><code>events.once(emitter, name)</code><span><a class="mark" href="#eventsonceemitter-name" id="eventsonceemitter-name">#</a></span><a aria-hidden="true" class="legacy" id="events_events_once_emitter_name"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#eventsonceemitter-name">
<a href="events/events_once_emitter_name.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v11.13.0</span>
</div>
<ul>
<li><code>emitter</code> <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
<li><code>name</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/ri1kj8" rel="nofollow" class="type" target="_blank">&lt;Promise&gt;</a></li>
</ul>
<p>创建 <code>Promise</code>，其在 <code>EventEmitter</code> 触发给定事件时被履行，或者如果 <code>EventEmitter</code> 在等待时触发 <code>'error'</code> 则被拒绝。
<code>Promise</code> 将使用触发给定事件的所有参数的数组解决。</p>
<p>此方法有意通用，与 Web 平台 <a href="http://url.nodejs.cn/zSu9eM" rel="nofollow" target="_blank">EventTarget</a> 接口配合使用，该接口没有特殊的 <code>'error'</code> 事件语义，也不监听 <code>'error'</code> 事件。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { once, <span class="hljs-title class_">EventEmitter</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

  process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
    ee.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'myevent'</span>, <span class="hljs-number">42</span>);
  });

  <span class="hljs-keyword">const</span> [value] = <span class="hljs-keyword">await</span> <span class="hljs-title function_">once</span>(ee, <span class="hljs-string">'myevent'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);

  <span class="hljs-keyword">const</span> err = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'kaboom'</span>);
  process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
    ee.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'error'</span>, err);
  });

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">once</span>(ee, <span class="hljs-string">'myevent'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'error happened'</span>, err);
  }
}

<span class="hljs-title function_">run</span>();</code></pre>
<p><code>'error'</code> 事件的特殊处理仅在 <code>events.once()</code> 用于等待另一个事件时使用。
如果 <code>events.once()</code> 用于等待 <code>error'</code> 事件本身，则它将被视为任何其他类型的事件而无需特殊处理：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">EventEmitter</span>, once } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);

<span class="hljs-keyword">const</span> ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-title function_">once</span>(ee, <span class="hljs-string">'error'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">[err]</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'ok'</span>, err.<span class="hljs-property">message</span>))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'error'</span>, err.<span class="hljs-property">message</span>));

ee.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'error'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'boom'</span>));

<span class="hljs-comment">// 打印: ok boom</span></code></pre>
<h4>等待 process.nextTick() 上触发的多个事件<span><a class="mark" href="#awaiting-multiple-events-emitted-on-processnexttick" id="awaiting-multiple-events-emitted-on-processnexttick">#</a></span><a aria-hidden="true" class="legacy" id="events_awaiting_multiple_events_emitted_on_process_nexttick"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#awaiting-multiple-events-emitted-on-processnexttick">
<a href="events/awaiting_multiple_events_emitted_on_process_nexttick.html" class="tip_trans">中英对照</a>
</p>
<p>当使用 <code>events.once()</code> 函数等待在同一批 <code>process.nextTick()</code> 操作中触发的多个事件时，或者同步触发多个事件时，有一个边缘情况值得注意。
具体来说，因为 <code>process.nextTick()</code> 队列在 <code>Promise</code> 微任务队列之前被排空，并且因为 <code>EventEmitter</code> 同步触发所有事件，所以 <code>events.once()</code> 有可能错过事件。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">EventEmitter</span>, once } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);

<span class="hljs-keyword">const</span> myEE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">once</span>(myEE, <span class="hljs-string">'bar'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'bar'</span>);

  <span class="hljs-comment">// 此 Promise 永远不会被解决，</span>
  <span class="hljs-comment">// 因为 'foo' 事件在 Promise 被创建之前就已经触发了。</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">once</span>(myEE, <span class="hljs-string">'foo'</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo'</span>);
}

process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
  myEE.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'bar'</span>);
  myEE.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'foo'</span>);
});

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>));</code></pre>
<p>要捕获这两个事件，则在等待其中一个之前创建每个 Promise，然后可以使用 <code>Promise.all()</code>、<code>Promise.race()</code> 或 <code>Promise.allSettled()</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">EventEmitter</span>, once } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);

<span class="hljs-keyword">const</span> myEE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">once</span>(myEE, <span class="hljs-string">'bar'</span>), <span class="hljs-title function_">once</span>(myEE, <span class="hljs-string">'foo'</span>)]);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>);
}

process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
  myEE.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'bar'</span>);
  myEE.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'foo'</span>);
});

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'done'</span>));</code></pre>
</section><section><h3><code>events.captureRejections</code><span><a class="mark" href="#eventscapturerejections" id="eventscapturerejections">#</a></span><a aria-hidden="true" class="legacy" id="events_events_capturerejections"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#eventscapturerejections">
<a href="events/events_capturerejections.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v12.16.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="/api/documentation.html#stability-index">稳定性: 1</a> - captureRejections 是实验的。</div><p></p>
<p>值: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type" target="_blank">&lt;boolean&gt;</a></p>
<p>更改所有新的 <code>EventEmitter</code> 对象的默认 <code>captureRejections</code> 选项。</p>
</section><section><h3>events.captureRejectionSymbol<span><a class="mark" href="#eventscapturerejectionsymbol" id="eventscapturerejectionsymbol">#</a></span><a aria-hidden="true" class="legacy" id="events_events_capturerejectionsymbol"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#eventscapturerejectionsymbol">
<a href="events/events_capturerejectionsymbol.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v12.16.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="/api/documentation.html#stability-index">稳定性: 1</a> - captureRejections 是实验的。</div><p></p>
<p>值: <code>Symbol.for('nodejs.rejection')</code></p>
<p>了解如何编写自定义的<a href="/api-v12/events.html#events_emitter_symbol_for_nodejs_rejection_err_eventname_args">拒绝句柄</a>。</p>
</section><section><h3>events.on(emitter, eventName)<span><a class="mark" href="#eventsonemitter-eventname" id="eventsonemitter-eventname">#</a></span><a aria-hidden="true" class="legacy" id="events_events_on_emitter_eventname"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#eventsonemitter-eventname">
<a href="events/events_on_emitter_eventname.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v12.16.0</span>
</div>
<ul>
<li><code>emitter</code> <a href="/api/events.html#class-eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
<li><code>eventName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type" target="_blank">&lt;symbol&gt;</a> 正在监听的事件的名称</li>
<li>返回: <a href="http://url.nodejs.cn/HnG4ws" rel="nofollow" class="type" target="_blank">&lt;AsyncIterator&gt;</a> 迭代由 <code>emitter</code> 触发的 <code>eventName</code> 事件</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { on, <span class="hljs-title class_">EventEmitter</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);

(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> ee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

  <span class="hljs-comment">// 稍后触发</span>
  process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> {
    ee.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>);
    ee.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'foo'</span>, <span class="hljs-number">42</span>);
  });

  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> event <span class="hljs-keyword">of</span> <span class="hljs-title function_">on</span>(ee, <span class="hljs-string">'foo'</span>)) {
    <span class="hljs-comment">// 此内部块的执行是同步的，</span>
    <span class="hljs-comment">// 且每次处理一个事件（即使有等待）。</span>
    <span class="hljs-comment">// 如果需要并发执行，则不要使用。</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event); <span class="hljs-comment">// 打印 ['bar'] [42]</span>
  }
  <span class="hljs-comment">// 此处无法到达</span>
})();</code></pre>
<p>返回迭代 <code>eventName</code> 事件的 <code>AsyncIterator</code>。
如果 <code>EventEmitter</code> 触发 <code>'error'</code>，则将抛出错误。
它在退出循环时删除所有监听器。
每次迭代返回的 <code>value</code> 是由触发的事件参数组成的数组。</p></section>
</div>
</div>
</div>
<div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
<div id="wxcode_box" style="display: none;">
<div id="wxcode_img_box">
<img id="wxcode_img">
<div id="wxcode_img_tips">微信扫码登录</div>
</div>
</div>
<script>
    window._API_NAME = "events";
    window._UPDATE_TIME = "20220728214329";
  </script>

</body></html>