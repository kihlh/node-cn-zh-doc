<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>crypto 加密 | Node.js API 文档</title>
  <link rel="icon" sizes="32x32" type="image/png" href="//static.nodejs.cn/_static/img/favicon.png">
  <link href="css/api.css?1625411136855" rel="stylesheet">
</head>

<body class="alt apidoc" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="/" rel="nofollow">
          Node.js 中文网
        </a>

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.4.1</a></li>
        </ul> -->
      <div id="biz_nav"><a title="云服务器" target="_blank" rel="nofollow"><img></a></div>
      <div class="line"></div>
      <ul>
<li><a href="assert.html" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="buffer.html" rel="nofollow">Buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="child_process.html" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="console.html" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="crypto.html" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="debugger.html" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="dgram.html" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="net.html" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="process.html" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="string_decoder.html" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" rel="nofollow">timer<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" rel="nofollow">wasi<span class="api_nav_cn_name">WebAssembly系统接口</span></a></li>
<li><a href="webcrypto.html" rel="nofollow">webcrypto<span class="api_nav_cn_name">Web加密</span></a></li>
<li><a href="worker_threads.html" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>
<hr class="line">
<ul>
<li><a href="documentation.html" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" rel="nofollow">用法与示例</a></li>
<li><a href="cli.html" rel="nofollow">命令行选项</a></li>
<li><a href="modules.html" rel="nofollow">CommonJS<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="esm.html" rel="nofollow">ECMAScript<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="packages.html" rel="nofollow">包模块</a></li>
<li><a href="addons.html" rel="nofollow">C++<span class="api_nav_cn_name">插件</span></a></li>
<li><a href="embedding.html" rel="nofollow">C++<span class="api_nav_cn_name">嵌入器</span></a></li>
<li><a href="n-api.html" rel="nofollow">N-API</a></li>
<li><a href="async_context.html" rel="nofollow">异步上下文跟踪</a></li>
<li><a href="policy.html" rel="nofollow">安全策略</a></li>
<li><a href="deprecations.html" rel="nofollow">弃用的<span class="api_nav_cn_name">API</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="crypto" class="interior">
      <header>
        <div class="header-container">
          <h1>Node.js v16.4.1 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li>
              <a href="./">返回文档首页</a>
            </li>
            <li>
              <a href="http://api.nodejs.cn/">搜索</a>
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#crypto_crypto">crypto 加密</a></span>
<ul>
<li><a href="#crypto_determining_if_crypto_support_is_unavailable">确定加密支持是否不可用</a></li>
<li><a href="#crypto_class_certificate"><code>Certificate</code> 类</a>
<ul>
<li><a href="#crypto_static_method_certificate_exportchallenge_spkac_encoding"><code>Certificate.exportChallenge(spkac[, encoding])</code></a></li>
<li><a href="#crypto_static_method_certificate_exportpublickey_spkac_encoding"><code>Certificate.exportPublicKey(spkac[, encoding])</code></a></li>
<li><a href="#crypto_static_method_certificate_verifyspkac_spkac_encoding"><code>Certificate.verifySpkac(spkac[, encoding])</code></a></li>
<li><span class="stability_0"><a href="#crypto_legacy_api">旧版的 API</a></span>
<ul>
<li><a href="#crypto_new_crypto_certificate"><code>new crypto.Certificate()</code></a></li>
<li><a href="#crypto_certificate_exportchallenge_spkac_encoding"><code>certificate.exportChallenge(spkac[, encoding])</code></a></li>
<li><a href="#crypto_certificate_exportpublickey_spkac_encoding"><code>certificate.exportPublicKey(spkac[, encoding])</code></a></li>
<li><a href="#crypto_certificate_verifyspkac_spkac_encoding"><code>certificate.verifySpkac(spkac[, encoding])</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#crypto_class_cipher"><code>Cipher</code> 类</a>
<ul>
<li><a href="#crypto_cipher_final_outputencoding"><code>cipher.final([outputEncoding])</code></a></li>
<li><a href="#crypto_cipher_getauthtag"><code>cipher.getAuthTag()</code></a></li>
<li><a href="#crypto_cipher_setaad_buffer_options"><code>cipher.setAAD(buffer[, options])</code></a></li>
<li><a href="#crypto_cipher_setautopadding_autopadding"><code>cipher.setAutoPadding([autoPadding])</code></a></li>
<li><a href="#crypto_cipher_update_data_inputencoding_outputencoding"><code>cipher.update(data[, inputEncoding][, outputEncoding])</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_decipher"><code>Decipher</code> 类</a>
<ul>
<li><a href="#crypto_decipher_final_outputencoding"><code>decipher.final([outputEncoding])</code></a></li>
<li><a href="#crypto_decipher_setaad_buffer_options"><code>decipher.setAAD(buffer[, options])</code></a></li>
<li><a href="#crypto_decipher_setauthtag_buffer_encoding"><code>decipher.setAuthTag(buffer[, encoding])</code></a></li>
<li><a href="#crypto_decipher_setautopadding_autopadding"><code>decipher.setAutoPadding([autoPadding])</code></a></li>
<li><a href="#crypto_decipher_update_data_inputencoding_outputencoding"><code>decipher.update(data[, inputEncoding][, outputEncoding])</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_diffiehellman"><code>DiffieHellman</code> 类</a>
<ul>
<li><a href="#crypto_diffiehellman_computesecret_otherpublickey_inputencoding_outputencoding"><code>diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])</code></a></li>
<li><a href="#crypto_diffiehellman_generatekeys_encoding"><code>diffieHellman.generateKeys([encoding])</code></a></li>
<li><a href="#crypto_diffiehellman_getgenerator_encoding"><code>diffieHellman.getGenerator([encoding])</code></a></li>
<li><a href="#crypto_diffiehellman_getprime_encoding"><code>diffieHellman.getPrime([encoding])</code></a></li>
<li><a href="#crypto_diffiehellman_getprivatekey_encoding"><code>diffieHellman.getPrivateKey([encoding])</code></a></li>
<li><a href="#crypto_diffiehellman_getpublickey_encoding"><code>diffieHellman.getPublicKey([encoding])</code></a></li>
<li><a href="#crypto_diffiehellman_setprivatekey_privatekey_encoding"><code>diffieHellman.setPrivateKey(privateKey[, encoding])</code></a></li>
<li><a href="#crypto_diffiehellman_setpublickey_publickey_encoding"><code>diffieHellman.setPublicKey(publicKey[, encoding])</code></a></li>
<li><a href="#crypto_diffiehellman_verifyerror"><code>diffieHellman.verifyError</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_diffiehellmangroup"><code>DiffieHellmanGroup</code> 类</a></li>
<li><a href="#crypto_class_ecdh"><code>ECDH</code> 类</a>
<ul>
<li><a href="#crypto_static_method_ecdh_convertkey_key_curve_inputencoding_outputencoding_format"><code>ECDH.convertKey(key, curve[, inputEncoding[, outputEncoding[, format]]])</code></a></li>
<li><a href="#crypto_ecdh_computesecret_otherpublickey_inputencoding_outputencoding"><code>ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])</code></a></li>
<li><a href="#crypto_ecdh_generatekeys_encoding_format"><code>ecdh.generateKeys([encoding[, format]])</code></a></li>
<li><a href="#crypto_ecdh_getprivatekey_encoding"><code>ecdh.getPrivateKey([encoding])</code></a></li>
<li><a href="#crypto_ecdh_getpublickey_encoding_format"><code>ecdh.getPublicKey([encoding][, format])</code></a></li>
<li><a href="#crypto_ecdh_setprivatekey_privatekey_encoding"><code>ecdh.setPrivateKey(privateKey[, encoding])</code></a></li>
<li><span class="stability_0"><a href="#crypto_ecdh_setpublickey_publickey_encoding"><code>ecdh.setPublicKey(publicKey[, encoding])</code></a></span></li>
</ul>
</li>
<li><a href="#crypto_class_hash"><code>Hash</code> 类</a>
<ul>
<li><a href="#crypto_hash_copy_options"><code>hash.copy([options])</code></a></li>
<li><a href="#crypto_hash_digest_encoding"><code>hash.digest([encoding])</code></a></li>
<li><a href="#crypto_hash_update_data_inputencoding"><code>hash.update(data[, inputEncoding])</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_hmac"><code>Hmac</code> 类</a>
<ul>
<li><a href="#crypto_hmac_digest_encoding"><code>hmac.digest([encoding])</code></a></li>
<li><a href="#crypto_hmac_update_data_inputencoding"><code>hmac.update(data[, inputEncoding])</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_keyobject"><code>KeyObject</code> 类</a>
<ul>
<li><a href="#crypto_static_method_keyobject_from_key"><code>KeyObject.from(key)</code></a></li>
<li><a href="#crypto_keyobject_asymmetrickeydetails"><code>keyObject.asymmetricKeyDetails</code></a></li>
<li><a href="#crypto_keyobject_asymmetrickeytype"><code>keyObject.asymmetricKeyType</code></a></li>
<li><a href="#crypto_keyobject_export_options"><code>keyObject.export([options])</code></a></li>
<li><a href="#crypto_keyobject_symmetrickeysize"><code>keyObject.symmetricKeySize</code></a></li>
<li><a href="#crypto_keyobject_type"><code>keyObject.type</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_sign"><code>Sign</code> 类</a>
<ul>
<li><a href="#crypto_sign_sign_privatekey_outputencoding"><code>sign.sign(privateKey[, outputEncoding])</code></a></li>
<li><a href="#crypto_sign_update_data_inputencoding"><code>sign.update(data[, inputEncoding])</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_verify"><code>Verify</code> 类</a>
<ul>
<li><a href="#crypto_verify_update_data_inputencoding"><code>verify.update(data[, inputEncoding])</code></a></li>
<li><a href="#crypto_verify_verify_object_signature_signatureencoding"><code>verify.verify(object, signature[, signatureEncoding])</code></a></li>
</ul>
</li>
<li><a href="#crypto_class_x509certificate"><code>X509Certificate</code> 类</a>
<ul>
<li><a href="#crypto_new_x509certificate_buffer"><code>new X509Certificate(buffer)</code></a></li>
<li><a href="#crypto_x509_ca"><code>x509.ca</code></a></li>
<li><a href="#crypto_x509_checkemail_email_options"><code>x509.checkEmail(email[, options])</code></a></li>
<li><a href="#crypto_x509_checkhost_name_options"><code>x509.checkHost(name[, options])</code></a></li>
<li><a href="#crypto_x509_checkip_ip_options"><code>x509.checkIP(ip[, options])</code></a></li>
<li><a href="#crypto_x509_checkissued_othercert"><code>x509.checkIssued(otherCert)</code></a></li>
<li><a href="#crypto_x509_checkprivatekey_privatekey"><code>x509.checkPrivateKey(privateKey)</code></a></li>
<li><a href="#crypto_x509_fingerprint"><code>x509.fingerprint</code></a></li>
<li><a href="#crypto_x509_fingerprint256"><code>x509.fingerprint256</code></a></li>
<li><a href="#crypto_x509_infoaccess"><code>x509.infoAccess</code></a></li>
<li><a href="#crypto_x509_issuer"><code>x509.issuer</code></a></li>
<li><a href="#crypto_x509_issuercertificate"><code>x509.issuerCertificate</code></a></li>
<li><a href="#crypto_x509_keyusage"><code>x509.keyUsage</code></a></li>
<li><a href="#crypto_x509_publickey"><code>x509.publicKey</code></a></li>
<li><a href="#crypto_x509_raw"><code>x509.raw</code></a></li>
<li><a href="#crypto_x509_serialnumber"><code>x509.serialNumber</code></a></li>
<li><a href="#crypto_x509_subject"><code>x509.subject</code></a></li>
<li><a href="#crypto_x509_subjectaltname"><code>x509.subjectAltName</code></a></li>
<li><a href="#crypto_x509_tojson"><code>x509.toJSON()</code></a></li>
<li><a href="#crypto_x509_tolegacyobject"><code>x509.toLegacyObject()</code></a></li>
<li><a href="#crypto_x509_tostring"><code>x509.toString()</code></a></li>
<li><a href="#crypto_x509_validfrom"><code>x509.validFrom</code></a></li>
<li><a href="#crypto_x509_validto"><code>x509.validTo</code></a></li>
<li><a href="#crypto_x509_verify_publickey"><code>x509.verify(publicKey)</code></a></li>
</ul>
</li>
<li><a href="#crypto_crypto_module_methods_and_properties">加密模块的方法和属性</a>
<ul>
<li><a href="#crypto_crypto_constants"><code>crypto.constants</code></a></li>
<li><span class="stability_0"><a href="#crypto_crypto_default_encoding"><code>crypto.DEFAULT_ENCODING</code></a></span></li>
<li><span class="stability_0"><a href="#crypto_crypto_fips"><code>crypto.fips</code></a></span></li>
<li><a href="#crypto_crypto_checkprime_candidate_options_callback"><code>crypto.checkPrime(candidate[, options, [callback]])</code></a></li>
<li><a href="#crypto_crypto_checkprimesync_candidate_options"><code>crypto.checkPrimeSync(candidate[, options])</code></a></li>
<li><span class="stability_0"><a href="#crypto_crypto_createcipher_algorithm_password_options"><code>crypto.createCipher(algorithm, password[, options])</code></a></span></li>
<li><a href="#crypto_crypto_createcipheriv_algorithm_key_iv_options"><code>crypto.createCipheriv(algorithm, key, iv[, options])</code></a></li>
<li><span class="stability_0"><a href="#crypto_crypto_createdecipher_algorithm_password_options"><code>crypto.createDecipher(algorithm, password[, options])</code></a></span></li>
<li><a href="#crypto_crypto_createdecipheriv_algorithm_key_iv_options"><code>crypto.createDecipheriv(algorithm, key, iv[, options])</code></a></li>
<li><a href="#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding"><code>crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])</code></a></li>
<li><a href="#crypto_crypto_creatediffiehellman_primelength_generator"><code>crypto.createDiffieHellman(primeLength[, generator])</code></a></li>
<li><a href="#crypto_crypto_creatediffiehellmangroup_name"><code>crypto.createDiffieHellmanGroup(name)</code></a></li>
<li><a href="#crypto_crypto_createecdh_curvename"><code>crypto.createECDH(curveName)</code></a></li>
<li><a href="#crypto_crypto_createhash_algorithm_options"><code>crypto.createHash(algorithm[, options])</code></a></li>
<li><a href="#crypto_crypto_createhmac_algorithm_key_options"><code>crypto.createHmac(algorithm, key[, options])</code></a></li>
<li><a href="#crypto_crypto_createprivatekey_key"><code>crypto.createPrivateKey(key)</code></a></li>
<li><a href="#crypto_crypto_createpublickey_key"><code>crypto.createPublicKey(key)</code></a></li>
<li><a href="#crypto_crypto_createsecretkey_key_encoding"><code>crypto.createSecretKey(key[, encoding])</code></a></li>
<li><a href="#crypto_crypto_createsign_algorithm_options"><code>crypto.createSign(algorithm[, options])</code></a></li>
<li><a href="#crypto_crypto_createverify_algorithm_options"><code>crypto.createVerify(algorithm[, options])</code></a></li>
<li><a href="#crypto_crypto_diffiehellman_options"><code>crypto.diffieHellman(options)</code></a></li>
<li><a href="#crypto_crypto_generatekey_type_options_callback"><code>crypto.generateKey(type, options, callback)</code></a></li>
<li><a href="#crypto_crypto_generatekeypair_type_options_callback"><code>crypto.generateKeyPair(type, options, callback)</code></a></li>
<li><a href="#crypto_crypto_generatekeypairsync_type_options"><code>crypto.generateKeyPairSync(type, options)</code></a></li>
<li><a href="#crypto_crypto_generatekeysync_type_options"><code>crypto.generateKeySync(type, options)</code></a></li>
<li><a href="#crypto_crypto_generateprime_size_options_callback"><code>crypto.generatePrime(size[, options[, callback]])</code></a></li>
<li><a href="#crypto_crypto_generateprimesync_size_options"><code>crypto.generatePrimeSync(size[, options])</code></a></li>
<li><a href="#crypto_crypto_getcipherinfo_nameornid_options"><code>crypto.getCipherInfo(nameOrNid[, options])</code></a></li>
<li><a href="#crypto_crypto_getciphers"><code>crypto.getCiphers()</code></a></li>
<li><a href="#crypto_crypto_getcurves"><code>crypto.getCurves()</code></a></li>
<li><a href="#crypto_crypto_getdiffiehellman_groupname"><code>crypto.getDiffieHellman(groupName)</code></a></li>
<li><a href="#crypto_crypto_getfips"><code>crypto.getFips()</code></a></li>
<li><a href="#crypto_crypto_gethashes"><code>crypto.getHashes()</code></a></li>
<li><a href="#crypto_crypto_hkdf_digest_key_salt_info_keylen_callback"><code>crypto.hkdf(digest, key, salt, info, keylen, callback)</code></a></li>
<li><a href="#crypto_crypto_hkdfsync_digest_key_salt_info_keylen"><code>crypto.hkdfSync(digest, key, salt, info, keylen)</code></a></li>
<li><a href="#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback"><code>crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)</code></a></li>
<li><a href="#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest"><code>crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)</code></a></li>
<li><a href="#crypto_crypto_privatedecrypt_privatekey_buffer"><code>crypto.privateDecrypt(privateKey, buffer)</code></a></li>
<li><a href="#crypto_crypto_privateencrypt_privatekey_buffer"><code>crypto.privateEncrypt(privateKey, buffer)</code></a></li>
<li><a href="#crypto_crypto_publicdecrypt_key_buffer"><code>crypto.publicDecrypt(key, buffer)</code></a></li>
<li><a href="#crypto_crypto_publicencrypt_key_buffer"><code>crypto.publicEncrypt(key, buffer)</code></a></li>
<li><a href="#crypto_crypto_randombytes_size_callback"><code>crypto.randomBytes(size[, callback])</code></a></li>
<li><a href="#crypto_crypto_randomfillsync_buffer_offset_size"><code>crypto.randomFillSync(buffer[, offset][, size])</code></a></li>
<li><a href="#crypto_crypto_randomfill_buffer_offset_size_callback"><code>crypto.randomFill(buffer[, offset][, size], callback)</code></a></li>
<li><a href="#crypto_crypto_randomint_min_max_callback"><code>crypto.randomInt([min, ]max[, callback])</code></a></li>
<li><a href="#crypto_crypto_randomuuid_options"><code>crypto.randomUUID([options])</code></a></li>
<li><a href="#crypto_crypto_scrypt_password_salt_keylen_options_callback"><code>crypto.scrypt(password, salt, keylen[, options], callback)</code></a></li>
<li><a href="#crypto_crypto_scryptsync_password_salt_keylen_options"><code>crypto.scryptSync(password, salt, keylen[, options])</code></a></li>
<li><a href="#crypto_crypto_secureheapused"><code>crypto.secureHeapUsed()</code></a></li>
<li><a href="#crypto_crypto_setengine_engine_flags"><code>crypto.setEngine(engine[, flags])</code></a></li>
<li><a href="#crypto_crypto_setfips_bool"><code>crypto.setFips(bool)</code></a></li>
<li><a href="#crypto_crypto_sign_algorithm_data_key_callback"><code>crypto.sign(algorithm, data, key[, callback])</code></a></li>
<li><a href="#crypto_crypto_timingsafeequal_a_b"><code>crypto.timingSafeEqual(a, b)</code></a></li>
<li><a href="#crypto_crypto_verify_algorithm_data_key_signature_callback"><code>crypto.verify(algorithm, data, key, signature[, callback])</code></a></li>
<li><a href="#crypto_crypto_webcrypto"><code>crypto.webcrypto</code></a></li>
</ul>
</li>
<li><a href="#crypto_notes">注意事项</a>
<ul>
<li><a href="#crypto_using_strings_as_inputs_to_cryptographic_apis">使用字符串作为加密 API 的输入</a></li>
<li><a href="#crypto_legacy_streams_api_prior_to_node_js_0_10">旧版的流 API（Node.js v0.10 之前）</a></li>
<li><a href="#crypto_recent_ecdh_changes">ECDH 近期的变化</a></li>
<li><a href="#crypto_support_for_weak_or_compromised_algorithms">弱算法或受损算法的支持</a></li>
<li><a href="#crypto_ccm_mode">CCM 模式</a></li>
</ul>
</li>
<li><a href="#crypto_crypto_constants_1">加密常量</a>
<ul>
<li><a href="#crypto_openssl_options">OpenSSL 选项</a></li>
<li><a href="#crypto_openssl_engine_constants">OpenSSL 引擎的常量</a></li>
<li><a href="#crypto_other_openssl_constants">其他 OpenSSL 常量</a></li>
<li><a href="#crypto_node_js_crypto_constants">Node.js 加密常量</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <!-- <div id="biz_content">
          <a href="http://www.tp-shop.cn/index.php?http_referer=node" target="_blank">
            <img src="//static.nodejs.cn/_static/img/ad/api_content_tpshop.jpg" />
          </a>
        </div> -->

      <div id="apicontent">
        <h2>crypto 加密<span><a class="mark" href="#crypto_crypto" id="crypto_crypto">#</a></span></h2><p class="tip_wrap" data-show_trans="1" data-item_id="crypto">
                <a href="crypto/crypto.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.3.6-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">稳定性: 2</a> - 稳定</div><p></p>
<p><strong>源代码:</strong> <a rel="nofollow" href="http://url.nodejs.cn/GeavFG">lib/crypto.js</a></p>
<p><code>crypto</code> 模块提供了加密功能，其中包括了用于 OpenSSL 散列、HMAC、加密、解密、签名、以及验证的函数的一整套封装。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> { createHmac } <span class="hljs-keyword">from</span> <span class="hljs-string">'crypto'</span>;

<span class="hljs-keyword">const</span> secret = <span class="hljs-string">'abcdefg'</span>;
<span class="hljs-keyword">const</span> hash = createHmac(<span class="hljs-string">'sha256'</span>, secret)
               .update(<span class="hljs-string">'I love cupcakes'</span>)
               .digest(<span class="hljs-string">'hex'</span>);
<span class="hljs-built_in">console</span>.log(hash);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> secret = <span class="hljs-string">'abcdefg'</span>;
<span class="hljs-keyword">const</span> hash = crypto.createHmac(<span class="hljs-string">'sha256'</span>, secret)
                   .update(<span class="hljs-string">'I love cupcakes'</span>)
                   .digest(<span class="hljs-string">'hex'</span>);
<span class="hljs-built_in">console</span>.log(hash);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e</span></code></pre>
<section><h3>确定加密支持是否不可用<span><a class="mark" href="#crypto_determining_if_crypto_support_is_unavailable" id="crypto_determining_if_crypto_support_is_unavailable">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="determining_if_crypto_support_is_unavailable">
                <a href="crypto/determining_if_crypto_support_is_unavailable.html" class="tip_trans">中英对照</a>
                </p>
<p>可以在不支持 <code>crypto</code> 模块的情况下构建 Node.js。
在这种情况下，尝试 <code>import</code> <code>crypto</code> 或调用 <code>require('crypto')</code> 将导致抛出错误。</p>
<p>使用 CommonJS 时，可以使用 try/catch 捕获抛出的错误：</p>
<pre><code class="language-js cjs"><span class="hljs-keyword">let</span> crypto;
<span class="hljs-keyword">try</span> {
  crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'crypto support is disabled!'</span>);
}</code></pre>
<p>当使用 ESM <code>import</code> 关键字时，只有在尝试加载模块（例如，使用预加载模块）之前注册了 <code>process.on('uncaughtException')</code> 的句柄，才能捕获到错误。</p>
<p>使用 ESM 时，如果有可能在未启用加密支持的 Node.js 版本上运行代码，则考虑使用 <code>import()</code> 函数而不是 <code>import</code> 关键字：</p>
<pre><code class="language-js mjs"><span class="hljs-keyword">let</span> crypto;
<span class="hljs-keyword">try</span> {
  crypto = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'crypto support is disabled!'</span>);
}</code></pre>
</section><section><h3><code>Certificate</code> 类<span><a class="mark" href="#crypto_class_certificate" id="crypto_class_certificate">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_certificate">
                <a href="crypto/class_certificate.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.8</span>
</div>
<p>SPKAC 是最初由 Netscape 实现的证书签名请求机制，并被正式指定为 <a href="http://url.nodejs.cn/2T24oh">HTML5 的 <code>keygen</code> 元素</a>的一部分。</p>
<p><code>&lt;keygen&gt;</code> 已弃用，因为 <a href="http://url.nodejs.cn/WMZ1Ef">HTML 5.2</a> 和新项目不应再使用此元素。</p>
<p><code>crypto</code> 模块提供了用于处理 SPKAC 数据的 <code>Certificate</code> 类。
最常见的用法是处理由 HTML5 <code>&lt;keygen&gt;</code> 元素生成的输出。
Node.js 在内部使用 <a href="http://url.nodejs.cn/qh2GSY">OpenSSL 的 SPKAC 实现</a>。</p>
<h4><code>Certificate.exportChallenge(spkac[, encoding])</code><span><a class="mark" href="#crypto_static_method_certificate_exportchallenge_spkac_encoding" id="crypto_static_method_certificate_exportchallenge_spkac_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="static_method_certificate_exportchallenge_spkac_encoding">
                <a href="crypto/static_method_certificate_exportchallenge_spkac_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>参数 spkac 可以是 ArrayBuffer。 将 spkac 参数的大小限制为最大 2**31 - 1 个字节。</p></td></tr>
<tr><td>v9.0.0</td>
<td><p><span>新增于: v9.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>spkac</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>spkac</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> <code>spkac</code> 数据结构的挑战组件，包括公钥和挑战。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> challenge = Certificate.exportChallenge(spkac);
<span class="hljs-built_in">console</span>.log(challenge.toString(<span class="hljs-string">'utf8'</span>));
<span class="hljs-comment">// 打印: the challenge as a UTF8 string</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> challenge = Certificate.exportChallenge(spkac);
<span class="hljs-built_in">console</span>.log(challenge.toString(<span class="hljs-string">'utf8'</span>));
<span class="hljs-comment">// 打印: the challenge as a UTF8 string</span></code></pre>
<h4><code>Certificate.exportPublicKey(spkac[, encoding])</code><span><a class="mark" href="#crypto_static_method_certificate_exportpublickey_spkac_encoding" id="crypto_static_method_certificate_exportpublickey_spkac_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="static_method_certificate_exportpublickey_spkac_encoding">
                <a href="crypto/static_method_certificate_exportpublickey_spkac_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>参数 spkac 可以是 ArrayBuffer。 将 spkac 参数的大小限制为最大 2**31 - 1 个字节。</p></td></tr>
<tr><td>v9.0.0</td>
<td><p><span>新增于: v9.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>spkac</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>spkac</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> <code>spkac</code> 数据结构的公钥组件，包括公钥和挑战。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> publicKey = Certificate.exportPublicKey(spkac);
<span class="hljs-built_in">console</span>.log(publicKey);
<span class="hljs-comment">// 打印: the public key as &lt;Buffer ...&gt;</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> publicKey = Certificate.exportPublicKey(spkac);
<span class="hljs-built_in">console</span>.log(publicKey);
<span class="hljs-comment">// 打印: the public key as &lt;Buffer ...&gt;</span></code></pre>
<h4><code>Certificate.verifySpkac(spkac[, encoding])</code><span><a class="mark" href="#crypto_static_method_certificate_verifyspkac_spkac_encoding" id="crypto_static_method_certificate_verifyspkac_spkac_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="static_method_certificate_verifyspkac_spkac_encoding">
                <a href="crypto/static_method_certificate_verifyspkac_spkac_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>参数 spkac 可以是 ArrayBuffer。 添加了编码。 将 spkac 参数的大小限制为最大 2**31 - 1 个字节。</p></td></tr>
<tr><td>v9.0.0</td>
<td><p><span>新增于: v9.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>spkac</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>spkac</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果给定的 <code>spkac</code> 数据结构有效，则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-built_in">console</span>.log(Certificate.verifySpkac(Buffer.from(spkac)));
<span class="hljs-comment">// 打印: true 或 false</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-built_in">console</span>.log(Certificate.verifySpkac(Buffer.from(spkac)));
<span class="hljs-comment">// 打印: true 或 false</span></code></pre>
<h4>旧版的 API<span><a class="mark" href="#crypto_legacy_api" id="crypto_legacy_api">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="legacy_api">
                <a href="crypto/legacy_api.html" class="tip_trans">中英对照</a>
                </p>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 弃用</div><p></p>
<p>作为旧版接口，可以创建 <code>crypto.Certificate</code> 类的新实例，如下面的示例所示。</p>
<h5><code>new crypto.Certificate()</code><span><a class="mark" href="#crypto_new_crypto_certificate" id="crypto_new_crypto_certificate">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="new_crypto_certificate">
                <a href="crypto/new_crypto_certificate.html" class="tip_trans">中英对照</a>
                </p>
<p>可以使用 <code>new</code> 关键字或通过调用 <code>crypto.Certificate()</code> 作为函数来创建 <code>Certificate</code> 类的实例：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> cert1 = <span class="hljs-keyword">new</span> Certificate();
<span class="hljs-keyword">const</span> cert2 = Certificate();</code><code class="language-js cjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> cert1 = <span class="hljs-keyword">new</span> Certificate();
<span class="hljs-keyword">const</span> cert2 = Certificate();</code></pre>
<h5><code>certificate.exportChallenge(spkac[, encoding])</code><span><a class="mark" href="#crypto_certificate_exportchallenge_spkac_encoding" id="crypto_certificate_exportchallenge_spkac_encoding">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="certificate_exportchallenge_spkac_encoding">
                <a href="crypto/certificate_exportchallenge_spkac_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.8</span>
</div>
<ul>
<li><code>spkac</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>spkac</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> <code>spkac</code> 数据结构的挑战组件，包括公钥和挑战。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> cert = Certificate();
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> challenge = cert.exportChallenge(spkac);
<span class="hljs-built_in">console</span>.log(challenge.toString(<span class="hljs-string">'utf8'</span>));
<span class="hljs-comment">// 打印: the challenge as a UTF8 string</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> cert = Certificate();
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> challenge = cert.exportChallenge(spkac);
<span class="hljs-built_in">console</span>.log(challenge.toString(<span class="hljs-string">'utf8'</span>));
<span class="hljs-comment">// 打印: the challenge as a UTF8 string</span></code></pre>
<h5><code>certificate.exportPublicKey(spkac[, encoding])</code><span><a class="mark" href="#crypto_certificate_exportpublickey_spkac_encoding" id="crypto_certificate_exportpublickey_spkac_encoding">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="certificate_exportpublickey_spkac_encoding">
                <a href="crypto/certificate_exportpublickey_spkac_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.8</span>
</div>
<ul>
<li><code>spkac</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>spkac</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> <code>spkac</code> 数据结构的公钥组件，包括公钥和挑战。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> cert = Certificate();
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> publicKey = cert.exportPublicKey(spkac);
<span class="hljs-built_in">console</span>.log(publicKey);
<span class="hljs-comment">// 打印: the public key as &lt;Buffer ...&gt;</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> cert = Certificate();
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-keyword">const</span> publicKey = cert.exportPublicKey(spkac);
<span class="hljs-built_in">console</span>.log(publicKey);
<span class="hljs-comment">// 打印: the public key as &lt;Buffer ...&gt;</span></code></pre>
<h5><code>certificate.verifySpkac(spkac[, encoding])</code><span><a class="mark" href="#crypto_certificate_verifyspkac_spkac_encoding" id="crypto_certificate_verifyspkac_spkac_encoding">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="certificate_verifyspkac_spkac_encoding">
                <a href="crypto/certificate_verifyspkac_spkac_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.8</span>
</div>
<ul>
<li><code>spkac</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>spkac</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果给定的 <code>spkac</code> 数据结构有效，则为 <code>true</code>，否则为 <code>false</code>。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> cert = Certificate();
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-built_in">console</span>.log(cert.verifySpkac(Buffer.from(spkac)));
<span class="hljs-comment">// 打印: true 或 false</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> { Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> cert = Certificate();
<span class="hljs-keyword">const</span> spkac = getSpkacSomehow();
<span class="hljs-built_in">console</span>.log(cert.verifySpkac(Buffer.from(spkac)));
<span class="hljs-comment">// 打印: true 或 false</span></code></pre>
</section><section><h3><code>Cipher</code> 类<span><a class="mark" href="#crypto_class_cipher" id="crypto_class_cipher">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_cipher">
                <a href="crypto/class_cipher.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.94</span>
</div>
<ul>
<li>继承自: <a href="stream.html#stream_class_stream_transform" rel="nofollow" class="type">&lt;stream.Transform&gt;</a></li>
</ul>
<p><code>Cipher</code> 类的实例用于加密数据。
可以通过以下两种方式之一使用该类：</p>
<ul>
<li>作为既可读又可写的<a href="stream.html">流</a>，其中写入未加密的纯数据以在可读端生成加密数据，或</li>
<li>使用 <a href="crypto.html#crypto_cipher_update_data_inputencoding_outputencoding"><code>cipher.update()</code></a> 和 <a href="crypto.html#crypto_cipher_final_outputencoding"><code>cipher.final()</code></a> 方法生成加密数据。</li>
</ul>
<p><a href="crypto.html#crypto_crypto_createcipher_algorithm_password_options"><code>crypto.createCipher()</code></a> 或 <a href="crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options"><code>crypto.createCipheriv()</code></a> 方法用于创建 <code>Cipher</code> 实例。
<code>Cipher</code> 对象不能直接使用 <code>new</code> 关键字创建。</p>
<p>示例：使用 <code>Cipher</code> 对象作为流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  scrypt,
  randomFill,
  createCipheriv
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;

<span class="hljs-comment">// 首先，将生成密钥。密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
scrypt(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-comment">// 然后，将生成一个随机初始化向量</span>
  randomFill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>), <span class="hljs-function">(<span class="hljs-params">err, iv</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

    <span class="hljs-comment">// 一旦有了密钥和 iv，就可以创建和使用密码......</span>
    <span class="hljs-keyword">const</span> cipher = createCipheriv(algorithm, key, iv);

    <span class="hljs-keyword">let</span> encrypted = <span class="hljs-string">''</span>;
    cipher.setEncoding(<span class="hljs-string">'hex'</span>);

    cipher.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> encrypted += chunk);
    cipher.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(encrypted));

    cipher.write(<span class="hljs-string">'some clear text data'</span>);
    cipher.end();
  });
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  scrypt,
  randomFill,
  createCipheriv
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;

<span class="hljs-comment">// 首先，将生成密钥。密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
scrypt(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-comment">// 然后，将生成一个随机初始化向量</span>
  randomFill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>), <span class="hljs-function">(<span class="hljs-params">err, iv</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

    <span class="hljs-comment">// 一旦有了密钥和 iv，就可以创建和使用密码......</span>
    <span class="hljs-keyword">const</span> cipher = createCipheriv(algorithm, key, iv);

    <span class="hljs-keyword">let</span> encrypted = <span class="hljs-string">''</span>;
    cipher.setEncoding(<span class="hljs-string">'hex'</span>);

    cipher.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> encrypted += chunk);
    cipher.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(encrypted));

    cipher.write(<span class="hljs-string">'some clear text data'</span>);
    cipher.end();
  });
});</code></pre>
<p>示例：使用 <code>Cipher</code> 和管道流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> {
  createReadStream,
  createWriteStream,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">import</span> {
  pipeline
} <span class="hljs-keyword">from</span> <span class="hljs-string">'stream'</span>;

<span class="hljs-keyword">const</span> {
  scrypt,
  randomFill,
  createCipheriv,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;

<span class="hljs-comment">// 首先，将生成密钥。密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
scrypt(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-comment">// 然后，将生成一个随机初始化向量</span>
  randomFill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>), <span class="hljs-function">(<span class="hljs-params">err, iv</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

    <span class="hljs-keyword">const</span> cipher = createCipheriv(algorithm, key, iv);

    <span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.js'</span>);
    <span class="hljs-keyword">const</span> output = createWriteStream(<span class="hljs-string">'test.enc'</span>);

    pipeline(input, cipher, output, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    });
  });
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createReadStream,
  createWriteStream,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> {
  pipeline
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> {
  scrypt,
  randomFill,
  createCipheriv,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;

<span class="hljs-comment">// 首先，将生成密钥。密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
scrypt(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-comment">// 然后，将生成一个随机初始化向量</span>
  randomFill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>), <span class="hljs-function">(<span class="hljs-params">err, iv</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

    <span class="hljs-keyword">const</span> cipher = createCipheriv(algorithm, key, iv);

    <span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.js'</span>);
    <span class="hljs-keyword">const</span> output = createWriteStream(<span class="hljs-string">'test.enc'</span>);

    pipeline(input, cipher, output, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    });
  });
});</code></pre>
<p>示例：使用 <a href="crypto.html#crypto_cipher_update_data_inputencoding_outputencoding"><code>cipher.update()</code></a> 和 <a href="crypto.html#crypto_cipher_final_outputencoding"><code>cipher.final()</code></a> 方法：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  scrypt,
  randomFill,
  createCipheriv,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;

<span class="hljs-comment">// 首先，将生成密钥。密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
scrypt(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-comment">// 然后，将生成一个随机初始化向量</span>
  randomFill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>), <span class="hljs-function">(<span class="hljs-params">err, iv</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

    <span class="hljs-keyword">const</span> cipher = createCipheriv(algorithm, key, iv);

    <span class="hljs-keyword">let</span> encrypted = cipher.update(<span class="hljs-string">'some clear text data'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-string">'hex'</span>);
    encrypted += cipher.final(<span class="hljs-string">'hex'</span>);
    <span class="hljs-built_in">console</span>.log(encrypted);
  });
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  scrypt,
  randomFill,
  createCipheriv,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;

<span class="hljs-comment">// 首先，将生成密钥。密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
scrypt(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-comment">// 然后，将生成一个随机初始化向量</span>
  randomFill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">16</span>), <span class="hljs-function">(<span class="hljs-params">err, iv</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;

    <span class="hljs-keyword">const</span> cipher = createCipheriv(algorithm, key, iv);

    <span class="hljs-keyword">let</span> encrypted = cipher.update(<span class="hljs-string">'some clear text data'</span>, <span class="hljs-string">'utf8'</span>, <span class="hljs-string">'hex'</span>);
    encrypted += cipher.final(<span class="hljs-string">'hex'</span>);
    <span class="hljs-built_in">console</span>.log(encrypted);
  });
});</code></pre>
<h4><code>cipher.final([outputEncoding])</code><span><a class="mark" href="#crypto_cipher_final_outputencoding" id="crypto_cipher_final_outputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="cipher_final_outputencoding">
                <a href="crypto/cipher_final_outputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.94</span>
</div>
<ul>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 任何剩余的加密内容。
如果指定了 <code>outputEncoding</code>，则返回字符串。
如果未提供 <code>outputEncoding</code>，则返回 <a href="buffer.html"><code>Buffer</code></a>。</li>
</ul>
<p>一旦调用了 <code>cipher.final()</code> 方法，则 <code>Cipher</code> 对象就不能再用于加密数据。
多次尝试调用 <code>cipher.final()</code> 将导致抛出错误。</p>
<h4><code>cipher.getAuthTag()</code><span><a class="mark" href="#crypto_cipher_getauthtag" id="crypto_cipher_getauthtag">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="cipher_getauthtag">
                <a href="crypto/cipher_getauthtag.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.0.0</span>
</div>
<ul>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 当使用经过身份验证的加密模式（当前支持 <code>GCM</code>、<code>CCM</code> 和 <code>OCB</code>）时，<code>cipher.getAuthTag()</code> 方法返回 <a href="buffer.html"><code>Buffer</code></a>，其中包含根据给定数据计算出的身份验证标签。</li>
</ul>
<p>只有在使用 <a href="crypto.html#crypto_cipher_final_outputencoding"><code>cipher.final()</code></a> 方法完成加密后才应调用 <code>cipher.getAuthTag()</code> 方法。</p>
<h4><code>cipher.setAAD(buffer[, options])</code><span><a class="mark" href="#crypto_cipher_setaad_buffer_options" id="crypto_cipher_setaad_buffer_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="cipher_setaad_buffer_options">
                <a href="crypto/cipher_setaad_buffer_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.0.0</span>
</div>
<ul>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a>
<ul>
<li><code>plaintextLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>buffer</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li>返回: <a href="crypto.html#crypto_class_cipher" rel="nofollow" class="type">&lt;Cipher&gt;</a> 用于方法链。</li>
</ul>
<p>当使用认证加密模式（当前支持 <code>GCM</code>、<code>CCM</code> 和 <code>OCB</code>）时，<code>cipher.setAAD()</code> 方法设置用于额外的认证数据 (AAD) 输入参数的值。</p>
<p><code>plaintextLength</code> 选项对于 <code>GCM</code> 和 <code>OCB</code> 是可选的。
使用 <code>CCM</code> 时，必须指定 <code>plaintextLength</code> 选项，其值必须与明文的字节长度匹配。
请参见 <a href="crypto.html#crypto_ccm_mode">CCM 模式</a>。</p>
<p><code>cipher.setAAD()</code> 方法必须在 <a href="crypto.html#crypto_cipher_update_data_inputencoding_outputencoding"><code>cipher.update()</code></a> 之前调用。</p>
<h4><code>cipher.setAutoPadding([autoPadding])</code><span><a class="mark" href="#crypto_cipher_setautopadding_autopadding" id="crypto_cipher_setautopadding_autopadding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="cipher_setautopadding_autopadding">
                <a href="crypto/cipher_setautopadding_autopadding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.1</span>
</div>
<ul>
<li><code>autoPadding</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code></li>
<li>返回: <a href="crypto.html#crypto_class_cipher" rel="nofollow" class="type">&lt;Cipher&gt;</a> 用于方法链。</li>
</ul>
<p>当使用块加密算法时，<code>Cipher</code> 类会自动向输入数据添加填充到适当的块大小。
要禁用默认填充调用 <code>cipher.setAutoPadding(false)</code>。</p>
<p>当 <code>autoPadding</code> 为 <code>false</code> 时，整个输入数据的长度必须是密码块大小的倍数，否则 <a href="crypto.html#crypto_cipher_final_outputencoding"><code>cipher.final()</code></a> 将抛出错误。
禁用自动填充对于非标准填充很有用，例如使用 <code>0x0</code> 而不是 PKCS 填充。</p>
<p><code>cipher.setAutoPadding()</code> 方法必须在 <a href="crypto.html#crypto_cipher_final_outputencoding"><code>cipher.final()</code></a> 之前调用。</p>
<h4><code>cipher.update(data[, inputEncoding][, outputEncoding])</code><span><a class="mark" href="#crypto_cipher_update_data_inputencoding_outputencoding" id="crypto_cipher_update_data_inputencoding_outputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="cipher_update_data_inputencoding_outputencoding">
                <a href="crypto/cipher_update_data_inputencoding_outputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.0.0</td>
<td><p>默认 <code>inputEncoding</code> 从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>data</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 数据的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>使用 <code>data</code> 更新密码。
如果给定了 <code>inputEncoding</code> 参数，则 <code>data</code> 参数是使用指定编码的字符串。
如果未给定 <code>inputEncoding</code> 参数，则 <code>data</code> 必须是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。
如果 <code>data</code> 是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>，则忽略 <code>inputEncoding</code>。</p>
<p><code>outputEncoding</code> 指定加密数据的输出格式。
如果指定了 <code>outputEncoding</code>，则返回使用指定编码的字符串。
如果未提供 <code>outputEncoding</code>，则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<p>可以使用新数据多次调用 <code>cipher.update()</code> 方法，直到调用 <a href="crypto.html#crypto_cipher_final_outputencoding"><code>cipher.final()</code></a>。
在 <a href="crypto.html#crypto_cipher_final_outputencoding"><code>cipher.final()</code></a> 之后调用 <code>cipher.update()</code> 将导致抛出错误。</p>
</section><section><h3><code>Decipher</code> 类<span><a class="mark" href="#crypto_class_decipher" id="crypto_class_decipher">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_decipher">
                <a href="crypto/class_decipher.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.94</span>
</div>
<ul>
<li>继承自: <a href="stream.html#stream_class_stream_transform" rel="nofollow" class="type">&lt;stream.Transform&gt;</a></li>
</ul>
<p><code>Decipher</code> 类的实例用于解密数据。
可以通过以下两种方式之一使用该类：</p>
<ul>
<li>作为既可读又可写的<a href="stream.html">流</a>，其中写入纯加密数据以在可读端生成未加密数据，或</li>
<li>使用 <a href="crypto.html#crypto_decipher_update_data_inputencoding_outputencoding"><code>decipher.update()</code></a> 和 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a> 方法生成未加密的数据。</li>
</ul>
<p><a href="crypto.html#crypto_crypto_createdecipher_algorithm_password_options"><code>crypto.createDecipher()</code></a> 或 <a href="crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv_options"><code>crypto.createDecipheriv()</code></a> 方法用于创建 <code>Decipher</code> 实例。
<code>Decipher</code> 对象不能直接使用 <code>new</code> 关键字创建。</p>
<p>示例：使用 <code>Decipher</code> 对象作为流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  scryptSync,
  createDecipheriv,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;
<span class="hljs-comment">// 密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
<span class="hljs-comment">// 请改用异步 `crypto.scrypt()`。</span>
<span class="hljs-keyword">const</span> key = scryptSync(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// IV 通常与密文一起传入。</span>
<span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化向量。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(algorithm, key, iv);

<span class="hljs-keyword">let</span> decrypted = <span class="hljs-string">''</span>;
decipher.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = decipher.read())) {
    decrypted += chunk.toString(<span class="hljs-string">'utf8'</span>);
  }
});
decipher.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(decrypted);
  <span class="hljs-comment">// 打印: some clear text data</span>
});

<span class="hljs-comment">// 使用相同的算法、密钥和 iv 加密。</span>
<span class="hljs-keyword">const</span> encrypted =
  <span class="hljs-string">'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa'</span>;
decipher.write(encrypted, <span class="hljs-string">'hex'</span>);
decipher.end();</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  scryptSync,
  createDecipheriv,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;
<span class="hljs-comment">// 密钥长度取决于算法。</span>
<span class="hljs-comment">// 在这种情况下，对于 aes192，它是 24 字节（192 位）。</span>
<span class="hljs-comment">// 请改用异步 `crypto.scrypt()`。</span>
<span class="hljs-keyword">const</span> key = scryptSync(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// IV 通常与密文一起传入。</span>
<span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化向量。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(algorithm, key, iv);

<span class="hljs-keyword">let</span> decrypted = <span class="hljs-string">''</span>;
decipher.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = decipher.read())) {
    decrypted += chunk.toString(<span class="hljs-string">'utf8'</span>);
  }
});
decipher.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(decrypted);
  <span class="hljs-comment">// 打印: some clear text data</span>
});

<span class="hljs-comment">// 使用相同的算法、密钥和 iv 加密。</span>
<span class="hljs-keyword">const</span> encrypted =
  <span class="hljs-string">'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa'</span>;
decipher.write(encrypted, <span class="hljs-string">'hex'</span>);
decipher.end();</code></pre>
<p>示例：使用 <code>Decipher</code> 和管道流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> {
  createReadStream,
  createWriteStream,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> {
  scryptSync,
  createDecipheriv,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;
<span class="hljs-comment">// 请改用异步 `crypto.scrypt()`。</span>
<span class="hljs-keyword">const</span> key = scryptSync(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// IV 通常与密文一起传入。</span>
<span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化向量。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(algorithm, key, iv);

<span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.enc'</span>);
<span class="hljs-keyword">const</span> output = createWriteStream(<span class="hljs-string">'test.js'</span>);

input.pipe(decipher).pipe(output);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createReadStream,
  createWriteStream,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> {
  scryptSync,
  createDecipheriv,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;
<span class="hljs-comment">// 请改用异步 `crypto.scrypt()`。</span>
<span class="hljs-keyword">const</span> key = scryptSync(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// IV 通常与密文一起传入。</span>
<span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化向量。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(algorithm, key, iv);

<span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.enc'</span>);
<span class="hljs-keyword">const</span> output = createWriteStream(<span class="hljs-string">'test.js'</span>);

input.pipe(decipher).pipe(output);</code></pre>
<p>示例：使用 <a href="crypto.html#crypto_decipher_update_data_inputencoding_outputencoding"><code>decipher.update()</code></a> 和 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a> 方法：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  scryptSync,
  createDecipheriv,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;
<span class="hljs-comment">// 请改用异步 `crypto.scrypt()`。</span>
<span class="hljs-keyword">const</span> key = scryptSync(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// IV 通常与密文一起传入。</span>
<span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化向量。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(algorithm, key, iv);

<span class="hljs-comment">// 使用相同的算法、密钥和 iv 加密。</span>
<span class="hljs-keyword">const</span> encrypted =
  <span class="hljs-string">'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa'</span>;
<span class="hljs-keyword">let</span> decrypted = decipher.update(encrypted, <span class="hljs-string">'hex'</span>, <span class="hljs-string">'utf8'</span>);
decrypted += decipher.final(<span class="hljs-string">'utf8'</span>);
<span class="hljs-built_in">console</span>.log(decrypted);
<span class="hljs-comment">// 打印: some clear text data</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  scryptSync,
  createDecipheriv,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> algorithm = <span class="hljs-string">'aes-192-cbc'</span>;
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'Password used to generate key'</span>;
<span class="hljs-comment">// 请改用异步 `crypto.scrypt()`。</span>
<span class="hljs-keyword">const</span> key = scryptSync(password, <span class="hljs-string">'salt'</span>, <span class="hljs-number">24</span>);
<span class="hljs-comment">// IV 通常与密文一起传入。</span>
<span class="hljs-keyword">const</span> iv = Buffer.alloc(<span class="hljs-number">16</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 初始化向量。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(algorithm, key, iv);

<span class="hljs-comment">// 使用相同的算法、密钥和 iv 加密。</span>
<span class="hljs-keyword">const</span> encrypted =
  <span class="hljs-string">'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa'</span>;
<span class="hljs-keyword">let</span> decrypted = decipher.update(encrypted, <span class="hljs-string">'hex'</span>, <span class="hljs-string">'utf8'</span>);
decrypted += decipher.final(<span class="hljs-string">'utf8'</span>);
<span class="hljs-built_in">console</span>.log(decrypted);
<span class="hljs-comment">// 打印: some clear text data</span></code></pre>
<h4><code>decipher.final([outputEncoding])</code><span><a class="mark" href="#crypto_decipher_final_outputencoding" id="crypto_decipher_final_outputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="decipher_final_outputencoding">
                <a href="crypto/decipher_final_outputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.94</span>
</div>
<ul>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 任何剩余的解密内容。
如果指定了 <code>outputEncoding</code>，则返回字符串。
如果未提供 <code>outputEncoding</code>，则返回 <a href="buffer.html"><code>Buffer</code></a>。</li>
</ul>
<p>一旦调用了 <code>decipher.final()</code> 方法，就不能再使用 <code>Decipher</code> 对象来解密数据。
多次尝试调用 <code>decipher.final()</code> 将导致抛出错误。</p>
<h4><code>decipher.setAAD(buffer[, options])</code><span><a class="mark" href="#crypto_decipher_setaad_buffer_options" id="crypto_decipher_setaad_buffer_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="decipher_setaad_buffer_options">
                <a href="crypto/decipher_setaad_buffer_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>参数 buffer 可以是字符串或 ArrayBuffer，并且限制为不超过 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v7.2.0</td>
<td><p>此方法现在返回对 <code>decipher</code> 的引用。</p></td></tr>
<tr><td>v1.0.0</td>
<td><p><span>新增于: v1.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a>
<ul>
<li><code>plaintextLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>buffer</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li>返回: <a href="crypto.html#crypto_class_decipher" rel="nofollow" class="type">&lt;Decipher&gt;</a> 用于方法链。</li>
</ul>
<p>当使用认证加密模式（当前支持 <code>GCM</code>、<code>CCM</code> 和 <code>OCB</code>）时，<code>decipher.setAAD()</code> 方法设置用于额外的认证数据 (AAD) 输入参数的值。</p>
<p><code>options</code> 参数对于 <code>GCM</code> 是可选的。
使用 <code>CCM</code> 时，必须指定 <code>plaintextLength</code> 选项，其值必须与密文的字节长度匹配。
请参见 <a href="crypto.html#crypto_ccm_mode">CCM 模式</a>。</p>
<p><code>decipher.setAAD()</code> 方法必须在 <a href="crypto.html#crypto_decipher_update_data_inputencoding_outputencoding"><code>decipher.update()</code></a> 之前调用。</p>
<p>将字符串作为 <code>buffer</code> 传入时，请注意<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">将字符串用作加密 API 的输入时的注意事项</a>。</p>
<h4><code>decipher.setAuthTag(buffer[, encoding])</code><span><a class="mark" href="#crypto_decipher_setauthtag_buffer_encoding" id="crypto_decipher_setauthtag_buffer_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="decipher_setauthtag_buffer_encoding">
                <a href="crypto/decipher_setauthtag_buffer_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>参数 buffer 可以是字符串或 ArrayBuffer，并且限制为不超过 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v11.0.0</td>
<td><p>如果 GCM 标签长度无效，则此方法现在会抛出错误。</p></td></tr>
<tr><td>v7.2.0</td>
<td><p>此方法现在返回对 <code>decipher</code> 的引用。</p></td></tr>
<tr><td>v1.0.0</td>
<td><p><span>新增于: v1.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>buffer</code> 是字符串时使用的字符串编码。</li>
<li>返回: <a href="crypto.html#crypto_class_decipher" rel="nofollow" class="type">&lt;Decipher&gt;</a> 用于方法链。</li>
</ul>
<p>当使用认证加密方式（目前支持 <code>GCM</code>、<code>CCM</code>、<code>OCB</code>）时，则使用 <code>decipher.setAuthTag()</code> 方法传入接收到的认证标签。
如果没有提供标签，或者密文被篡改，则抛出 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a>，表示由于认证失败，密文应该被丢弃。
如果标签长度根据 <a href="http://url.nodejs.cn/G26eau">NIST SP 800-38D</a> 无效或与 <code>authTagLength</code> 选项的值不匹配，则 <code>decipher.setAuthTag()</code> 将抛出错误。</p>
<p>对于 <code>CCM</code> 模式，必须在 <a href="crypto.html#crypto_decipher_update_data_inputencoding_outputencoding"><code>decipher.update()</code></a> 之前调用 <code>decipher.setAuthTag()</code> 方法，对于 <code>GCM</code> 和 <code>OCB</code> 模式，必须在 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a> 之前调用。
<code>decipher.setAuthTag()</code> 只能被调用一次。</p>
<p>将字符串作为身份验证标记传入时，请注意<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">将字符串用作加密 API 的输入时的注意事项</a>。</p>
<h4><code>decipher.setAutoPadding([autoPadding])</code><span><a class="mark" href="#crypto_decipher_setautopadding_autopadding" id="crypto_decipher_setautopadding_autopadding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="decipher_setautopadding_autopadding">
                <a href="crypto/decipher_setautopadding_autopadding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.1</span>
</div>
<ul>
<li><code>autoPadding</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code></li>
<li>返回: <a href="crypto.html#crypto_class_decipher" rel="nofollow" class="type">&lt;Decipher&gt;</a> 用于方法链。</li>
</ul>
<p>当数据在没有标准块填充的情况下加密时，调用 <code>decipher.setAutoPadding(false)</code> 将禁用自动填充以防止 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a> 检查和删除填充。</p>
<p>仅当输入数据的长度是密码块大小的倍数时，关闭自动填充才会起作用。</p>
<p><code>decipher.setAutoPadding()</code> 方法必须在 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a> 之前调用。</p>
<h4><code>decipher.update(data[, inputEncoding][, outputEncoding])</code><span><a class="mark" href="#crypto_decipher_update_data_inputencoding_outputencoding" id="crypto_decipher_update_data_inputencoding_outputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="decipher_update_data_inputencoding_outputencoding">
                <a href="crypto/decipher_update_data_inputencoding_outputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.0.0</td>
<td><p>默认 <code>inputEncoding</code> 从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>data</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>data</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>用 <code>data</code> 更新解密。
如果给定了 <code>inputEncoding</code> 参数，则 <code>data</code> 参数是使用指定编码的字符串。
如果未给定 <code>inputEncoding</code> 参数，则 <code>data</code> 必须是 <a href="buffer.html"><code>Buffer</code></a>。
如果 <code>data</code> 是 <a href="buffer.html"><code>Buffer</code></a>，则忽略 <code>inputEncoding</code>。</p>
<p><code>outputEncoding</code> 指定加密数据的输出格式。
如果指定了 <code>outputEncoding</code>，则返回使用指定编码的字符串。
如果未提供 <code>outputEncoding</code>，则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<p>可以使用新数据多次调用 <code>decipher.update()</code> 方法，直到调用 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a>。
在 <a href="crypto.html#crypto_decipher_final_outputencoding"><code>decipher.final()</code></a> 之后调用 <code>decipher.update()</code> 将导致抛出错误。</p>
</section><section><h3><code>DiffieHellman</code> 类<span><a class="mark" href="#crypto_class_diffiehellman" id="crypto_class_diffiehellman">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_diffiehellman">
                <a href="crypto/class_diffiehellman.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<p><code>DiffieHellman</code> 类是用于创建 Diffie-Hellman 密钥交换的实用工具。</p>
<p>可以使用 <a href="crypto.html#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding"><code>crypto.createDiffieHellman()</code></a> 函数创建 <code>DiffieHellman</code> 类的实例。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'assert'</span>;

<span class="hljs-keyword">const</span> {
  createDiffieHellman,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 生成 Alice 的密钥...</span>
<span class="hljs-keyword">const</span> alice = createDiffieHellman(<span class="hljs-number">2048</span>);
<span class="hljs-keyword">const</span> aliceKey = alice.generateKeys();

<span class="hljs-comment">// 生成 Bob 的密钥...</span>
<span class="hljs-keyword">const</span> bob = createDiffieHellman(alice.getPrime(), alice.getGenerator());
<span class="hljs-keyword">const</span> bobKey = bob.generateKeys();

<span class="hljs-comment">// 交换并生成密钥...</span>
<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bobKey);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(aliceKey);

<span class="hljs-comment">// OK</span>
assert.strictEqual(aliceSecret.toString(<span class="hljs-string">'hex'</span>), bobSecret.toString(<span class="hljs-string">'hex'</span>));</code><code class="language-js cjs"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

<span class="hljs-keyword">const</span> {
  createDiffieHellman,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 生成 Alice 的密钥...</span>
<span class="hljs-keyword">const</span> alice = createDiffieHellman(<span class="hljs-number">2048</span>);
<span class="hljs-keyword">const</span> aliceKey = alice.generateKeys();

<span class="hljs-comment">// 生成 Bob 的密钥...</span>
<span class="hljs-keyword">const</span> bob = createDiffieHellman(alice.getPrime(), alice.getGenerator());
<span class="hljs-keyword">const</span> bobKey = bob.generateKeys();

<span class="hljs-comment">// 交换并生成密钥...</span>
<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bobKey);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(aliceKey);

<span class="hljs-comment">// OK</span>
assert.strictEqual(aliceSecret.toString(<span class="hljs-string">'hex'</span>), bobSecret.toString(<span class="hljs-string">'hex'</span>));</code></pre>
<h4><code>diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])</code><span><a class="mark" href="#crypto_diffiehellman_computesecret_otherpublickey_inputencoding_outputencoding" id="crypto_diffiehellman_computesecret_otherpublickey_inputencoding_outputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_computesecret_otherpublickey_inputencoding_outputencoding">
                <a href="crypto/diffiehellman_computesecret_otherpublickey_inputencoding_outputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>otherPublicKey</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>otherPublicKey</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>使用 <code>otherPublicKey</code> 作为对方的公钥计算共享密钥，并返回计算出的共享密钥。
使用指定的 <code>inputEncoding</code> 解释提供的密钥，使用指定的 <code>outputEncoding</code> 对密钥进行编码。
如果未提供 <code>inputEncoding</code>，则 <code>otherPublicKey</code> 应为 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p>如果给定 <code>outputEncoding</code>，则返回字符串； 否则，返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>diffieHellman.generateKeys([encoding])</code><span><a class="mark" href="#crypto_diffiehellman_generatekeys_encoding" id="crypto_diffiehellman_generatekeys_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_generatekeys_encoding">
                <a href="crypto/diffiehellman_generatekeys_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>生成私钥和公钥 Diffie-Hellman 密钥值，并返回指定 <code>encoding</code> 中的公钥。
此密钥应转让给另一方。
如果提供了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>diffieHellman.getGenerator([encoding])</code><span><a class="mark" href="#crypto_diffiehellman_getgenerator_encoding" id="crypto_diffiehellman_getgenerator_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_getgenerator_encoding">
                <a href="crypto/diffiehellman_getgenerator_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回指定 <code>encoding</code> 中的 Diffie-Hellman 生成器。
如果提供了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>diffieHellman.getPrime([encoding])</code><span><a class="mark" href="#crypto_diffiehellman_getprime_encoding" id="crypto_diffiehellman_getprime_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_getprime_encoding">
                <a href="crypto/diffiehellman_getprime_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回指定 <code>encoding</code> 中的 Diffie-Hellman 素数。
如果提供了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>diffieHellman.getPrivateKey([encoding])</code><span><a class="mark" href="#crypto_diffiehellman_getprivatekey_encoding" id="crypto_diffiehellman_getprivatekey_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_getprivatekey_encoding">
                <a href="crypto/diffiehellman_getprivatekey_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回指定 <code>encoding</code> 中的 Diffie-Hellman 私钥。
如果提供了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>diffieHellman.getPublicKey([encoding])</code><span><a class="mark" href="#crypto_diffiehellman_getpublickey_encoding" id="crypto_diffiehellman_getpublickey_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_getpublickey_encoding">
                <a href="crypto/diffiehellman_getpublickey_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回指定 <code>encoding</code> 中的 Diffie-Hellman 公钥。
如果提供了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>diffieHellman.setPrivateKey(privateKey[, encoding])</code><span><a class="mark" href="#crypto_diffiehellman_setprivatekey_privatekey_encoding" id="crypto_diffiehellman_setprivatekey_privatekey_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_setprivatekey_privatekey_encoding">
                <a href="crypto/diffiehellman_setprivatekey_privatekey_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>privateKey</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>privateKey</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>设置 Diffie-Hellman 私钥。
如果提供了 <code>encoding</code> 参数，则 <code>privateKey</code> 应该是字符串。
如果未提供 <code>encoding</code>，则 <code>privateKey</code> 应为 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<h4><code>diffieHellman.setPublicKey(publicKey[, encoding])</code><span><a class="mark" href="#crypto_diffiehellman_setpublickey_publickey_encoding" id="crypto_diffiehellman_setpublickey_publickey_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_setpublickey_publickey_encoding">
                <a href="crypto/diffiehellman_setpublickey_publickey_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>publicKey</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>publicKey</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>设置 Diffie-Hellman 公钥。
如果提供了 <code>encoding</code> 参数，则 <code>publicKey</code> 应该是字符串。
如果未提供 <code>encoding</code>，则 <code>publicKey</code> 应为 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<h4><code>diffieHellman.verifyError</code><span><a class="mark" href="#crypto_diffiehellman_verifyerror" id="crypto_diffiehellman_verifyerror">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="diffiehellman_verifyerror">
                <a href="crypto/diffiehellman_verifyerror.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.12</span>
</div>
<p>包含在 <code>DiffieHellman</code> 对象初始化期间执行的检查所产生的任何警告和/或错误的位字段。</p>
<p>以下值对此属性有效（如 <code>constants</code> 模块中所定义）：</p>
<ul>
<li><code>DH_CHECK_P_NOT_SAFE_PRIME</code></li>
<li><code>DH_CHECK_P_NOT_PRIME</code></li>
<li><code>DH_UNABLE_TO_CHECK_GENERATOR</code></li>
<li><code>DH_NOT_SUITABLE_GENERATOR</code></li>
</ul>
</section><section><h3><code>DiffieHellmanGroup</code> 类<span><a class="mark" href="#crypto_class_diffiehellmangroup" id="crypto_class_diffiehellmangroup">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_diffiehellmangroup">
                <a href="crypto/class_diffiehellmangroup.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.5</span>
</div>
<p><code>DiffieHellmanGroup</code> 类以著名的 modp 组为参数。
它的工作原理与 <code>DiffieHellman</code> 相同，不同之处在于它不允许在创建后更改其密钥。
换句话说，它没有实现 <code>setPublicKey()</code> 或 <code>setPrivateKey()</code> 方法。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { createDiffieHellmanGroup } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> dh = createDiffieHellmanGroup(<span class="hljs-string">'modp1'</span>);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> { createDiffieHellmanGroup } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> dh = createDiffieHellmanGroup(<span class="hljs-string">'modp1'</span>);</code></pre>
<p>名称（例如 <code>'modp1'</code>）取自 <a href="http://url.nodejs.cn/6ouCbA">RFC 2412</a>（modp1 和 2）和 <a href="http://url.nodejs.cn/m8pGEe">RFC 3526</a>：</p>
<pre><code class="language-console"><span class="hljs-meta">$</span><span class="bash"> perl -ne <span class="hljs-string">'print "$1\n" if /"(modp\d+)"/'</span> src/node_crypto_groups.h</span>
modp1  #  768 bits
modp2  # 1024 bits
modp5  # 1536 bits
modp14 # 2048 bits
modp15 # etc.
modp16
modp17
modp18</code></pre>
</section><section><h3><code>ECDH</code> 类<span><a class="mark" href="#crypto_class_ecdh" id="crypto_class_ecdh">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_ecdh">
                <a href="crypto/class_ecdh.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<p><code>ECDH</code> 类是用于创建椭圆曲线 Diffie-Hellman (ECDH) 密钥交换的实用工具。</p>
<p>可以使用 <a href="crypto.html#crypto_crypto_createecdh_curvename"><code>crypto.createECDH()</code></a> 函数创建 <code>ECDH</code> 类的实例。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> assert <span class="hljs-keyword">from</span> <span class="hljs-string">'assert'</span>;

<span class="hljs-keyword">const</span> {
  createECDH,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 生成 Alice 的密钥...</span>
<span class="hljs-keyword">const</span> alice = createECDH(<span class="hljs-string">'secp521r1'</span>);
<span class="hljs-keyword">const</span> aliceKey = alice.generateKeys();

<span class="hljs-comment">// 生成 Bob 的密钥...</span>
<span class="hljs-keyword">const</span> bob = createECDH(<span class="hljs-string">'secp521r1'</span>);
<span class="hljs-keyword">const</span> bobKey = bob.generateKeys();

<span class="hljs-comment">// 交换并生成密钥...</span>
<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bobKey);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(aliceKey);

assert.strictEqual(aliceSecret.toString(<span class="hljs-string">'hex'</span>), bobSecret.toString(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// OK</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);

<span class="hljs-keyword">const</span> {
  createECDH,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 生成 Alice 的密钥...</span>
<span class="hljs-keyword">const</span> alice = createECDH(<span class="hljs-string">'secp521r1'</span>);
<span class="hljs-keyword">const</span> aliceKey = alice.generateKeys();

<span class="hljs-comment">// 生成 Bob 的密钥...</span>
<span class="hljs-keyword">const</span> bob = createECDH(<span class="hljs-string">'secp521r1'</span>);
<span class="hljs-keyword">const</span> bobKey = bob.generateKeys();

<span class="hljs-comment">// 交换并生成密钥...</span>
<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bobKey);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(aliceKey);

assert.strictEqual(aliceSecret.toString(<span class="hljs-string">'hex'</span>), bobSecret.toString(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// OK</span></code></pre>
<h4><code>ECDH.convertKey(key, curve[, inputEncoding[, outputEncoding[, format]]])</code><span><a class="mark" href="#crypto_static_method_ecdh_convertkey_key_curve_inputencoding_outputencoding_format" id="crypto_static_method_ecdh_convertkey_key_curve_inputencoding_outputencoding_format">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="static_method_ecdh_convertkey_key_curve_inputencoding_outputencoding_format">
                <a href="crypto/static_method_ecdh_convertkey_key_curve_inputencoding_outputencoding_format.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.0.0</span>
</div>
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>curve</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>key</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>format</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <strong>默认值:</strong> <code>'uncompressed'</code></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>将 <code>key</code> 和 <code>curve</code> 指定的 EC Diffie-Hellman 公钥转换为 <code>format</code> 指定的格式。
<code>format</code> 参数指定点编码，可以是 <code>'compressed'</code>、<code>'uncompressed'</code> 或 <code>'hybrid'</code>。
提供的密钥使用指定的 <code>inputEncoding</code> 进行解释，返回的密钥使用指定的 <code>outputEncoding</code> 进行编码。</p>
<p>使用 <a href="crypto.html#crypto_crypto_getcurves"><code>crypto.getCurves()</code></a> 获取可用曲线名称的列表。
在最近的 OpenSSL 版本中，<code>openssl ecparam -list_curves</code> 还将显示每个可用椭圆曲线的名称和描述。</p>
<p>如果未指定 <code>format</code>，该点将以 <code>'uncompressed'</code> 格式返回。</p>
<p>如果未提供 <code>inputEncoding</code>，则 <code>key</code> 应为 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p>示例（解压缩密钥）：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  createECDH,
  ECDH,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> ecdh = createECDH(<span class="hljs-string">'secp256k1'</span>);
ecdh.generateKeys();

<span class="hljs-keyword">const</span> compressedKey = ecdh.getPublicKey(<span class="hljs-string">'hex'</span>, <span class="hljs-string">'compressed'</span>);

<span class="hljs-keyword">const</span> uncompressedKey = ECDH.convertKey(compressedKey,
                                        <span class="hljs-string">'secp256k1'</span>,
                                        <span class="hljs-string">'hex'</span>,
                                        <span class="hljs-string">'hex'</span>,
                                        <span class="hljs-string">'uncompressed'</span>);

<span class="hljs-comment">// 转换后的密钥和未压缩的公钥应该是一样的</span>
<span class="hljs-built_in">console</span>.log(uncompressedKey === ecdh.getPublicKey(<span class="hljs-string">'hex'</span>));</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createECDH,
  ECDH,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> ecdh = createECDH(<span class="hljs-string">'secp256k1'</span>);
ecdh.generateKeys();

<span class="hljs-keyword">const</span> compressedKey = ecdh.getPublicKey(<span class="hljs-string">'hex'</span>, <span class="hljs-string">'compressed'</span>);

<span class="hljs-keyword">const</span> uncompressedKey = ECDH.convertKey(compressedKey,
                                        <span class="hljs-string">'secp256k1'</span>,
                                        <span class="hljs-string">'hex'</span>,
                                        <span class="hljs-string">'hex'</span>,
                                        <span class="hljs-string">'uncompressed'</span>);

<span class="hljs-comment">// 转换后的密钥和未压缩的公钥应该是一样的</span>
<span class="hljs-built_in">console</span>.log(uncompressedKey === ecdh.getPublicKey(<span class="hljs-string">'hex'</span>));</code></pre>
<h4><code>ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])</code><span><a class="mark" href="#crypto_ecdh_computesecret_otherpublickey_inputencoding_outputencoding" id="crypto_ecdh_computesecret_otherpublickey_inputencoding_outputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="ecdh_computesecret_otherpublickey_inputencoding_outputencoding">
                <a href="crypto/ecdh_computesecret_otherpublickey_inputencoding_outputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>更改错误格式以更好地支持无效公钥错误。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>默认 <code>inputEncoding</code> 从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.11.14</td>
<td><p><span>新增于: v0.11.14</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>otherPublicKey</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>otherPublicKey</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>使用 <code>otherPublicKey</code> 作为对方的公钥计算共享密钥，并返回计算出的共享密钥。
提供的密钥使用指定的 <code>inputEncoding</code> 进行解释，返回的密钥使用指定的 <code>outputEncoding</code> 进行编码。
如果未提供 <code>inputEncoding</code>，则 <code>otherPublicKey</code> 应为 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p>如果给定 <code>outputEncoding</code>，将返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<p>当 <code>otherPublicKey</code> 位于椭圆曲线之外时，<code>ecdh.computeSecret</code> 将抛出 <code>ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY</code> 错误。
由于 <code>otherPublicKey</code> 通常由远程用户通过不安全的网络提供，因此请务必相应地处理此异常。</p>
<h4><code>ecdh.generateKeys([encoding[, format]])</code><span><a class="mark" href="#crypto_ecdh_generatekeys_encoding_format" id="crypto_ecdh_generatekeys_encoding_format">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="ecdh_generatekeys_encoding_format">
                <a href="crypto/ecdh_generatekeys_encoding_format.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>format</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <strong>默认值:</strong> <code>'uncompressed'</code></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>生成私有和公共 EC Diffie-Hellman 密钥值，并返回指定 <code>format</code> 和 <code>encoding</code> 中的公钥。
此密钥应转让给另一方。</p>
<p><code>format</code> 参数指定点编码，可以是 <code>'compressed'</code> 或 <code>'uncompressed'</code>。
如果未指定 <code>format</code>，则该点将以 <code>'uncompressed'</code> 格式返回。</p>
<p>如果提供了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>ecdh.getPrivateKey([encoding])</code><span><a class="mark" href="#crypto_ecdh_getprivatekey_encoding" id="crypto_ecdh_getprivatekey_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="ecdh_getprivatekey_encoding">
                <a href="crypto/ecdh_getprivatekey_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 指定 <code>encoding</code> 中的 EC Diffie-Hellman。</li>
</ul>
<p>如果指定了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>ecdh.getPublicKey([encoding][, format])</code><span><a class="mark" href="#crypto_ecdh_getpublickey_encoding_format" id="crypto_ecdh_getpublickey_encoding_format">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="ecdh_getpublickey_encoding_format">
                <a href="crypto/ecdh_getpublickey_encoding_format.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>format</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <strong>默认值:</strong> <code>'uncompressed'</code></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 指定 <code>encoding</code> 和 <code>format</code> 中的 EC Diffie-Hellman 公钥。</li>
</ul>
<p><code>format</code> 参数指定点编码，可以是 <code>'compressed'</code> 或 <code>'uncompressed'</code>。
如果未指定 <code>format</code>，该点将以 <code>'uncompressed'</code> 格式返回。</p>
<p>如果指定了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<h4><code>ecdh.setPrivateKey(privateKey[, encoding])</code><span><a class="mark" href="#crypto_ecdh_setprivatekey_privatekey_encoding" id="crypto_ecdh_setprivatekey_privatekey_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="ecdh_setprivatekey_privatekey_encoding">
                <a href="crypto/ecdh_setprivatekey_privatekey_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul>
<li><code>privateKey</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>privateKey</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>设置 EC Diffie-Hellman 私钥。
如果提供了 <code>encoding</code>，则 <code>privateKey</code> 应该是字符串；否则 <code>privateKey</code> 应该是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p>如果 <code>privateKey</code> 对于创建 <code>ECDH</code> 对象时指定的曲线无效，则会引发错误。
在设置私钥时，相关的公共点（密钥）也会生成并设置在 <code>ECDH</code> 对象中。</p>
<h4><code>ecdh.setPublicKey(publicKey[, encoding])</code><span><a class="mark" href="#crypto_ecdh_setpublickey_publickey_encoding" id="crypto_ecdh_setpublickey_publickey_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="ecdh_setpublickey_publickey_encoding">
                <a href="crypto/ecdh_setpublickey_publickey_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span><span>弃用于: v5.2.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 弃用</div><p></p>
<ul>
<li><code>publicKey</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>publicKey</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>设置 EC Diffie-Hellman 公钥。
如果提供了 <code>encoding</code>，则 <code>publicKey</code> 应该是字符串；否则应为 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p>通常没有理由调用这个方法，因为 <code>ECDH</code> 只需要一个私钥和对方的公钥来计算共享秘密。
通常会调用 <a href="crypto.html#crypto_ecdh_generatekeys_encoding_format"><code>ecdh.generateKeys()</code></a> 或 <a href="crypto.html#crypto_ecdh_setprivatekey_privatekey_encoding"><code>ecdh.setPrivateKey()</code></a>。
<a href="crypto.html#crypto_ecdh_setprivatekey_privatekey_encoding"><code>ecdh.setPrivateKey()</code></a> 方法尝试生成与正在设置的私钥相关联的公共点/密钥。</p>
<p>示例（获取共享密钥）：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  createECDH,
  createHash,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> alice = createECDH(<span class="hljs-string">'secp256k1'</span>);
<span class="hljs-keyword">const</span> bob = createECDH(<span class="hljs-string">'secp256k1'</span>);

<span class="hljs-comment">// 这是指定 Alice 以前的私钥之一的快捷方式。</span>
<span class="hljs-comment">// 在实际应用中使用这种可预测的私钥是不明智的。</span>
alice.setPrivateKey(
  createHash(<span class="hljs-string">'sha256'</span>).update(<span class="hljs-string">'alice'</span>, <span class="hljs-string">'utf8'</span>).digest()
);

<span class="hljs-comment">// Bob 使用新生成的加密强伪随机密钥对</span>
bob.generateKeys();

<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bob.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(alice.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);

<span class="hljs-comment">// aliceSecret 和 bobSecret 应该是相同的共享秘密值</span>
<span class="hljs-built_in">console</span>.log(aliceSecret === bobSecret);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createECDH,
  createHash,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> alice = createECDH(<span class="hljs-string">'secp256k1'</span>);
<span class="hljs-keyword">const</span> bob = createECDH(<span class="hljs-string">'secp256k1'</span>);

<span class="hljs-comment">// 这是指定 Alice 以前的私钥之一的快捷方式。</span>
<span class="hljs-comment">// 在实际应用中使用这种可预测的私钥是不明智的。</span>
alice.setPrivateKey(
  createHash(<span class="hljs-string">'sha256'</span>).update(<span class="hljs-string">'alice'</span>, <span class="hljs-string">'utf8'</span>).digest()
);

<span class="hljs-comment">// Bob 使用新生成的加密强伪随机密钥对</span>
bob.generateKeys();

<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bob.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(alice.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);

<span class="hljs-comment">// aliceSecret 和 bobSecret 应该是相同的共享秘密值</span>
<span class="hljs-built_in">console</span>.log(aliceSecret === bobSecret);</code></pre>
</section><section><h3><code>Hash</code> 类<span><a class="mark" href="#crypto_class_hash" id="crypto_class_hash">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_hash">
                <a href="crypto/class_hash.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div>
<ul>
<li>继承自: <a href="stream.html#stream_class_stream_transform" rel="nofollow" class="type">&lt;stream.Transform&gt;</a></li>
</ul>
<p><code>Hash</code> 类是用于创建数据散列摘要的实用工具。
它可以通过以下两种方式之一使用：</p>
<ul>
<li>作为既可读又可写的<a href="stream.html">流</a>，其中写入数据以在可读端生成计算的哈希摘要，或</li>
<li>使用 <a href="crypto.html#crypto_hash_update_data_inputencoding"><code>hash.update()</code></a> 和 <a href="crypto.html#crypto_hash_digest_encoding"><code>hash.digest()</code></a> 方法生成计算出的哈希。</li>
</ul>
<p><a href="crypto.html#crypto_crypto_createhash_algorithm_options"><code>crypto.createHash()</code></a> 方法用于创建 <code>Hash</code> 实例。
<code>Hash</code> 对象不能直接使用 <code>new</code> 关键字创建。</p>
<p>示例：使用 <code>Hash</code> 对象作为流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

hash.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = hash.read();
  <span class="hljs-keyword">if</span> (data) {
    <span class="hljs-built_in">console</span>.log(data.toString(<span class="hljs-string">'hex'</span>));
    <span class="hljs-comment">// 打印:</span>
    <span class="hljs-comment">//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50</span>
  }
});

hash.write(<span class="hljs-string">'some data to hash'</span>);
hash.end();</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

hash.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = hash.read();
  <span class="hljs-keyword">if</span> (data) {
    <span class="hljs-built_in">console</span>.log(data.toString(<span class="hljs-string">'hex'</span>));
    <span class="hljs-comment">// 打印:</span>
    <span class="hljs-comment">//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50</span>
  }
});

hash.write(<span class="hljs-string">'some data to hash'</span>);
hash.end();</code></pre>
<p>示例：使用 <code>Hash</code> 和管道流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> { createReadStream } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.js'</span>);
input.pipe(hash).setEncoding(<span class="hljs-string">'hex'</span>).pipe(process.stdout);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createReadStream,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.js'</span>);
input.pipe(hash).setEncoding(<span class="hljs-string">'hex'</span>).pipe(process.stdout);</code></pre>
<p>示例：使用 <a href="crypto.html#crypto_hash_update_data_inputencoding"><code>hash.update()</code></a> 和 <a href="crypto.html#crypto_hash_digest_encoding"><code>hash.digest()</code></a> 方法：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

hash.update(<span class="hljs-string">'some data to hash'</span>);
<span class="hljs-built_in">console</span>.log(hash.digest(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

hash.update(<span class="hljs-string">'some data to hash'</span>);
<span class="hljs-built_in">console</span>.log(hash.digest(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50</span></code></pre>
<h4><code>hash.copy([options])</code><span><a class="mark" href="#crypto_hash_copy_options" id="crypto_hash_copy_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="hash_copy_options">
                <a href="crypto/hash_copy_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.1.0</span>
</div>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_hash" rel="nofollow" class="type">&lt;Hash&gt;</a></li>
</ul>
<p>创建新的 <code>Hash</code> 对象，其中包含当前 <code>Hash</code> 对象的内部状态的深层副本。</p>
<p>可选的 <code>options</code> 参数控制流的行为。
对于 XOF 哈希函数（例如 <code>'shake256'</code>），可以使用 <code>outputLength</code> 选项指定所需的输出长度（以字节为单位）。</p>
<p>在调用 <a href="crypto.html#crypto_hash_digest_encoding"><code>hash.digest()</code></a> 方法后尝试复制 <code>Hash</code> 对象时会引发错误。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-comment">// 计算滚动哈希。</span>
<span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

hash.update(<span class="hljs-string">'one'</span>);
<span class="hljs-built_in">console</span>.log(hash.copy().digest(<span class="hljs-string">'hex'</span>));

hash.update(<span class="hljs-string">'two'</span>);
<span class="hljs-built_in">console</span>.log(hash.copy().digest(<span class="hljs-string">'hex'</span>));

hash.update(<span class="hljs-string">'three'</span>);
<span class="hljs-built_in">console</span>.log(hash.copy().digest(<span class="hljs-string">'hex'</span>));

<span class="hljs-comment">// 等等。</span></code><code class="language-js cjs"><span class="hljs-comment">// 计算滚动哈希。</span>
<span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

hash.update(<span class="hljs-string">'one'</span>);
<span class="hljs-built_in">console</span>.log(hash.copy().digest(<span class="hljs-string">'hex'</span>));

hash.update(<span class="hljs-string">'two'</span>);
<span class="hljs-built_in">console</span>.log(hash.copy().digest(<span class="hljs-string">'hex'</span>));

hash.update(<span class="hljs-string">'three'</span>);
<span class="hljs-built_in">console</span>.log(hash.copy().digest(<span class="hljs-string">'hex'</span>));

<span class="hljs-comment">// 等等。</span></code></pre>
<h4><code>hash.digest([encoding])</code><span><a class="mark" href="#crypto_hash_digest_encoding" id="crypto_hash_digest_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="hash_digest_encoding">
                <a href="crypto/hash_digest_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>计算传给散列的所有数据的摘要（使用 <a href="crypto.html#crypto_hash_update_data_inputencoding"><code>hash.update()</code></a> 方法）。
如果提供了 <code>encoding</code>，则将返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<p><code>Hash</code> 对象在调用 <code>hash.digest()</code> 方法后不能再次使用。
多次调用会导致抛出错误。</p>
<h4><code>hash.update(data[, inputEncoding])</code><span><a class="mark" href="#crypto_hash_update_data_inputencoding" id="crypto_hash_update_data_inputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="hash_update_data_inputencoding">
                <a href="crypto/hash_update_data_inputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.0.0</td>
<td><p>默认 <code>inputEncoding</code> 从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.1.92</td>
<td><p><span>新增于: v0.1.92</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>data</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>data</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>使用给定的 <code>data</code> 更新哈希内容，其编码在 <code>inputEncoding</code> 中给出。
如果未提供 <code>encoding</code>，而 <code>data</code> 是字符串，则强制执行 <code>'utf8'</code> 编码。
如果 <code>data</code> 是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>，则忽略 <code>inputEncoding</code>。</p>
<p>这可以在流式传输时使用新数据多次调用。</p>
</section><section><h3><code>Hmac</code> 类<span><a class="mark" href="#crypto_class_hmac" id="crypto_class_hmac">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_hmac">
                <a href="crypto/class_hmac.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.94</span>
</div>
<ul>
<li>继承自: <a href="stream.html#stream_class_stream_transform" rel="nofollow" class="type">&lt;stream.Transform&gt;</a></li>
</ul>
<p><code>Hmac</code> 类是用于创建加密 HMAC 摘要的实用工具。
它可以通过以下两种方式之一使用：</p>
<ul>
<li>作为既可读又可写的<a href="stream.html">流</a>，其中写入数据以在可读端生成计算的 HMAC 摘要，或</li>
<li>使用 <a href="crypto.html#crypto_hmac_update_data_inputencoding"><code>hmac.update()</code></a> 和 <a href="crypto.html#crypto_hmac_digest_encoding"><code>hmac.digest()</code></a> 方法生成计算出的 HMAC 摘要。</li>
</ul>
<p><a href="crypto.html#crypto_crypto_createhmac_algorithm_key_options"><code>crypto.createHmac()</code></a> 方法用于创建 <code>Hmac</code> 实例。
<code>Hmac</code> 对象不能直接使用 <code>new</code> 关键字创建。</p>
<p>示例：使用 <code>Hmac</code> 对象作为流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

hmac.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = hmac.read();
  <span class="hljs-keyword">if</span> (data) {
    <span class="hljs-built_in">console</span>.log(data.toString(<span class="hljs-string">'hex'</span>));
    <span class="hljs-comment">// 打印:</span>
    <span class="hljs-comment">//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e</span>
  }
});

hmac.write(<span class="hljs-string">'some data to hash'</span>);
hmac.end();</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

hmac.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = hmac.read();
  <span class="hljs-keyword">if</span> (data) {
    <span class="hljs-built_in">console</span>.log(data.toString(<span class="hljs-string">'hex'</span>));
    <span class="hljs-comment">// 打印:</span>
    <span class="hljs-comment">//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e</span>
  }
});

hmac.write(<span class="hljs-string">'some data to hash'</span>);
hmac.end();</code></pre>
<p>示例：使用 <code>Hmac</code> 和管道流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> { createReadStream } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.js'</span>);
input.pipe(hmac).pipe(process.stdout);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createReadStream,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(<span class="hljs-string">'test.js'</span>);
input.pipe(hmac).pipe(process.stdout);</code></pre>
<p>示例：使用 <a href="crypto.html#crypto_hmac_update_data_inputencoding"><code>hmac.update()</code></a> 和 <a href="crypto.html#crypto_hmac_digest_encoding"><code>hmac.digest()</code></a> 方法：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

hmac.update(<span class="hljs-string">'some data to hash'</span>);
<span class="hljs-built_in">console</span>.log(hmac.digest(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

hmac.update(<span class="hljs-string">'some data to hash'</span>);
<span class="hljs-built_in">console</span>.log(hmac.digest(<span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e</span></code></pre>
<h4><code>hmac.digest([encoding])</code><span><a class="mark" href="#crypto_hmac_digest_encoding" id="crypto_hmac_digest_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="hmac_digest_encoding">
                <a href="crypto/hmac_digest_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.94</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>计算使用 <a href="crypto.html#crypto_hmac_update_data_inputencoding"><code>hmac.update()</code></a> 传入的所有数据的 HMAC 摘要。
如果提供了 <code>encoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>；</p>
<p><code>Hmac</code> 对象在 <code>hmac.digest()</code> 被调用后不能再次使用。
多次调用 <code>hmac.digest()</code> 将导致抛出错误。</p>
<h4><code>hmac.update(data[, inputEncoding])</code><span><a class="mark" href="#crypto_hmac_update_data_inputencoding" id="crypto_hmac_update_data_inputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="hmac_update_data_inputencoding">
                <a href="crypto/hmac_update_data_inputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.0.0</td>
<td><p>默认 <code>inputEncoding</code> 从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>data</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>data</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>使用给定的 <code>data</code> 更新 <code>Hmac</code> 内容，其编码在 <code>inputEncoding</code> 中给出。
如果未提供 <code>encoding</code>，而 <code>data</code> 是字符串，则强制执行 <code>'utf8'</code> 编码。
如果 <code>data</code> 是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>，则忽略 <code>inputEncoding</code>。</p>
<p>这可以在流式传输时使用新数据多次调用。</p>
</section><section><h3><code>KeyObject</code> 类<span><a class="mark" href="#crypto_class_keyobject" id="crypto_class_keyobject">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_keyobject">
                <a href="crypto/class_keyobject.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.5.0, v12.19.0</td>
<td><p>现在可以使用 <code>postMessage</code> 将此类的实例传给工作线程。</p></td></tr>
<tr><td>v11.13.0</td>
<td><p>该类现已导出。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p><span>新增于: v11.6.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>Node.js 使用 <code>KeyObject</code> 类来表示对称或非对称密钥，每种密钥暴露不同的功能。
<a href="crypto.html#crypto_crypto_createsecretkey_key_encoding"><code>crypto.createSecretKey()</code></a>、<a href="crypto.html#crypto_crypto_createpublickey_key"><code>crypto.createPublicKey()</code></a> 和 <a href="crypto.html#crypto_crypto_createprivatekey_key"><code>crypto.createPrivateKey()</code></a> 方法用于创建 <code>KeyObject</code> 实例。
<code>KeyObject</code> 对象不能直接使用 <code>new</code> 关键字创建。</p>
<p>由于改进的安全功能，大多数应用程序应该考虑使用新的 <code>KeyObject</code> API 而不是将密钥作为字符串或 <code>Buffer</code> 传入。</p>
<p><code>KeyObject</code> 实例可以通过 <a href="worker_threads.html#worker_threads_port_postmessage_value_transferlist"><code>postMessage()</code></a> 传给其他线程。
接收者获得克隆的 <code>KeyObject</code>，<code>KeyObject</code> 不需要在 <code>transferList</code> 参数中列出。</p>
<h4><code>KeyObject.from(key)</code><span><a class="mark" href="#crypto_static_method_keyobject_from_key" id="crypto_static_method_keyobject_from_key">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="static_method_keyobject_from_key">
                <a href="crypto/static_method_keyobject_from_key.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>key</code> <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a></li>
<li>返回: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
<p>示例：将 <code>CryptoKey</code> 实例转换为 <code>KeyObject</code>：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">webcrypto</span>: {
    subtle,
  },
  KeyObject,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> key = <span class="hljs-keyword">await</span> subtle.generateKey({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'HMAC'</span>,
  <span class="hljs-attr">hash</span>: <span class="hljs-string">'SHA-256'</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-number">256</span>
}, <span class="hljs-literal">true</span>, [<span class="hljs-string">'sign'</span>, <span class="hljs-string">'verify'</span>]);

<span class="hljs-keyword">const</span> keyObject = KeyObject.from(key);
<span class="hljs-built_in">console</span>.log(keyObject.symmetricKeySize);
<span class="hljs-comment">// 打印: 32 (（以字节为单位的对称密钥大小）)</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  <span class="hljs-attr">webcrypto</span>: {
    subtle,
  },
  KeyObject,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">await</span> subtle.generateKey({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'HMAC'</span>,
    <span class="hljs-attr">hash</span>: <span class="hljs-string">'SHA-256'</span>,
    <span class="hljs-attr">length</span>: <span class="hljs-number">256</span>
  }, <span class="hljs-literal">true</span>, [<span class="hljs-string">'sign'</span>, <span class="hljs-string">'verify'</span>]);

  <span class="hljs-keyword">const</span> keyObject = KeyObject.from(key);
  <span class="hljs-built_in">console</span>.log(keyObject.symmetricKeySize);
  <span class="hljs-comment">// 打印: 32 (（以字节为单位的对称密钥大小）)</span>
})();</code></pre>
<h4><code>keyObject.asymmetricKeyDetails</code><span><a class="mark" href="#crypto_keyobject_asymmetrickeydetails" id="crypto_keyobject_asymmetrickeydetails">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="keyobject_asymmetrickeydetails">
                <a href="crypto/keyobject_asymmetrickeydetails.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.7.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>modulusLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 以位为单位的密钥大小（RSA、DSA）。</li>
<li><code>publicExponent</code>: <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a> 公共指数 (RSA)。</li>
<li><code>divisorLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>q</code> 的比特大小 (DSA)。</li>
<li><code>namedCurve</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 曲线名称 (EC)。</li>
</ul>
</li>
</ul>
<p>此属性仅存在于非对称密钥上。
根据密钥的类型，此对象包含有关密钥的信息。
通过此属性获得的任何信息都不能用于唯一标识密钥或危及密钥的安全性。</p>
<p>RSA-PSS 参数、DH 或任何未来的密钥类型详细信息可能会使用其他属性通过此 API 暴露。</p>
<h4><code>keyObject.asymmetricKeyType</code><span><a class="mark" href="#crypto_keyobject_asymmetrickeytype" id="crypto_keyobject_asymmetrickeytype">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="keyobject_asymmetrickeytype">
                <a href="crypto/keyobject_asymmetrickeytype.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.9.0, v12.17.0</td>
<td><p>添加了对 <code>'dh'</code> 的支持。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>添加了对 <code>'rsa-pss'</code> 的支持。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>此属性现在为无法识别类型的 KeyObject 实例返回 <code>undefined</code> 而不是中止。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>添加了对 <code>'x25519'</code> 和 <code>'x448'</code> 的支持。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>添加了对 <code>'ed25519'</code> 和 <code>'ed448'</code> 的支持。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p><span>新增于: v11.6.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>对于非对称密钥，此属性表示密钥的类型。
支持的密钥类型有：</p>
<ul>
<li><code>'rsa'</code> (OID 1.2.840.113549.1.1.1)</li>
<li><code>'rsa-pss'</code> (OID 1.2.840.113549.1.1.10)</li>
<li><code>'dsa'</code> (OID 1.2.840.10040.4.1)</li>
<li><code>'ec'</code> (OID 1.2.840.10045.2.1)</li>
<li><code>'x25519'</code> (OID 1.3.101.110)</li>
<li><code>'x448'</code> (OID 1.3.101.111)</li>
<li><code>'ed25519'</code> (OID 1.3.101.112)</li>
<li><code>'ed448'</code> (OID 1.3.101.113)</li>
<li><code>'dh'</code> (OID 1.2.840.113549.1.3.1)</li>
</ul>
<p>对于无法识别的 <code>KeyObject</code> 类型和对称密钥，此属性为 <code>undefined</code>。</p>
<h4><code>keyObject.export([options])</code><span><a class="mark" href="#crypto_keyobject_export_options" id="crypto_keyobject_export_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="keyobject_export_options">
                <a href="crypto/keyobject_export_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.9.0</td>
<td><p>添加了对 <code>'jwk'</code> 格式的支持。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p><span>新增于: v11.6.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>options</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>对于对称密钥，可以使用以下编码选项：</p>
<ul>
<li><code>format</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'buffer'</code>（默认）或 <code>'jwk'</code>。</li>
</ul>
<p>对于公钥，可以使用以下编码选项：</p>
<ul>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pkcs1'</code>（仅限 RSA）或 <code>'spki'</code> 之一。</li>
<li><code>format</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pem'</code>、<code>'der'</code> 或 <code>'jwk'</code>。</li>
</ul>
<p>对于私钥，可以使用以下编码选项：</p>
<ul>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pkcs1'</code>（仅限 RSA）、<code>'pkcs8'</code> 或 <code>'sec1'</code>（仅限 EC）之一。</li>
<li><code>format</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pem'</code>、<code>'der'</code> 或 <code>'jwk'</code>。</li>
<li><code>cipher</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 如果指定，则私钥将使用给定的 <code>cipher</code> 和 <code>passphrase</code> 使用基于 PKCS#5 v2.0 密码的加密进行加密。</li>
<li><code>passphrase</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 用于加密的密码，参见 <code>cipher</code>。</li>
</ul>
<p>结果类型取决于选择的编码格式，当 PEM 结果是字符串时，当 DER 将是包含编码为 DER 的数据的缓冲区，当 <a href="http://url.nodejs.cn/Tbud1K">JWK</a> 时它将是对象。</p>
<p>选择 <a href="http://url.nodejs.cn/Tbud1K">JWK</a> 编码格式时，将忽略所有其他编码选项。</p>
<p>PKCS#1、SEC1 和 PKCS#8 类型的密钥可以通过使用 <code>cipher</code> 和 <code>format</code> 选项的组合进行加密。
PKCS#8 <code>type</code> 可以与任何 <code>format</code> 一起使用，通过指定 <code>cipher</code> 来加密任何密钥算法（RSA、EC 或 DH）。
当使用 PEM <code>format</code> 时，PKCS#1 和 SEC1 只能通过指定 <code>cipher</code> 来加密。
为了获得最大的兼容性，对加密的私钥使用 PKCS#8。
由于 PKCS#8 定义了自己的加密机制，因此在加密 PKCS#8 密钥时不支持 PEM 级加密。
PKCS#8 加密参见 <a href="http://url.nodejs.cn/2NHVsz">RFC 5208</a>，PKCS#1 和 SEC1 加密参见 <a href="http://url.nodejs.cn/DreNtw">RFC 1421</a>。</p>
<h4><code>keyObject.symmetricKeySize</code><span><a class="mark" href="#crypto_keyobject_symmetrickeysize" id="crypto_keyobject_symmetrickeysize">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="keyobject_symmetrickeysize">
                <a href="crypto/keyobject_symmetrickeysize.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.6.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>对于秘密密钥，此属性表示密钥的大小（以字节为单位）。
对于非对称密钥，此属性为 <code>undefined</code>。</p>
<h4><code>keyObject.type</code><span><a class="mark" href="#crypto_keyobject_type" id="crypto_keyobject_type">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="keyobject_type">
                <a href="crypto/keyobject_type.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.6.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>根据此 <code>KeyObject</code> 的类型，此属性是 <code>'secret'</code> 表示秘密（对称）密钥，<code>'public'</code> 表示公共（非对称）密钥或 <code>'private'</code> 表示私有（非对称）密钥。</p>
</section><section><h3><code>Sign</code> 类<span><a class="mark" href="#crypto_class_sign" id="crypto_class_sign">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_sign">
                <a href="crypto/class_sign.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div>
<ul>
<li>继承自: <a href="stream.html#stream_class_stream_writable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a></li>
</ul>
<p><code>Sign</code> 类是用于生成签名的实用工具。
它可以通过以下两种方式之一使用：</p>
<ul>
<li>作为可写<a href="stream.html">流</a>，写入要签名的数据，使用 <a href="crypto.html#crypto_sign_sign_privatekey_outputencoding"><code>sign.sign()</code></a> 方法生成并返回签名，或者</li>
<li>使用 <a href="crypto.html#crypto_sign_update_data_inputencoding"><code>sign.update()</code></a> 和 <a href="crypto.html#crypto_sign_sign_privatekey_outputencoding"><code>sign.sign()</code></a> 方法生成签名。</li>
</ul>
<p><a href="crypto.html#crypto_crypto_createsign_algorithm_options"><code>crypto.createSign()</code></a> 方法用于创建 <code>Sign</code> 实例。
参数是要使用的哈希函数的字符串名称。
<code>Sign</code> 对象不能直接使用 <code>new</code> 关键字创建。</p>
<p>示例：使用 <code>Sign</code> 和 <a href="crypto.html#crypto_class_verify"><code>Verify</code></a> 对象作为流：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  generateKeyPairSync,
  createSign,
  createVerify,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> { privateKey, publicKey } = generateKeyPairSync(<span class="hljs-string">'ec'</span>, {
  <span class="hljs-attr">namedCurve</span>: <span class="hljs-string">'sect239k1'</span>
});

<span class="hljs-keyword">const</span> sign = createSign(<span class="hljs-string">'SHA256'</span>);
sign.write(<span class="hljs-string">'some data to sign'</span>);
sign.end();
<span class="hljs-keyword">const</span> signature = sign.sign(privateKey, <span class="hljs-string">'hex'</span>);

<span class="hljs-keyword">const</span> verify = createVerify(<span class="hljs-string">'SHA256'</span>);
verify.write(<span class="hljs-string">'some data to sign'</span>);
verify.end();
<span class="hljs-built_in">console</span>.log(verify.verify(publicKey, signature, <span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 打印: true</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  generateKeyPairSync,
  createSign,
  createVerify,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> { privateKey, publicKey } = generateKeyPairSync(<span class="hljs-string">'ec'</span>, {
  <span class="hljs-attr">namedCurve</span>: <span class="hljs-string">'sect239k1'</span>
});

<span class="hljs-keyword">const</span> sign = createSign(<span class="hljs-string">'SHA256'</span>);
sign.write(<span class="hljs-string">'some data to sign'</span>);
sign.end();
<span class="hljs-keyword">const</span> signature = sign.sign(privateKey, <span class="hljs-string">'hex'</span>);

<span class="hljs-keyword">const</span> verify = createVerify(<span class="hljs-string">'SHA256'</span>);
verify.write(<span class="hljs-string">'some data to sign'</span>);
verify.end();
<span class="hljs-built_in">console</span>.log(verify.verify(publicKey, signature, <span class="hljs-string">'hex'</span>));
<span class="hljs-comment">// 打印: true</span></code></pre>
<p>示例：使用 <a href="crypto.html#crypto_sign_update_data_inputencoding"><code>sign.update()</code></a> 和 <a href="crypto.html#crypto_verify_update_data_inputencoding"><code>verify.update()</code></a> 方法：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  generateKeyPairSync,
  createSign,
  createVerify,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> { privateKey, publicKey } = generateKeyPairSync(<span class="hljs-string">'rsa'</span>, {
  <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">2048</span>,
});

<span class="hljs-keyword">const</span> sign = createSign(<span class="hljs-string">'SHA256'</span>);
sign.update(<span class="hljs-string">'some data to sign'</span>);
sign.end();
<span class="hljs-keyword">const</span> signature = sign.sign(privateKey);

<span class="hljs-keyword">const</span> verify = createVerify(<span class="hljs-string">'SHA256'</span>);
verify.update(<span class="hljs-string">'some data to sign'</span>);
verify.end();
<span class="hljs-built_in">console</span>.log(verify.verify(publicKey, signature));
<span class="hljs-comment">// 打印: true</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  generateKeyPairSync,
  createSign,
  createVerify,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> { privateKey, publicKey } = generateKeyPairSync(<span class="hljs-string">'rsa'</span>, {
  <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">2048</span>,
});

<span class="hljs-keyword">const</span> sign = createSign(<span class="hljs-string">'SHA256'</span>);
sign.update(<span class="hljs-string">'some data to sign'</span>);
sign.end();
<span class="hljs-keyword">const</span> signature = sign.sign(privateKey);

<span class="hljs-keyword">const</span> verify = createVerify(<span class="hljs-string">'SHA256'</span>);
verify.update(<span class="hljs-string">'some data to sign'</span>);
verify.end();
<span class="hljs-built_in">console</span>.log(verify.verify(publicKey, signature));
<span class="hljs-comment">// 打印: true</span></code></pre>
<h4><code>sign.sign(privateKey[, outputEncoding])</code><span><a class="mark" href="#crypto_sign_sign_privatekey_outputencoding" id="crypto_sign_sign_privatekey_outputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="sign_sign_privatekey_outputencoding">
                <a href="crypto/sign_sign_privatekey_outputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>privateKey 也可以是 ArrayBuffer 和 CryptoKey。</p></td></tr>
<tr><td>v13.2.0, v12.16.0</td>
<td><p>此函数现在支持 IEEE-P1363 DSA 和 ECDSA 签名。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>此函数现在支持 RSA-PSS 密钥。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>此函数现在支持密钥对象。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>添加了对 RSASSA-PSS 和其他选项的支持。</p></td></tr>
<tr><td>v0.1.92</td>
<td><p><span>新增于: v0.1.92</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>privateKey</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
<ul>
<li><code>dsaEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>padding</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>saltLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
</li>
<li><code>outputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 返回值的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<!--lint enable maximum-line-length remark-lint-->
<p>使用 <a href="crypto.html#crypto_sign_update_data_inputencoding"><code>sign.update()</code></a> 或 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>sign.write()</code></a> 计算通过的所有数据的签名。</p>
<p>如果 <code>privateKey</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>privateKey</code> 传给 <a href="crypto.html#crypto_crypto_createprivatekey_key"><code>crypto.createPrivateKey()</code></a> 一样。
如果是对象，则可以传入以下额外属性：</p>
<ul>
<li>
<p><code>dsaEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 对于 DSA 和 ECDSA，此选项指定生成签名的格式。
它可以是以下之一：</p>
<ul>
<li><code>'der'</code>（默认）：DER 编码的 ASN.1 签名结构编码 <code>(r, s)</code>。</li>
<li><code>'ieee-p1363'</code>: IEEE-P1363 中提议的签名格式 <code>r || s</code>。</li>
</ul>
</li>
<li>
<p><code>padding</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> RSA 的可选填充值，以下之一：</p>
<ul>
<li><code>crypto.constants.RSA_PKCS1_PADDING</code>（默认）</li>
<li><code>crypto.constants.RSA_PKCS1_PSS_PADDING</code></li>
</ul>
<p><code>RSA_PKCS1_PSS_PADDING</code> 将使用具有与 <a href="http://url.nodejs.cn/o3Gr5v">RFC 4055</a> 的第 3.1 章节中指定的消息签名相同的散列函数的 MGF1，除非 MGF1 散列函数已被指定为符合 <a href="http://url.nodejs.cn/o3Gr5v">RFC 4055</a> 的第 3.3 章节的密钥的一部分。</p>
</li>
<li>
<p><code>saltLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 填充为 <code>RSA_PKCS1_PSS_PADDING</code> 时的盐长度。
特殊值 <code>crypto.constants.RSA_PSS_SALTLEN_DIGEST</code> 将盐长度设置为摘要大小，<code>crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN</code>（默认值）将其设置为最大允许值。</p>
</li>
</ul>
<p>如果提供了 <code>outputEncoding</code>，则返回字符串；否则返回 <a href="buffer.html"><code>Buffer</code></a>。</p>
<p><code>Sign</code> 对象在调用 <code>sign.sign()</code> 方法后不能再次使用。
多次调用 <code>sign.sign()</code> 将导致抛出错误。</p>
<h4><code>sign.update(data[, inputEncoding])</code><span><a class="mark" href="#crypto_sign_update_data_inputencoding" id="crypto_sign_update_data_inputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="sign_update_data_inputencoding">
                <a href="crypto/sign_update_data_inputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.0.0</td>
<td><p>默认 <code>inputEncoding</code> 从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.1.92</td>
<td><p><span>新增于: v0.1.92</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>data</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>data</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>使用给定的 <code>data</code> 更新 <code>Sign</code> 内容，其编码在 <code>inputEncoding</code> 中给出。
如果未提供 <code>encoding</code>，而 <code>data</code> 是字符串，则强制执行 <code>'utf8'</code> 编码。
如果 <code>data</code> 是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>，则忽略 <code>inputEncoding</code>。</p>
<p>这可以在流式传输时使用新数据多次调用。</p>
</section><section><h3><code>Verify</code> 类<span><a class="mark" href="#crypto_class_verify" id="crypto_class_verify">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_verify">
                <a href="crypto/class_verify.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div>
<ul>
<li>继承自: <a href="stream.html#stream_class_stream_writable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a></li>
</ul>
<p><code>Verify</code> 类是用于验证签名的实用工具。
它可以通过以下两种方式之一使用：</p>
<ul>
<li>作为可写<a href="stream.html">流</a>，其中写入的数据用于根据提供的签名进行验证，或者</li>
<li>使用 <a href="crypto.html#crypto_verify_update_data_inputencoding"><code>verify.update()</code></a> 和 <a href="crypto.html#crypto_verify_verify_object_signature_signatureencoding"><code>verify.verify()</code></a> 方法来验证签名。</li>
</ul>
<p><a href="crypto.html#crypto_crypto_createverify_algorithm_options"><code>crypto.createVerify()</code></a> 方法用于创建 <code>Verify</code> 实例。
<code>Verify</code> 对象不能直接使用 <code>new</code> 关键字创建。</p>
<p>有关示例，请参见 <a href="crypto.html#crypto_class_sign"><code>Sign</code></a>。</p>
<h4><code>verify.update(data[, inputEncoding])</code><span><a class="mark" href="#crypto_verify_update_data_inputencoding" id="crypto_verify_update_data_inputencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="verify_update_data_inputencoding">
                <a href="crypto/verify_update_data_inputencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.0.0</td>
<td><p>默认 <code>inputEncoding</code> 从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.1.92</td>
<td><p><span>新增于: v0.1.92</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>data</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>inputEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>data</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
</ul>
<p>使用给定的 <code>data</code> 更新 <code>Verify</code> 内容，其编码在 <code>inputEncoding</code> 中给出。
如果未提供 <code>inputEncoding</code>，而 <code>data</code> 是字符串，则强制执行 <code>'utf8'</code> 编码。
如果 <code>data</code> 是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>，则忽略 <code>inputEncoding</code>。</p>
<p>这可以在流式传输时使用新数据多次调用。</p>
<h4><code>verify.verify(object, signature[, signatureEncoding])</code><span><a class="mark" href="#crypto_verify_verify_object_signature_signatureencoding" id="crypto_verify_verify_object_signature_signatureencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="verify_verify_object_signature_signatureencoding">
                <a href="crypto/verify_verify_object_signature_signatureencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>该对象也可以是 ArrayBuffer 和 CryptoKey。</p></td></tr>
<tr><td>v13.2.0, v12.16.0</td>
<td><p>此函数现在支持 IEEE-P1363 DSA 和 ECDSA 签名。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>此函数现在支持 RSA-PSS 密钥。</p></td></tr>
<tr><td>v11.7.0</td>
<td><p>密钥现在可以是私钥。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>添加了对 RSASSA-PSS 和其他选项的支持。</p></td></tr>
<tr><td>v0.1.92</td>
<td><p><span>新增于: v0.1.92</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>object</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
<ul>
<li><code>dsaEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>padding</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>saltLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
</li>
<li><code>signature</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>signatureEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>signature</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <code>true</code> 或 <code>false</code> 取决于数据和公钥签名的有效性。
  <!--lint enable maximum-line-length remark-lint-->
</li>
</ul>
<p>使用给定的 <code>object</code> 和 <code>signature</code> 验证提供的数据。</p>
<p>如果 <code>object</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>object</code> 传给 <a href="crypto.html#crypto_crypto_createpublickey_key"><code>crypto.createPublicKey()</code></a> 一样。
如果是对象，则可以传入以下额外属性：</p>
<ul>
<li>
<p><code>dsaEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 对于 DSA 和 ECDSA，此选项指定签名的格式。
它可以是以下之一：</p>
<ul>
<li><code>'der'</code>（默认）：DER 编码的 ASN.1 签名结构编码 <code>(r, s)</code>。</li>
<li><code>'ieee-p1363'</code>: IEEE-P1363 中提议的签名格式 <code>r || s</code>。</li>
</ul>
</li>
<li>
<p><code>padding</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> RSA 的可选填充值，以下之一：</p>
<ul>
<li><code>crypto.constants.RSA_PKCS1_PADDING</code>（默认）</li>
<li><code>crypto.constants.RSA_PKCS1_PSS_PADDING</code></li>
</ul>
<p><code>RSA_PKCS1_PSS_PADDING</code> 将使用具有相同散列函数的 MGF1，用于验证 <a href="http://url.nodejs.cn/o3Gr5v">RFC 4055</a> 的第 3.1 章节中指定的消息，除非 MGF1 散列函数已被指定为符合 <a href="http://url.nodejs.cn/o3Gr5v">RFC 4055</a> 的第 3.3 章节的密钥的一部分。</p>
</li>
<li>
<p><code>saltLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 填充为 <code>RSA_PKCS1_PSS_PADDING</code> 时的盐长度。
特殊值 <code>crypto.constants.RSA_PSS_SALTLEN_DIGEST</code> 将盐长度设置为摘要大小，<code>crypto.constants.RSA_PSS_SALTLEN_AUTO</code>（默认值）使其自动确定。</p>
</li>
</ul>
<p><code>signature</code> 参数是先前计算的数据签名，在 <code>signatureEncoding</code> 中。
如果指定了 <code>signatureEncoding</code>，则 <code>signature</code> 应该是字符串； 否则 <code>signature</code> 应该是 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p><code>verify</code> 对象在 <code>verify.verify()</code> 被调用后不能再次使用。
多次调用 <code>verify.verify()</code> 将导致抛出错误。</p>
<p>因为公钥可以从私钥导出，所以可以传递私钥而不是公钥。</p>
</section><section><h3><code>X509Certificate</code> 类<span><a class="mark" href="#crypto_class_x509certificate" id="crypto_class_x509certificate">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_x509certificate">
                <a href="crypto/class_x509certificate.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<p>封装 X509 证书并提供对其信息的只读访问。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> { X509Certificate } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> x509 = <span class="hljs-keyword">new</span> X509Certificate(<span class="hljs-string">'{... pem encoded cert ...}'</span>);

<span class="hljs-built_in">console</span>.log(x509.subject);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> { X509Certificate } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> x509 = <span class="hljs-keyword">new</span> X509Certificate(<span class="hljs-string">'{... pem encoded cert ...}'</span>);

<span class="hljs-built_in">console</span>.log(x509.subject);</code></pre>
<h4><code>new X509Certificate(buffer)</code><span><a class="mark" href="#crypto_new_x509certificate_buffer" id="crypto_new_x509certificate_buffer">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="new_x509certificate_buffer">
                <a href="crypto/new_x509certificate_buffer.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> PEM 或 DER 编码的 X509 证书。</li>
</ul>
<h4><code>x509.ca</code><span><a class="mark" href="#crypto_x509_ca" id="crypto_x509_ca">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_ca">
                <a href="crypto/x509_ca.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果这是证书颁发机构 (ca) 证书，则为 <code>true</code>。</li>
</ul>
<h4><code>x509.checkEmail(email[, options])</code><span><a class="mark" href="#crypto_x509_checkemail_email_options" id="crypto_x509_checkemail_email_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_checkemail_email_options">
                <a href="crypto/x509_checkemail_email_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>email</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>subject</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>'always'</code> 或 <code>'never'</code>。 <strong>默认值:</strong> <code>'always'</code>。</li>
<li><code>wildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code>。</li>
<li><code>partialWildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code>。</li>
<li><code>multiLabelWildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
<li><code>singleLabelSubdomains</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/8ym6ow" rel="nofollow" class="type">&lt;undefined&gt;</a> 如果证书匹配，则返回 <code>email</code>，如果不匹配，则返回 <code>undefined</code>。</li>
</ul>
<p>检查证书是否与给定的电子邮件地址匹配。</p>
<h4><code>x509.checkHost(name[, options])</code><span><a class="mark" href="#crypto_x509_checkhost_name_options" id="crypto_x509_checkhost_name_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_checkhost_name_options">
                <a href="crypto/x509_checkhost_name_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>name</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>subject</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>'always'</code> 或 <code>'never'</code>。 <strong>默认值:</strong> <code>'always'</code>。</li>
<li><code>wildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code>。</li>
<li><code>partialWildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code>。</li>
<li><code>multiLabelWildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
<li><code>singleLabelSubdomains</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/8ym6ow" rel="nofollow" class="type">&lt;undefined&gt;</a> 如果证书匹配，则返回 <code>name</code>，如果不匹配，则返回 <code>undefined</code>。</li>
</ul>
<p>检查证书是否与给定的主机名匹配。</p>
<h4><code>x509.checkIP(ip[, options])</code><span><a class="mark" href="#crypto_x509_checkip_ip_options" id="crypto_x509_checkip_ip_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_checkip_ip_options">
                <a href="crypto/x509_checkip_ip_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>ip</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>subject</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>'always'</code> 或 <code>'never'</code>。 <strong>默认值:</strong> <code>'always'</code>。</li>
<li><code>wildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code>。</li>
<li><code>partialWildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>true</code>。</li>
<li><code>multiLabelWildcards</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
<li><code>singleLabelSubdomains</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/8ym6ow" rel="nofollow" class="type">&lt;undefined&gt;</a> 如果证书匹配，则返回 <code>ip</code>，如果不匹配，则返回 <code>undefined</code>。</li>
</ul>
<p>检查证书是否与给定的 IP 地址（IPv4 或 IPv6）匹配。</p>
<h4><code>x509.checkIssued(otherCert)</code><span><a class="mark" href="#crypto_x509_checkissued_othercert" id="crypto_x509_checkissued_othercert">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_checkissued_othercert">
                <a href="crypto/x509_checkissued_othercert.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>otherCert</code> <a href="crypto.html#crypto_class_x509certificate" rel="nofollow" class="type">&lt;X509Certificate&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>检查此证书是否由给定的 <code>otherCert</code> 颁发。</p>
<h4><code>x509.checkPrivateKey(privateKey)</code><span><a class="mark" href="#crypto_x509_checkprivatekey_privatekey" id="crypto_x509_checkprivatekey_privatekey">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_checkprivatekey_privatekey">
                <a href="crypto/x509_checkprivatekey_privatekey.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>privateKey</code> <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> 私钥。</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>检查此证书的公钥是否与给定的私钥一致。</p>
<h4><code>x509.fingerprint</code><span><a class="mark" href="#crypto_x509_fingerprint" id="crypto_x509_fingerprint">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_fingerprint">
                <a href="crypto/x509_fingerprint.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>此证书的 SHA-1 指纹。</p>
<h4><code>x509.fingerprint256</code><span><a class="mark" href="#crypto_x509_fingerprint256" id="crypto_x509_fingerprint256">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_fingerprint256">
                <a href="crypto/x509_fingerprint256.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>此证书的 SHA-256 指纹。</p>
<h4><code>x509.infoAccess</code><span><a class="mark" href="#crypto_x509_infoaccess" id="crypto_x509_infoaccess">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_infoaccess">
                <a href="crypto/x509_infoaccess.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>本证书的信息访问内容。</p>
<h4><code>x509.issuer</code><span><a class="mark" href="#crypto_x509_issuer" id="crypto_x509_issuer">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_issuer">
                <a href="crypto/x509_issuer.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>此证书中包含的发行人标识。</p>
<h4><code>x509.issuerCertificate</code><span><a class="mark" href="#crypto_x509_issuercertificate" id="crypto_x509_issuercertificate">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_issuercertificate">
                <a href="crypto/x509_issuercertificate.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.9.0</span>
</div>
<ul>
<li>Type: <a href="crypto.html#crypto_class_x509certificate" rel="nofollow" class="type">&lt;X509Certificate&gt;</a></li>
</ul>
<p>颁发者证书或 <code>undefined</code>（如果颁发者证书不可用）。</p>
<h4><code>x509.keyUsage</code><span><a class="mark" href="#crypto_x509_keyusage" id="crypto_x509_keyusage">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_keyusage">
                <a href="crypto/x509_keyusage.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string[]&gt;</a></li>
</ul>
<p>详细说明此证书的密钥用法的数组。</p>
<h4><code>x509.publicKey</code><span><a class="mark" href="#crypto_x509_publickey" id="crypto_x509_publickey">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_publickey">
                <a href="crypto/x509_publickey.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
<p>此证书的公钥 <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a>。</p>
<h4><code>x509.raw</code><span><a class="mark" href="#crypto_x509_raw" id="crypto_x509_raw">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_raw">
                <a href="crypto/x509_raw.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>包含此证书的 DER 编码的 <code>Buffer</code>。</p>
<h4><code>x509.serialNumber</code><span><a class="mark" href="#crypto_x509_serialnumber" id="crypto_x509_serialnumber">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_serialnumber">
                <a href="crypto/x509_serialnumber.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>此证书的序列号。</p>
<h4><code>x509.subject</code><span><a class="mark" href="#crypto_x509_subject" id="crypto_x509_subject">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_subject">
                <a href="crypto/x509_subject.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>本证书的完整主题。</p>
<h4><code>x509.subjectAltName</code><span><a class="mark" href="#crypto_x509_subjectaltname" id="crypto_x509_subjectaltname">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_subjectaltname">
                <a href="crypto/x509_subjectaltname.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>为此证书指定的使用者备用名称。</p>
<h4><code>x509.toJSON()</code><span><a class="mark" href="#crypto_x509_tojson" id="crypto_x509_tojson">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_tojson">
                <a href="crypto/x509_tojson.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>X509 证书没有标准的 JSON 编码。
<code>toJSON()</code> 方法返回包含 PEM 编码证书的字符串。</p>
<h4><code>x509.toLegacyObject()</code><span><a class="mark" href="#crypto_x509_tolegacyobject" id="crypto_x509_tolegacyobject">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_tolegacyobject">
                <a href="crypto/x509_tolegacyobject.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>使用旧版的<a href="tls.html#tls_certificate_object">证书对象</a>编码返回有关此证书的信息。</p>
<h4><code>x509.toString()</code><span><a class="mark" href="#crypto_x509_tostring" id="crypto_x509_tostring">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_tostring">
                <a href="crypto/x509_tostring.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>返回 PEM 编码的证书。</p>
<h4><code>x509.validFrom</code><span><a class="mark" href="#crypto_x509_validfrom" id="crypto_x509_validfrom">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_validfrom">
                <a href="crypto/x509_validfrom.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>此证书被视为有效的起始日期/时间。</p>
<h4><code>x509.validTo</code><span><a class="mark" href="#crypto_x509_validto" id="crypto_x509_validto">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_validto">
                <a href="crypto/x509_validto.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>此证书被视为有效的结束日期/时间。</p>
<h4><code>x509.verify(publicKey)</code><span><a class="mark" href="#crypto_x509_verify_publickey" id="crypto_x509_verify_publickey">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="x509_verify_publickey">
                <a href="crypto/x509_verify_publickey.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>publicKey</code> <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> 公钥。</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>验证此证书是否由给定的公钥签名。
不对证书执行任何其他验证检查。</p>
</section><section><h3>加密模块的方法和属性<span><a class="mark" href="#crypto_crypto_module_methods_and_properties" id="crypto_crypto_module_methods_and_properties">#</a></span></h3>
<h4><code>crypto.constants</code><span><a class="mark" href="#crypto_crypto_constants" id="crypto_crypto_constants">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_constants">
                <a href="crypto/crypto_constants.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v6.3.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 包含用于加密和安全相关操作的常用常量的对象。
当前定义的特定常量在<a href="crypto.html#crypto_crypto_constants_1">加密常量</a>中进行了描述。</li>
</ul>
<h4><code>crypto.DEFAULT_ENCODING</code><span><a class="mark" href="#crypto_crypto_default_encoding" id="crypto_crypto_default_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_default_encoding">
                <a href="crypto/crypto_default_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.3</span><span>弃用于: v10.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 弃用</div><p></p>
<p>用于可以采用字符串或<a href="buffer.html">缓冲区</a>的函数的默认编码。
默认值为 <code>'buffer'</code>，这使得方法默认为 <a href="buffer.html"><code>Buffer</code></a> 对象。</p>
<p>提供 <code>crypto.DEFAULT_ENCODING</code> 机制是为了与期望 <code>'latin1'</code> 作为默认编码的遗留程序向后兼容。</p>
<p>新应用程序应该期望默认值为 <code>'buffer'</code>。</p>
<p>此属性已弃用。</p>
<h4><code>crypto.fips</code><span><a class="mark" href="#crypto_crypto_fips" id="crypto_crypto_fips">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_fips">
                <a href="crypto/crypto_fips.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v6.0.0</span><span>弃用于: v10.0.0</span>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 弃用</div><p></p>
<p>用于检查和控制当前是否正在使用符合 FIPS 的加密提供程序的属性。
设置为 true 需要 Node.js 的 FIPS 构建。</p>
<p>此属性已弃用。
请改用 <code>crypto.setFips()</code> 和 <code>crypto.getFips()</code>。</p>
<h4><code>crypto.checkPrime(candidate[, options, [callback]])</code><span><a class="mark" href="#crypto_crypto_checkprime_candidate_options_callback" id="crypto_crypto_checkprime_candidate_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_checkprime_candidate_options_callback">
                <a href="crypto/crypto_checkprime_candidate_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.8.0</span>
</div>
<ul>
<li><code>candidate</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a>
编码为任意长度的大端字节序序列的可能素数。</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>checks</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要执行的 Miller-Rabin 概率素性迭代次数。
当值为 <code>0</code>（零）时，使用多次检查对随机输入产生最多 2<sup>-64</sup> 的误报率。
选择多个检查时必须小心。
有关更多详细信息，请参阅 <a href="http://url.nodejs.cn/y6xmHD"><code>BN_is_prime_ex</code></a> 函数 <code>nchecks</code> 选项的 OpenSSL 文档。 <strong>默认值:</strong> <code>0</code></li>
</ul>
</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> 如果检查期间发生错误，则设置为 <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> 对象。</li>
<li><code>result</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果候选者是错误概率小于 <code>0.25 ** options.checks</code> 的素数，则为 <code>true</code>。</li>
</ul>
</li>
</ul>
<p>检查 <code>candidate</code> 的素性。</p>
<h4><code>crypto.checkPrimeSync(candidate[, options])</code><span><a class="mark" href="#crypto_crypto_checkprimesync_candidate_options" id="crypto_crypto_checkprimesync_candidate_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_checkprimesync_candidate_options">
                <a href="crypto/crypto_checkprimesync_candidate_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.8.0</span>
</div>
<ul>
<li><code>candidate</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a>
编码为任意长度的大端字节序序列的可能素数。</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>checks</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要执行的 Miller-Rabin 概率素性迭代次数。
当值为 <code>0</code>（零）时，使用多次检查对随机输入产生最多 2<sup>-64</sup> 的误报率。
选择多个检查时必须小心。
有关更多详细信息，请参阅 <a href="http://url.nodejs.cn/y6xmHD"><code>BN_is_prime_ex</code></a> 函数 <code>nchecks</code> 选项的 OpenSSL 文档。 <strong>默认值:</strong> <code>0</code></li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果候选者是错误概率小于 <code>0.25 ** options.checks</code> 的素数，则为 <code>true</code>。</li>
</ul>
<p>检查 <code>candidate</code> 的素性。</p>
<h4><code>crypto.createCipher(algorithm, password[, options])</code><span><a class="mark" href="#crypto_crypto_createcipher_algorithm_password_options" id="crypto_crypto_createcipher_algorithm_password_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createcipher_algorithm_password_options">
                <a href="crypto/crypto_createcipher_algorithm_password_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>密码参数可以是 ArrayBuffer 并且限制为最多 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v10.10.0</td>
<td><p>现在支持 OCB 模式下的加密。</p></td></tr>
<tr><td>v10.2.0</td>
<td><p>选项 <code>authTagLength</code> 现在可用于在 GCM 模式下生成较短的身份验证标签，默认为 16 字节。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>弃用于: v10.0.0</span></p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 弃用: 改为使用 <a href="crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options"><code>crypto.createCipheriv()</code></a> 。</div><p></p>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>password</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_cipher" rel="nofollow" class="type">&lt;Cipher&gt;</a></li>
</ul>
<p>创建并返回使用给定 <code>algorithm</code> 和 <code>password</code> 的 <code>Cipher</code> 对象。</p>
<p><code>options</code> 参数控制流的行为，并且是可选的，除非使用 CCM 或 OCB 模式的加密（例如 <code>'aes-128-ccm'</code>）。
在这种情况下，需要 <code>authTagLength</code> 选项并指定身份验证标签的长度（以字节为单位），请参阅 <a href="crypto.html#crypto_ccm_mode">CCM 模式</a>。
在 GCM 模式下，<code>authTagLength</code> 选项不是必需的，但可用于设置 <code>getAuthTag()</code> 将返回的身份验证标签的长度，默认为 16 字节。</p>
<p><code>algorithm</code> 依赖于 OpenSSL，例如 <code>'aes192'</code> 等。
在 OpenSSL 的最新版本中，<code>openssl list -cipher-algorithms</code>（在 OpenSSL 的旧版本中为 <code>openssl list-cipher-algorithms</code>）将显示可用的加密算法。</p>
<p><code>password</code> 用于派生密钥和初始化向量 (IV)。
该值必须是 <code>'latin1'</code> 编码的字符串、<a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p><code>crypto.createCipher()</code> 的实现使用 OpenSSL 函数 <a href="http://url.nodejs.cn/d3vRBX"><code>EVP_BytesToKey</code></a> 派生密钥，摘要算法设置为 MD5，一次迭代，不加盐。
缺少盐允许字典攻击，因为相同的密码总是创建相同的密钥。
低迭代次数和非加密安全散列算法允许非常快速地测试密码。</p>
<p>根据 OpenSSL 建议使用更现代的算法而不是 <a href="http://url.nodejs.cn/d3vRBX"><code>EVP_BytesToKey</code></a>，建议开发人员使用 <a href="crypto.html#crypto_crypto_scrypt_password_salt_keylen_options_callback"><code>crypto.scrypt()</code></a> 自行派生密钥和 IV，并使用 <a href="crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options"><code>crypto.createCipheriv()</code></a> 创建 <code>Cipher</code> 对象。
用户不应在 <code>crypto.createCipher()</code> 中使用计数器模式（例如 CTR、GCM 或 CCM）的密码。
使用它们时会发出警告，以避免导致漏洞的 IV 重用风险。
对于在 GCM 中重用 IV 的情况，请参阅 <a href="http://url.nodejs.cn/i26CfC">Nonce-Disrespecting Adversaries</a> 以获取详细信息。</p>
<h4><code>crypto.createCipheriv(algorithm, key, iv[, options])</code><span><a class="mark" href="#crypto_crypto_createcipheriv_algorithm_key_iv_options" id="crypto_crypto_createcipheriv_algorithm_key_iv_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createcipheriv_algorithm_key_iv_options">
                <a href="crypto/crypto_createcipheriv_algorithm_key_iv_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>密码和 iv 参数可以是 ArrayBuffer，并且每个都限制为最大 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>参数 <code>key</code> 现在可以是 <code>KeyObject</code>。</p></td></tr>
<tr><td>v11.2.0, v10.17.0</td>
<td><p>现在支持加密 <code>chacha20-poly1305</code>。</p></td></tr>
<tr><td>v10.10.0</td>
<td><p>现在支持 OCB 模式下的加密。</p></td></tr>
<tr><td>v10.2.0</td>
<td><p>选项 <code>authTagLength</code> 现在可用于在 GCM 模式下生成较短的身份验证标签，默认为 16 字节。</p></td></tr>
<tr><td>v9.9.0</td>
<td><p>对于不需要初始化向量的加密，<code>iv</code> 参数现在可以为 <code>null</code>。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a></li>
<li><code>iv</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_cipher" rel="nofollow" class="type">&lt;Cipher&gt;</a></li>
</ul>
<p>使用给定的 <code>algorithm</code>、<code>key</code> 和初始化向量（<code>iv</code>）创建并返回 <code>Cipher</code> 对象。</p>
<p><code>options</code> 参数控制流的行为，并且是可选的，除非使用 CCM 或 OCB 模式的加密（例如 <code>'aes-128-ccm'</code>）。
在这种情况下，需要 <code>authTagLength</code> 选项并指定身份验证标签的长度（以字节为单位），请参阅 <a href="crypto.html#crypto_ccm_mode">CCM 模式</a>。
在 GCM 模式下，<code>authTagLength</code> 选项不是必需的，但可用于设置 <code>getAuthTag()</code> 将返回的身份验证标签的长度，默认为 16 字节。</p>
<p><code>algorithm</code> 依赖于 OpenSSL，例如 <code>'aes192'</code> 等。
在 OpenSSL 的最新版本中，<code>openssl list -cipher-algorithms</code>（在 OpenSSL 的旧版本中为 <code>openssl list-cipher-algorithms</code>）将显示可用的加密算法。</p>
<p><code>key</code> 是 <code>algorithm</code> 使用的原始密钥，<code>iv</code> 是<a href="http://url.nodejs.cn/mMnDDL">初始化向量</a>。
两个参数都必须是 <code>'utf8'</code> 编码的字符串、<a href="buffer.html">缓冲区</a>、<code>TypedArray</code> 或 <code>DataView</code>。
<code>key</code> 可以是 <code>secret</code> 类型的 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>。
如果加密不需要初始化向量，则 <code>iv</code> 可以是 <code>null</code>。</p>
<p>为 <code>key</code> 或 <code>iv</code> 传入字符串时，请考虑到<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">当使用字符串作为加密 API 输入时的注意事项</a>。</p>
<p>初始化向量应该是不可预测的和独特的；理想情况下，它们将是加密随机的。
它们不必是机密的：IV 通常不加密就添加到密文消息中。
必须是不可预测的和独特的，但不必是机密的，这听起来可能有些矛盾。请记住，一定不能让攻击者提前预测到给定的 IV。</p>
<h4><code>crypto.createDecipher(algorithm, password[, options])</code><span><a class="mark" href="#crypto_crypto_createdecipher_algorithm_password_options" id="crypto_crypto_createdecipher_algorithm_password_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createdecipher_algorithm_password_options">
                <a href="crypto/crypto_createdecipher_algorithm_password_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.10.0</td>
<td><p>现在支持 OCB 模式下的加密。</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>弃用于: v10.0.0</span></p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_0"><a href="documentation.html#documentation_stability_index">稳定性: 0</a> - 弃用: 改为使用 <a href="crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv_options"><code>crypto.createDecipheriv()</code></a> 。</div><p></p>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>password</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_decipher" rel="nofollow" class="type">&lt;Decipher&gt;</a></li>
</ul>
<p>创建并返回使用给定 <code>algorithm</code> 和 <code>password</code>（键）的 <code>Decipher</code> 对象。</p>
<p><code>options</code> 参数控制流的行为，并且是可选的，除非使用 CCM 或 OCB 模式的加密（例如 <code>'aes-128-ccm'</code>）。
在这种情况下，需要 <code>authTagLength</code> 选项并指定身份验证标签的长度（以字节为单位），请参阅 <a href="crypto.html#crypto_ccm_mode">CCM 模式</a>。</p>
<p><code>crypto.createDecipher()</code> 的实现使用 OpenSSL 函数 <a href="http://url.nodejs.cn/d3vRBX"><code>EVP_BytesToKey</code></a> 派生密钥，摘要算法设置为 MD5，一次迭代，不加盐。
缺少盐允许字典攻击，因为相同的密码总是创建相同的密钥。
低迭代次数和非加密安全散列算法允许非常快速地测试密码。</p>
<p>根据 OpenSSL 建议使用更现代的算法而不是 <a href="http://url.nodejs.cn/d3vRBX"><code>EVP_BytesToKey</code></a>，建议开发人员使用 <a href="crypto.html#crypto_crypto_scrypt_password_salt_keylen_options_callback"><code>crypto.scrypt()</code></a> 自行派生密钥和 IV，并使用 <a href="crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv_options"><code>crypto.createDecipheriv()</code></a> 创建 <code>Decipher</code> 对象。</p>
<h4><code>crypto.createDecipheriv(algorithm, key, iv[, options])</code><span><a class="mark" href="#crypto_crypto_createdecipheriv_algorithm_key_iv_options" id="crypto_crypto_createdecipheriv_algorithm_key_iv_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createdecipheriv_algorithm_key_iv_options">
                <a href="crypto/crypto_createdecipheriv_algorithm_key_iv_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v11.6.0</td>
<td><p>参数 <code>key</code> 现在可以是 <code>KeyObject</code>。</p></td></tr>
<tr><td>v11.2.0, v10.17.0</td>
<td><p>现在支持加密 <code>chacha20-poly1305</code>。</p></td></tr>
<tr><td>v10.10.0</td>
<td><p>现在支持 OCB 模式下的加密。</p></td></tr>
<tr><td>v10.2.0</td>
<td><p>选项 <code>authTagLength</code> 现在可用于限制接受的 GCM 身份验证标签长度。</p></td></tr>
<tr><td>v9.9.0</td>
<td><p>对于不需要初始化向量的加密，<code>iv</code> 参数现在可以为 <code>null</code>。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a></li>
<li><code>iv</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_decipher" rel="nofollow" class="type">&lt;Decipher&gt;</a></li>
</ul>
<p>创建并返回 <code>Decipher</code> 对象，该对象使用给定的 <code>algorithm</code>、<code>key</code> 和初始化向量 (<code>iv</code>)。</p>
<p><code>options</code> 参数控制流的行为，并且是可选的，除非使用 CCM 或 OCB 模式的加密（例如 <code>'aes-128-ccm'</code>）。
在这种情况下，需要 <code>authTagLength</code> 选项并指定身份验证标签的长度（以字节为单位），请参阅 <a href="crypto.html#crypto_ccm_mode">CCM 模式</a>。
在 GCM 模式下，<code>authTagLength</code> 选项不是必需的，但可用于将接受的身份验证标签限制为具有指定长度的标签。</p>
<p><code>algorithm</code> 依赖于 OpenSSL，例如 <code>'aes192'</code> 等。
在 OpenSSL 的最新版本中，<code>openssl list -cipher-algorithms</code>（在 OpenSSL 的旧版本中为 <code>openssl list-cipher-algorithms</code>）将显示可用的加密算法。</p>
<p><code>key</code> 是 <code>algorithm</code> 使用的原始密钥，<code>iv</code> 是<a href="http://url.nodejs.cn/mMnDDL">初始化向量</a>。
两个参数都必须是 <code>'utf8'</code> 编码的字符串、<a href="buffer.html">缓冲区</a>、<code>TypedArray</code> 或 <code>DataView</code>。
<code>key</code> 可以是 <code>secret</code> 类型的 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>。
如果加密不需要初始化向量，则 <code>iv</code> 可以是 <code>null</code>。</p>
<p>为 <code>key</code> 或 <code>iv</code> 传入字符串时，请考虑到<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">当使用字符串作为加密 API 输入时的注意事项</a>。</p>
<p>初始化向量应该是不可预测的和独特的；理想情况下，它们将是加密随机的。
它们不必是机密的：IV 通常不加密就添加到密文消息中。
必须是不可预测的和独特的，但不必是机密的，这听起来可能有些矛盾。请记住，一定不能让攻击者提前预测到给定的 IV。</p>
<h4><code>crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])</code><span><a class="mark" href="#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding" id="crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding">
                <a href="crypto/crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>参数 <code>prime</code> 现在可以是任何 <code>TypedArray</code> 或 <code>DataView</code>。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>参数 <code>prime</code> 现在可以是 <code>Uint8Array</code>。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>编码参数的默认值从 <code>binary</code> 更改为 <code>utf8</code>。</p></td></tr>
<tr><td>v0.11.12</td>
<td><p><span>新增于: v0.11.12</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>prime</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>primeEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>prime</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li><code>generator</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a>
<strong>默认值:</strong> <code>2</code></li>
<li><code>generatorEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>generator</code> 字符串的<a href="buffer.html#buffer_buffers_and_character_encodings">编码</a>。</li>
<li>返回: <a href="crypto.html#crypto_class_diffiehellman" rel="nofollow" class="type">&lt;DiffieHellman&gt;</a></li>
</ul>
<p>使用提供的 <code>prime</code> 和可选的特定 <code>generator</code> 创建 <code>DiffieHellman</code> 密钥交换对象。</p>
<p><code>generator</code> 参数可以是数字、字符串或 <a href="buffer.html"><code>Buffer</code></a>。
如果未指定 <code>generator</code>，则使用值 <code>2</code>。</p>
<p>如果指定了 <code>primeEncoding</code>，则 <code>prime</code> 应该是字符串；否则应为 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<p>如果指定了 <code>generatorEncoding</code>，则 <code>generator</code> 应该是字符串；否则应为数字 <a href="buffer.html"><code>Buffer</code></a>、<code>TypedArray</code> 或 <code>DataView</code>。</p>
<h4><code>crypto.createDiffieHellman(primeLength[, generator])</code><span><a class="mark" href="#crypto_crypto_creatediffiehellman_primelength_generator" id="crypto_crypto_creatediffiehellman_primelength_generator">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_creatediffiehellman_primelength_generator">
                <a href="crypto/crypto_creatediffiehellman_primelength_generator.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.5.0</span>
</div>
<ul>
<li><code>primeLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>generator</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>2</code></li>
<li>返回: <a href="crypto.html#crypto_class_diffiehellman" rel="nofollow" class="type">&lt;DiffieHellman&gt;</a></li>
</ul>
<p>创建 <code>DiffieHellman</code> 密钥交换对象并使用可选的特定数字 <code>generator</code> 生成 <code>primeLength</code> 位的质数。
如果未指定 <code>generator</code>，则使用值 <code>2</code>。</p>
<h4><code>crypto.createDiffieHellmanGroup(name)</code><span><a class="mark" href="#crypto_crypto_creatediffiehellmangroup_name" id="crypto_crypto_creatediffiehellmangroup_name">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_creatediffiehellmangroup_name">
                <a href="crypto/crypto_creatediffiehellmangroup_name.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.3</span>
</div>
<ul>
<li><code>name</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="crypto.html#crypto_class_diffiehellmangroup" rel="nofollow" class="type">&lt;DiffieHellmanGroup&gt;</a></li>
</ul>
<p><a href="crypto.html#crypto_crypto_getdiffiehellman_groupname"><code>crypto.getDiffieHellman()</code></a> 的别名</p>
<h4><code>crypto.createECDH(curveName)</code><span><a class="mark" href="#crypto_crypto_createecdh_curvename" id="crypto_crypto_createecdh_curvename">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createecdh_curvename">
                <a href="crypto/crypto_createecdh_curvename.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul>
<li><code>curveName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="crypto.html#crypto_class_ecdh" rel="nofollow" class="type">&lt;ECDH&gt;</a></li>
</ul>
<p>使用 <code>curveName</code> 字符串指定的预定义曲线创建椭圆曲线 Diffie-Hellman (<code>ECDH</code>) 密钥交换对象。
使用 <a href="crypto.html#crypto_crypto_getcurves"><code>crypto.getCurves()</code></a> 获取可用曲线名称的列表。
在最近的 OpenSSL 版本中，<code>openssl ecparam -list_curves</code> 还将显示每个可用椭圆曲线的名称和描述。</p>
<h4><code>crypto.createHash(algorithm[, options])</code><span><a class="mark" href="#crypto_crypto_createhash_algorithm_options" id="crypto_crypto_createhash_algorithm_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createhash_algorithm_options">
                <a href="crypto/crypto_createhash_algorithm_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.8.0</td>
<td><p>为 XOF 哈希函数添加了 <code>outputLength</code> 选项。</p></td></tr>
<tr><td>v0.1.92</td>
<td><p><span>新增于: v0.1.92</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_hash" rel="nofollow" class="type">&lt;Hash&gt;</a></li>
</ul>
<p>创建并返回 <code>Hash</code> 对象，该对象可用于使用给定的 <code>algorithm</code> 生成哈希摘要。
可选的 <code>options</code> 参数控制流的行为。
对于 XOF 哈希函数（例如 <code>'shake256'</code>），可以使用 <code>outputLength</code> 选项指定所需的输出长度（以字节为单位）。</p>
<p><code>algorithm</code> 取决于平台上 OpenSSL 版本支持的可用算法。
例如 <code>'sha256'</code>、<code>'sha512'</code> 等。
在 OpenSSL 的最新版本中，<code>openssl list -digest-algorithms</code>（在 OpenSSL 的旧版本中为 <code>openssl list-message-digest-algorithms</code>）将显示可用的摘要算法。</p>
<p>示例：生成文件的 sha256 总和</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> {
  createReadStream
} <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> filename = process.argv[<span class="hljs-number">2</span>];

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(filename);
input.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = input.read();
  <span class="hljs-keyword">if</span> (data)
    hash.update(data);
  <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${hash.digest(<span class="hljs-string">'hex'</span>)}</span> <span class="hljs-subst">${filename}</span>`</span>);
  }
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createReadStream,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> {
  createHash,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> filename = process.argv[<span class="hljs-number">2</span>];

<span class="hljs-keyword">const</span> hash = createHash(<span class="hljs-string">'sha256'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(filename);
input.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = input.read();
  <span class="hljs-keyword">if</span> (data)
    hash.update(data);
  <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${hash.digest(<span class="hljs-string">'hex'</span>)}</span> <span class="hljs-subst">${filename}</span>`</span>);
  }
});</code></pre>
<h4><code>crypto.createHmac(algorithm, key[, options])</code><span><a class="mark" href="#crypto_crypto_createhmac_algorithm_key_options" id="crypto_crypto_createhmac_algorithm_key_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createhmac_algorithm_key_options">
                <a href="crypto/crypto_createhmac_algorithm_key_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>密钥也可以是 ArrayBuffer 或 CryptoKey。 添加了编码选项。 密钥不能包含超过 2 ** 32 - 1 个字节。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>参数 <code>key</code> 现在可以是 <code>KeyObject</code>。</p></td></tr>
<tr><td>v0.1.94</td>
<td><p><span>新增于: v0.1.94</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_transform_options"><code>stream.transform</code> 选项</a>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>key</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li>返回: <a href="crypto.html#crypto_class_hmac" rel="nofollow" class="type">&lt;Hmac&gt;</a></li>
</ul>
<p>创建并返回使用给定 <code>algorithm</code> 和 <code>key</code> 的 <code>Hmac</code> 对象。
可选的 <code>options</code> 参数控制流的行为。</p>
<p><code>algorithm</code> 取决于平台上 OpenSSL 版本支持的可用算法。
例如 <code>'sha256'</code>、<code>'sha512'</code> 等。
在 OpenSSL 的最新版本中，<code>openssl list -digest-algorithms</code>（在 OpenSSL 的旧版本中为 <code>openssl list-message-digest-algorithms</code>）将显示可用的摘要算法。</p>
<p><code>key</code> 是用于生成加密 HMAC 哈希的 HMAC 密钥。
如果是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则其类型必须是 <code>secret</code>。</p>
<p>示例：生成文件的 sha256 HMAC</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> {
  createReadStream
} <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> filename = process.argv[<span class="hljs-number">2</span>];

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(filename);
input.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = input.read();
  <span class="hljs-keyword">if</span> (data)
    hmac.update(data);
  <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${hmac.digest(<span class="hljs-string">'hex'</span>)}</span> <span class="hljs-subst">${filename}</span>`</span>);
  }
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createReadStream,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> {
  createHmac,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> filename = process.argv[<span class="hljs-number">2</span>];

<span class="hljs-keyword">const</span> hmac = createHmac(<span class="hljs-string">'sha256'</span>, <span class="hljs-string">'a secret'</span>);

<span class="hljs-keyword">const</span> input = createReadStream(filename);
input.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 哈希流只会生成一个元素。</span>
  <span class="hljs-keyword">const</span> data = input.read();
  <span class="hljs-keyword">if</span> (data)
    hmac.update(data);
  <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${hmac.digest(<span class="hljs-string">'hex'</span>)}</span> <span class="hljs-subst">${filename}</span>`</span>);
  }
});</code></pre>
<h4><code>crypto.createPrivateKey(key)</code><span><a class="mark" href="#crypto_crypto_createprivatekey_key" id="crypto_crypto_createprivatekey_key">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createprivatekey_key">
                <a href="crypto/crypto_createprivatekey_key.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.12.0</td>
<td><p>键也可以是 JWK 对象。</p></td></tr>
<tr><td>v15.0.0</td>
<td><p>键也可以是 ArrayBuffer。 添加了编码选项。 密钥不能包含超过 2 ** 32 - 1 个字节。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p><span>新增于: v11.6.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a>
<ul>
<li><code>key</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 密钥材料，采用 PEM、DER 或 JWK 格式。</li>
<li><code>format</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pem'</code>、<code>'der'</code> 或 '<code>'jwk'</code>。
<strong>默认值:</strong> <code>'pem'</code>。</li>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pkcs1'</code>、<code>'pkcs8'</code> 或 <code>'sec1'</code>。
仅当 <code>format</code> 为 <code>'der'</code> 时才需要此选项，否则将被忽略。</li>
<li><code>passphrase</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 用于解密的密码。</li>
<li><code>encoding</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>key</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li>返回: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
<!--lint enable maximum-line-length remark-lint-->
<p>创建并返回包含私钥的新密钥对象。
如果 <code>key</code> 是字符串或 <code>Buffer</code>，则假定 <code>format</code> 是 <code>'pem'</code>；否则，<code>key</code> 必须是具有上述属性的对象。</p>
<p>如果私钥被加密，则必须指定 <code>passphrase</code>。
密码的长度限制为 1024 字节。</p>
<h4><code>crypto.createPublicKey(key)</code><span><a class="mark" href="#crypto_crypto_createpublickey_key" id="crypto_crypto_createpublickey_key">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createpublickey_key">
                <a href="crypto/crypto_createpublickey_key.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.12.0</td>
<td><p>键也可以是 JWK 对象。</p></td></tr>
<tr><td>v15.0.0</td>
<td><p>键也可以是 ArrayBuffer。 添加了编码选项。 密钥不能包含超过 2 ** 32 - 1 个字节。</p></td></tr>
<tr><td>v11.13.0</td>
<td><p>参数 <code>key</code> 现在可以是类型为 <code>private</code> 的 <code>KeyObject</code>。</p></td></tr>
<tr><td>v11.7.0</td>
<td><p>参数 <code>key</code> 现在可以是私钥。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p><span>新增于: v11.6.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a>
<ul>
<li><code>key</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 密钥材料，采用 PEM、DER 或 JWK 格式。</li>
<li><code>format</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pem'</code>、<code>'der'</code> 或 '<code>'jwk'</code>。
<strong>默认值:</strong> <code>'pem'</code>。</li>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'pkcs1'</code> 或 <code>'spki'</code>。
仅当 <code>format</code> 为 <code>'der'</code> 时才需要此选项，否则将被忽略。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>key</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li>返回: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
<!--lint enable maximum-line-length remark-lint-->
<p>创建并返回包含公钥的新密钥对象。
如果 <code>key</code> 是字符串或 <code>Buffer</code>，则假定 <code>format</code> 是 <code>'pem'</code>； 如果 <code>key</code> 是类型为 <code>'private'</code> 的 <code>KeyObject</code>，则公钥来自给定的私钥； 否则，<code>key</code> 必须是具有上述属性的对象。</p>
<p>如果格式为 <code>'pem'</code>，则 <code>'key'</code> 也可能是 X.509 证书。</p>
<p>因为公钥可以从私钥导出，所以可以传递私钥而不是公钥。
在这种情况下，此函数的行为就像 <a href="crypto.html#crypto_crypto_createprivatekey_key"><code>crypto.createPrivateKey()</code></a> 已被调用，除了返回的 <code>KeyObject</code> 的类型将为 <code>'public'</code> 并且无法从返回的 <code>KeyObject</code> 中提取私钥。
同样，如果给定了类型为 <code>'private'</code> 的 <code>KeyObject</code>，则新的类型为 <code>'public'</code> 的 <code>KeyObject</code> 将被返回，并且无法从返回的对象中提取私钥。</p>
<h4><code>crypto.createSecretKey(key[, encoding])</code><span><a class="mark" href="#crypto_crypto_createsecretkey_key_encoding" id="crypto_crypto_createsecretkey_key_encoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createsecretkey_key_encoding">
                <a href="crypto/crypto_createsecretkey_key_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>键也可以是 ArrayBuffer 或字符串。 添加了编码参数。 密钥不能包含超过 2 ** 32 - 1 个字节。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p><span>新增于: v11.6.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>key</code> 为字符串时的字符串编码。</li>
<li>返回: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
<p>创建并返回新的密钥对象，其中包含用于对称加密或 <code>Hmac</code> 的密钥。</p>
<h4><code>crypto.createSign(algorithm[, options])</code><span><a class="mark" href="#crypto_crypto_createsign_algorithm_options" id="crypto_crypto_createsign_algorithm_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createsign_algorithm_options">
                <a href="crypto/crypto_createsign_algorithm_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_writable_options"><code>stream.Writable</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_sign" rel="nofollow" class="type">&lt;Sign&gt;</a></li>
</ul>
<p>创建并返回使用给定 <code>algorithm</code> 的 <code>Sign</code> 对象。
使用 <a href="crypto.html#crypto_crypto_gethashes"><code>crypto.getHashes()</code></a> 获取可用摘要算法的名称。
可选的 <code>options</code> 参数控制 <code>stream.Writable</code> 行为。</p>
<p>在某些情况下，可以使用签名算法的名称（例如 <code>'RSA-SHA256'</code>）而不是摘要算法来创建 <code>Sign</code> 实例。
这将使用相应的摘要算法。
这不适用于所有签名算法，例如 <code>'ecdsa-with-SHA256'</code>，因此最好始终使用摘要算法名称。</p>
<h4><code>crypto.createVerify(algorithm[, options])</code><span><a class="mark" href="#crypto_crypto_createverify_algorithm_options" id="crypto_crypto_createverify_algorithm_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_createverify_algorithm_options">
                <a href="crypto/crypto_createverify_algorithm_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.92</span>
</div>
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> <a href="stream.html#stream_new_stream_writable_options"><code>stream.Writable</code> 选项</a></li>
<li>返回: <a href="crypto.html#crypto_class_verify" rel="nofollow" class="type">&lt;Verify&gt;</a></li>
</ul>
<p>创建并返回使用给定算法的 <code>Verify</code> 对象。
使用 <a href="crypto.html#crypto_crypto_gethashes"><code>crypto.getHashes()</code></a> 获取可用签名算法的名称数组。
可选的 <code>options</code> 参数控制 <code>stream.Writable</code> 行为。</p>
<p>在某些情况下，可以使用签名算法的名称（例如 <code>'RSA-SHA256'</code>）而不是摘要算法来创建 <code>Verify</code> 实例。
这将使用相应的摘要算法。
这不适用于所有签名算法，例如 <code>'ecdsa-with-SHA256'</code>，因此最好始终使用摘要算法名称。</p>
<h4><code>crypto.diffieHellman(options)</code><span><a class="mark" href="#crypto_crypto_diffiehellman_options" id="crypto_crypto_diffiehellman_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_diffiehellman_options">
                <a href="crypto/crypto_diffiehellman_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.9.0, v12.17.0</span>
</div>
<ul>
<li><code>options</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>privateKey</code>: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
<li><code>publicKey</code>: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>基于 <code>privateKey</code> 和 <code>publicKey</code> 计算 Diffie-Hellman 秘密。
两个密钥必须具有相同的 <code>asymmetricKeyType</code>，它必须是 <code>'dh'</code>（对于 Diffie-Hellman）、<code>'ec'</code>（对于 ECDH）、<code>'x448'</code> 或 <code>'x25519'</code>（对于 ECDH-ES）之一。</p>
<h4><code>crypto.generateKey(type, options, callback)</code><span><a class="mark" href="#crypto_crypto_generatekey_type_options_callback" id="crypto_crypto_generatekey_type_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_generatekey_type_options_callback">
                <a href="crypto/crypto_generatekey_type_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 生成的密钥的预期用途。
当前接受的值为 <code>'hmac'</code> 和 <code>'aes'</code>。</li>
<li><code>options</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>length</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要生成的密钥的位长。
这必须是一个大于 0 的值。
<ul>
<li>如果 <code>type</code> 为 <code>'hmac'</code>，则最小为 1，最大长度为 2<sup>31</sup>-1。</li>
</ul>
如果该值不是 8 的倍数，则生成的密钥将被截断为 <code>Math.floor(length / 8)</code>。
<ul>
<li>如果 <code>type</code> 是 <code>'aes'</code>，则长度必须是 <code>128</code>、<code>192</code> 或 <code>256</code> 之一。</li>
</ul>
</li>
</ul>
</li>
<li><code>callback</code>: <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code>: <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>key</code>: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
</li>
</ul>
<p>异步生成给定 <code>length</code> 的新随机密钥。
<code>type</code> 将确定将在 <code>length</code> 上执行哪些验证。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  generateKey,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

generateKey(<span class="hljs-string">'hmac'</span>, { <span class="hljs-attr">length</span>: <span class="hljs-number">64</span> }, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(key.export().toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// 46e..........620</span>
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  generateKey,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

generateKey(<span class="hljs-string">'hmac'</span>, { <span class="hljs-attr">length</span>: <span class="hljs-number">64</span> }, <span class="hljs-function">(<span class="hljs-params">err, key</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(key.export().toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// 46e..........620</span>
});</code></pre>
<h4><code>crypto.generateKeyPair(type, options, callback)</code><span><a class="mark" href="#crypto_crypto_generatekeypair_type_options_callback" id="crypto_crypto_generatekeypair_type_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_generatekeypair_type_options_callback">
                <a href="crypto/crypto_generatekeypair_type_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.9.0, v12.17.0</td>
<td><p>添加对 Diffie-Hellman 的支持。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>添加生成 X25519 和 X448 密钥对的功能。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>添加生成 Ed25519 和 Ed448 密钥对的功能。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>如果未指定编码，<code>generateKeyPair</code> 和 <code>generateKeyPairSync</code> 函数现在会生成关键对象。</p></td></tr>
<tr><td>v10.12.0</td>
<td><p><span>新增于: v10.12.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'rsa'</code>、<code>'dsa'</code>、<code>'ec'</code>、<code>'ed25519'</code>、<code>'ed448'</code>、<code>'x25519'</code>、<code>'x448'</code> 或 <code>'dh'</code>。</li>
<li><code>options</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>modulusLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 以位为单位的密钥大小（RSA、DSA）。</li>
<li><code>publicExponent</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 公共指数 (RSA)。 <strong>默认值:</strong> <code>0x10001</code>。</li>
<li><code>divisorLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>q</code> 的比特大小 (DSA)。</li>
<li><code>namedCurve</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 要使用的曲线名称 (EC)。</li>
<li><code>prime</code>: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 素数参数 (DH)。</li>
<li><code>primeLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 以比特为单位的质数长度 (DH)。</li>
<li><code>generator</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 自定义生成器 (DH)。 <strong>默认值:</strong> <code>2</code>。</li>
<li><code>groupName</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> Diffie-Hellman 组名 (DH)。
参见 <a href="crypto.html#crypto_crypto_getdiffiehellman_groupname"><code>crypto.getDiffieHellman()</code></a>。</li>
<li><code>publicKeyEncoding</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 参见 <a href="crypto.html#crypto_keyobject_export_options"><code>keyObject.export()</code></a>。</li>
<li><code>privateKeyEncoding</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 参见 <a href="crypto.html#crypto_keyobject_export_options"><code>keyObject.export()</code></a>。</li>
</ul>
</li>
<li><code>callback</code>: <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code>: <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>publicKey</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
<li><code>privateKey</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
</li>
</ul>
<p>生成给定 <code>type</code> 的新非对称密钥对。
目前支持 RSA、DSA、EC、Ed25519、Ed448、X25519、X448 和 DH。</p>
<p>如果指定了 <code>publicKeyEncoding</code> 或 <code>privateKeyEncoding</code>，则此函数的行为就像对其结果调用了 <a href="crypto.html#crypto_keyobject_export_options"><code>keyObject.export()</code></a>。
否则，密钥的相应部分将作为 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a> 返回。</p>
<p>建议将公钥编码为 <code>'spki'</code>，私钥编码为 <code>'pkcs8'</code>，并加密以进行长期存储：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  generateKeyPair,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

generateKeyPair(<span class="hljs-string">'rsa'</span>, {
  <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">4096</span>,
  <span class="hljs-attr">publicKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'spki'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>
  },
  <span class="hljs-attr">privateKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'pkcs8'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>,
    <span class="hljs-attr">cipher</span>: <span class="hljs-string">'aes-256-cbc'</span>,
    <span class="hljs-attr">passphrase</span>: <span class="hljs-string">'top secret'</span>
  }
}, <span class="hljs-function">(<span class="hljs-params">err, publicKey, privateKey</span>) =&gt;</span> {
  <span class="hljs-comment">// 处理错误并使用生成的密钥对。</span>
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  generateKeyPair,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

generateKeyPair(<span class="hljs-string">'rsa'</span>, {
  <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">4096</span>,
  <span class="hljs-attr">publicKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'spki'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>
  },
  <span class="hljs-attr">privateKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'pkcs8'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>,
    <span class="hljs-attr">cipher</span>: <span class="hljs-string">'aes-256-cbc'</span>,
    <span class="hljs-attr">passphrase</span>: <span class="hljs-string">'top secret'</span>
  }
}, <span class="hljs-function">(<span class="hljs-params">err, publicKey, privateKey</span>) =&gt;</span> {
  <span class="hljs-comment">// 处理错误并使用生成的密钥对。</span>
});</code></pre>
<p>完成后，<code>callback</code> 将被调用，<code>err</code> 设置为 <code>undefined</code>，<code>publicKey</code> / <code>privateKey</code> 代表生成的密钥对。</p>
<p>如果此方法作为其 <a href="util.html#util_util_promisify_original"><code>util.promisify()</code></a> 版本被调用，则其将为具有 <code>publicKey</code> 和 <code>privateKey</code> 属性的 <code>Object</code> 返回 <code>Promise</code>。</p>
<h4><code>crypto.generateKeyPairSync(type, options)</code><span><a class="mark" href="#crypto_crypto_generatekeypairsync_type_options" id="crypto_crypto_generatekeypairsync_type_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_generatekeypairsync_type_options">
                <a href="crypto/crypto_generatekeypairsync_type_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v13.9.0, v12.17.0</td>
<td><p>添加对 Diffie-Hellman 的支持。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>添加生成 Ed25519 和 Ed448 密钥对的功能。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>如果未指定编码，<code>generateKeyPair</code> 和 <code>generateKeyPairSync</code> 函数现在会生成关键对象。</p></td></tr>
<tr><td>v10.12.0</td>
<td><p><span>新增于: v10.12.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 必须是 <code>'rsa'</code>、<code>'dsa'</code>、<code>'ec'</code>、<code>'ed25519'</code>、<code>'ed448'</code>、<code>'x25519'</code>、<code>'x448'</code> 或 <code>'dh'</code>。</li>
<li><code>options</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>modulusLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 以位为单位的密钥大小（RSA、DSA）。</li>
<li><code>publicExponent</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 公共指数 (RSA)。 <strong>默认值:</strong> <code>0x10001</code>。</li>
<li><code>divisorLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>q</code> 的比特大小 (DSA)。</li>
<li><code>namedCurve</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 要使用的曲线名称 (EC)。</li>
<li><code>prime</code>: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 素数参数 (DH)。</li>
<li><code>primeLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 以比特为单位的质数长度 (DH)。</li>
<li><code>generator</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 自定义生成器 (DH)。 <strong>默认值:</strong> <code>2</code>。</li>
<li><code>groupName</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> Diffie-Hellman 组名 (DH)。
参见 <a href="crypto.html#crypto_crypto_getdiffiehellman_groupname"><code>crypto.getDiffieHellman()</code></a>。</li>
<li><code>publicKeyEncoding</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 参见 <a href="crypto.html#crypto_keyobject_export_options"><code>keyObject.export()</code></a>。</li>
<li><code>privateKeyEncoding</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 参见 <a href="crypto.html#crypto_keyobject_export_options"><code>keyObject.export()</code></a>。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>publicKey</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
<li><code>privateKey</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
</li>
</ul>
<p>生成给定 <code>type</code> 的新非对称密钥对。
目前支持 RSA、DSA、EC、Ed25519、Ed448、X25519、X448 和 DH。</p>
<p>如果指定了 <code>publicKeyEncoding</code> 或 <code>privateKeyEncoding</code>，则此函数的行为就像对其结果调用了 <a href="crypto.html#crypto_keyobject_export_options"><code>keyObject.export()</code></a>。
否则，密钥的相应部分将作为 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a> 返回。</p>
<p>对公钥进行编码时，建议使用<code>'spki'</code>。
对私钥进行编码时，建议使用强密码的<code>'pkcs8'</code>，并对密码进行保密。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  generateKeyPairSync,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> {
  publicKey,
  privateKey,
} = generateKeyPairSync(<span class="hljs-string">'rsa'</span>, {
  <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">4096</span>,
  <span class="hljs-attr">publicKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'spki'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>
  },
  <span class="hljs-attr">privateKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'pkcs8'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>,
    <span class="hljs-attr">cipher</span>: <span class="hljs-string">'aes-256-cbc'</span>,
    <span class="hljs-attr">passphrase</span>: <span class="hljs-string">'top secret'</span>
  }
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  generateKeyPairSync,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> {
  publicKey,
  privateKey,
} = generateKeyPairSync(<span class="hljs-string">'rsa'</span>, {
  <span class="hljs-attr">modulusLength</span>: <span class="hljs-number">4096</span>,
  <span class="hljs-attr">publicKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'spki'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>
  },
  <span class="hljs-attr">privateKeyEncoding</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-string">'pkcs8'</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">'pem'</span>,
    <span class="hljs-attr">cipher</span>: <span class="hljs-string">'aes-256-cbc'</span>,
    <span class="hljs-attr">passphrase</span>: <span class="hljs-string">'top secret'</span>
  }
});</code></pre>
<p>返回值 <code>{ publicKey, privateKey }</code> 表示生成的密钥对。
选择 PEM 编码时，相应的密钥将是字符串，否则它将是包含编码为 DER 的数据的缓冲区。</p>
<h4><code>crypto.generateKeySync(type, options)</code><span><a class="mark" href="#crypto_crypto_generatekeysync_type_options" id="crypto_crypto_generatekeysync_type_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_generatekeysync_type_options">
                <a href="crypto/crypto_generatekeysync_type_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>type</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 生成的密钥的预期用途。
当前接受的值为 <code>'hmac'</code> 和 <code>'aes'</code>。</li>
<li><code>options</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>length</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要生成的密钥的位长。
<ul>
<li>如果 <code>type</code> 为 <code>'hmac'</code>，则最小为 1，最大长度为 2<sup>31</sup>-1。</li>
</ul>
如果该值不是 8 的倍数，则生成的密钥将被截断为 <code>Math.floor(length / 8)</code>。
<ul>
<li>如果 <code>type</code> 是 <code>'aes'</code>，则长度必须是 <code>128</code>、<code>192</code> 或 <code>256</code> 之一。</li>
</ul>
</li>
</ul>
</li>
<li>返回: <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a></li>
</ul>
<p>同步生成给定 <code>length</code> 的新随机密钥。
<code>type</code> 将确定将在 <code>length</code> 上执行哪些验证。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  generateKeySync,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> key = generateKeySync(<span class="hljs-string">'hmac'</span>, <span class="hljs-number">64</span>);
<span class="hljs-built_in">console</span>.log(key.export().toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// e89..........41e</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  generateKeySync,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> key = generateKeySync(<span class="hljs-string">'hmac'</span>, <span class="hljs-number">64</span>);
<span class="hljs-built_in">console</span>.log(key.export().toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// e89..........41e</span></code></pre>
<h4><code>crypto.generatePrime(size[, options[, callback]])</code><span><a class="mark" href="#crypto_crypto_generateprime_size_options_callback" id="crypto_crypto_generateprime_size_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_generateprime_size_options_callback">
                <a href="crypto/crypto_generateprime_size_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.8.0</span>
</div>
<ul>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要生成的素数的大小（以位为单位）。</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>add</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a></li>
<li><code>rem</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a></li>
<li><code>safe</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
<li><code>bigint</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 当 <code>true</code> 时，生成的素数作为 <code>bigint</code> 返回。</li>
</ul>
</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>prime</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a></li>
</ul>
</li>
</ul>
<p>生成 <code>size</code> 位的伪随机素数。</p>
<p>如果 <code>options.safe</code> 是 <code>true</code>，素数将是一个安全素数——也就是说，<code>(prime - 1) / 2</code> 也将是素数。</p>
<p><code>options.add</code> 和 <code>options.rem</code> 参数可用于强制执行其他要求，例如，对于 Diffie-Hellman：</p>
<ul>
<li>如果 <code>options.add</code> 和 <code>options.rem</code> 都设置，素数将满足条件 <code>prime % add = rem</code>。</li>
<li>如果只设置了 <code>options.add</code> 而 <code>options.safe</code> 不是 <code>true</code>，素数将满足条件 <code>prime % add = 1</code>。</li>
<li>如果只设置了 <code>options.add</code>，而将 <code>options.safe</code> 设置为 <code>true</code>，则素数将满足条件 <code>prime % add = 3</code>。
这是必要的，因为 <code>options.add &gt; 2</code> 的 <code>prime % add = 1</code> 会与 <code>options.safe</code> 强制执行的条件相矛盾。</li>
<li>如果未给出 <code>options.add</code>，则忽略 <code>options.rem</code>。</li>
</ul>
<p>如果以 <code>ArrayBuffer</code>、<code>SharedArrayBuffer</code>、<code>TypedArray</code>、<code>Buffer</code> 或 <code>DataView</code> 形式给出，则 <code>options.add</code> 和 <code>options.rem</code> 都必须编码为大端序列。</p>
<p>默认情况下，素数被编码为 <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> 中八位字节的大端序列。
如果 <code>bigint</code> 选项为 <code>true</code>，则提供 <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a>。</p>
<h4><code>crypto.generatePrimeSync(size[, options])</code><span><a class="mark" href="#crypto_crypto_generateprimesync_size_options" id="crypto_crypto_generateprimesync_size_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_generateprimesync_size_options">
                <a href="crypto/crypto_generateprimesync_size_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.8.0</span>
</div>
<ul>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要生成的素数的大小（以位为单位）。</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>add</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a></li>
<li><code>rem</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a></li>
<li><code>safe</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <strong>默认值:</strong> <code>false</code>。</li>
<li><code>bigint</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 当 <code>true</code> 时，生成的素数作为 <code>bigint</code> 返回。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a></li>
</ul>
<p>生成 <code>size</code> 位的伪随机素数。</p>
<p>如果 <code>options.safe</code> 是 <code>true</code>，素数将是一个安全素数——也就是说，<code>(prime - 1) / 2</code> 也将是素数。</p>
<p><code>options.add</code> 和 <code>options.rem</code> 参数可用于强制执行其他要求，例如，对于 Diffie-Hellman：</p>
<ul>
<li>如果 <code>options.add</code> 和 <code>options.rem</code> 都设置，素数将满足条件 <code>prime % add = rem</code>。</li>
<li>如果只设置了 <code>options.add</code> 而 <code>options.safe</code> 不是 <code>true</code>，素数将满足条件 <code>prime % add = 1</code>。</li>
<li>如果只设置了 <code>options.add</code>，而将 <code>options.safe</code> 设置为 <code>true</code>，则素数将满足条件 <code>prime % add = 3</code>。
这是必要的，因为 <code>options.add &gt; 2</code> 的 <code>prime % add = 1</code> 会与 <code>options.safe</code> 强制执行的条件相矛盾。</li>
<li>如果未给出 <code>options.add</code>，则忽略 <code>options.rem</code>。</li>
</ul>
<p>如果以 <code>ArrayBuffer</code>、<code>SharedArrayBuffer</code>、<code>TypedArray</code>、<code>Buffer</code> 或 <code>DataView</code> 形式给出，则 <code>options.add</code> 和 <code>options.rem</code> 都必须编码为大端序列。</p>
<p>默认情况下，素数被编码为 <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> 中八位字节的大端序列。
如果 <code>bigint</code> 选项为 <code>true</code>，则提供 <a href="http://url.nodejs.cn/gJMq1y" rel="nofollow" class="type">&lt;bigint&gt;</a>。</p>
<h4><code>crypto.getCipherInfo(nameOrNid[, options])</code><span><a class="mark" href="#crypto_crypto_getcipherinfo_nameornid_options" id="crypto_crypto_getcipherinfo_nameornid_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_getcipherinfo_nameornid_options">
                <a href="crypto/crypto_getcipherinfo_nameornid_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>nameOrNid</code>: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要查询的密码的名称或 nid。</li>
<li><code>options</code>: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>keyLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 测试密钥的长度。</li>
<li><code>ivLength</code>: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 测试 IV 的长度。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>name</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 密码的名称</li>
<li><code>nid</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 密码的 nid</li>
<li><code>blockSize</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 密码的块大小（以字节为单位）。
当 <code>mode</code> 为 <code>'stream'</code> 时，此属性被省略。</li>
<li><code>ivLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 以字节为单位的预期或默认初始化向量长度。
如果密码不使用初始化向量，则省略此属性。</li>
<li><code>keyLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 以字节为单位的预期或默认密钥长度。</li>
<li><code>mode</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 密码模式。
<code>'cbc'</code>、<code>'ccm'</code>、<code>'cfb'</code>、<code>'ctr'</code>、<code>'ecb'</code>、<code>'gcm'</code>、<code>'ocb'</code>、<code>'ofb'</code>、<code>'stream'</code>、<code>'wrap'</code>、<code>'xts'</code> 之一。</li>
</ul>
</li>
</ul>
<p>返回有关给定密码的信息。</p>
<p>一些密码接受可变长度的密钥和初始化向量。
默认情况下，<code>crypto.getCipherInfo()</code> 方法将返回这些密码的默认值。
要测试给定的密钥长度或 iv 长度对于给定的密码是否可接受，请使用 <code>keyLength</code> 和 <code>ivLength</code> 选项。
如果给定的值不可接受，则返回 <code>undefined</code>。</p>
<h4><code>crypto.getCiphers()</code><span><a class="mark" href="#crypto_crypto_getciphers" id="crypto_crypto_getciphers">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_getciphers">
                <a href="crypto/crypto_getciphers.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.3</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string[]&gt;</a> 包含支持的密码算法名称的数组。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  getCiphers,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-built_in">console</span>.log(getCiphers()); <span class="hljs-comment">// ['aes-128-cbc', 'aes-128-ccm', ...]</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  getCiphers,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-built_in">console</span>.log(getCiphers()); <span class="hljs-comment">// ['aes-128-cbc', 'aes-128-ccm', ...]</span></code></pre>
<h4><code>crypto.getCurves()</code><span><a class="mark" href="#crypto_crypto_getcurves" id="crypto_crypto_getcurves">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_getcurves">
                <a href="crypto/crypto_getcurves.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v2.3.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string[]&gt;</a> 包含支持的椭圆曲线名称的数组。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  getCurves,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-built_in">console</span>.log(getCurves()); <span class="hljs-comment">// ['Oakley-EC2N-3', 'Oakley-EC2N-4', ...]</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  getCurves,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-built_in">console</span>.log(getCurves()); <span class="hljs-comment">// ['Oakley-EC2N-3', 'Oakley-EC2N-4', ...]</span></code></pre>
<h4><code>crypto.getDiffieHellman(groupName)</code><span><a class="mark" href="#crypto_crypto_getdiffiehellman_groupname" id="crypto_crypto_getdiffiehellman_groupname">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_getdiffiehellman_groupname">
                <a href="crypto/crypto_getdiffiehellman_groupname.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.7.5</span>
</div>
<ul>
<li><code>groupName</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="crypto.html#crypto_class_diffiehellmangroup" rel="nofollow" class="type">&lt;DiffieHellmanGroup&gt;</a></li>
</ul>
<p>创建预定义的 <code>DiffieHellmanGroup</code> 密钥交换对象。
支持的组是：<code>'modp1'</code>、<code>'modp2'</code>、<code>'modp5'</code>（在 <a href="http://url.nodejs.cn/6ouCbA">RFC 2412</a> 中定义，但请参阅<a href="crypto.html#crypto_support_for_weak_or_compromised_algorithms">注意事项</a>）和 <code>'modp14'</code>、<code>'modp15'</code>、<code>'modp16'</code>、<code>'modp17'</code>、<code>'modp18'</code>（在 <a href="http://url.nodejs.cn/m8pGEe">RFC 3526</a> 中定义）。
返回的对象模仿 <a href="crypto.html#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding"><code>crypto.createDiffieHellman()</code></a> 创建的对象的接口，但不允许更改键（例如，使用 <a href="crypto.html#crypto_diffiehellman_setpublickey_publickey_encoding"><code>diffieHellman.setPublicKey()</code></a>）。
使用这种方法的优点是双方不必事先生成或交换组模数，既节省了处理器时间又节省了通信时间。</p>
<p>示例（获取共享密钥）：</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  getDiffieHellman,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> alice = getDiffieHellman(<span class="hljs-string">'modp14'</span>);
<span class="hljs-keyword">const</span> bob = getDiffieHellman(<span class="hljs-string">'modp14'</span>);

alice.generateKeys();
bob.generateKeys();

<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bob.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(alice.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);

<span class="hljs-comment">/* aliceSecret 和 bobSecret 应该是一样的 */</span>
<span class="hljs-built_in">console</span>.log(aliceSecret === bobSecret);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  getDiffieHellman,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> alice = getDiffieHellman(<span class="hljs-string">'modp14'</span>);
<span class="hljs-keyword">const</span> bob = getDiffieHellman(<span class="hljs-string">'modp14'</span>);

alice.generateKeys();
bob.generateKeys();

<span class="hljs-keyword">const</span> aliceSecret = alice.computeSecret(bob.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> bobSecret = bob.computeSecret(alice.getPublicKey(), <span class="hljs-literal">null</span>, <span class="hljs-string">'hex'</span>);

<span class="hljs-comment">/* aliceSecret 和 bobSecret 应该是一样的 */</span>
<span class="hljs-built_in">console</span>.log(aliceSecret === bobSecret);</code></pre>
<h4><code>crypto.getFips()</code><span><a class="mark" href="#crypto_crypto_getfips" id="crypto_crypto_getfips">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_getfips">
                <a href="crypto/crypto_getfips.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.0.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 当且仅当当前使用符合 FIPS 的加密提供程序时为 <code>1</code>，否则为 <code>0</code>。
未来的语义化主版本可能会将此 API 的返回类型更改为 <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a>。</li>
</ul>
<h4><code>crypto.getHashes()</code><span><a class="mark" href="#crypto_crypto_gethashes" id="crypto_crypto_gethashes">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_gethashes">
                <a href="crypto/crypto_gethashes.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.3</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string[]&gt;</a> 支持的哈希算法名称的数组，例如 <code>'RSA-SHA256'</code>。
哈希算法也称为"摘要"算法。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  getHashes,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-built_in">console</span>.log(getHashes()); <span class="hljs-comment">// ['DSA', 'DSA-SHA', 'DSA-SHA1', ...]</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  getHashes,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-built_in">console</span>.log(getHashes()); <span class="hljs-comment">// ['DSA', 'DSA-SHA', 'DSA-SHA1', ...]</span></code></pre>
<h4><code>crypto.hkdf(digest, key, salt, info, keylen, callback)</code><span><a class="mark" href="#crypto_crypto_hkdf_digest_key_salt_info_keylen_callback" id="crypto_crypto_hkdf_digest_key_salt_info_keylen_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_hkdf_digest_key_salt_info_keylen_callback">
                <a href="crypto/crypto_hkdf_digest_key_salt_info_keylen_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>digest</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 要使用的摘要算法。</li>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> 秘钥。
它的长度必须至少为 1 个字节。</li>
<li><code>salt</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 盐值。
必须提供，但可以是零长度。</li>
<li><code>info</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 附加信息值。
必须提供但可以是零长度，并且不能超过 1024 字节。</li>
<li><code>keylen</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要生成的密钥的长度。
必须大于 0。
最大允许值是所选摘要函数生成的字节数的 <code>255</code> 倍（例如，<code>sha512</code> 生成 64 字节哈希，使最大 HKDF 输出为 16320 字节）。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>derivedKey</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
</ul>
<p>HKDF 是 RFC 5869 中定义的简单密钥派生函数。
给定的 <code>key</code>、<code>salt</code> 和 <code>info</code> 与 <code>digest</code> 一起使用以导出 <code>keylen</code> 字节的密钥。</p>
<p>提供的 <code>callback</code> 函数使用两个参数调用：<code>err</code> 和 <code>derivedKey</code>。
如果在派生密钥时发生错误，则将设置 <code>err</code>；否则 <code>err</code> 将是 <code>null</code>。
成功生成的 <code>derivedKey</code> 将作为 <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> 传给回调。
如果任何输入参数指定了无效的值或类型，则会抛出错误。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  hkdf,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

hkdf(<span class="hljs-string">'sha512'</span>, <span class="hljs-string">'key'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-string">'info'</span>, <span class="hljs-number">64</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(derivedKey).toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '24156e2...5391653'</span>
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  hkdf,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

hkdf(<span class="hljs-string">'sha512'</span>, <span class="hljs-string">'key'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-string">'info'</span>, <span class="hljs-number">64</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(derivedKey).toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '24156e2...5391653'</span>
});</code></pre>
<h4><code>crypto.hkdfSync(digest, key, salt, info, keylen)</code><span><a class="mark" href="#crypto_crypto_hkdfsync_digest_key_salt_info_keylen" id="crypto_crypto_hkdfsync_digest_key_salt_info_keylen">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_hkdfsync_digest_key_salt_info_keylen">
                <a href="crypto/crypto_hkdfsync_digest_key_salt_info_keylen.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>digest</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 要使用的摘要算法。</li>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> 秘钥。
它的长度必须至少为 1 个字节。</li>
<li><code>salt</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 盐值。
必须提供，但可以是零长度。</li>
<li><code>info</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 附加信息值。
必须提供但可以是零长度，并且不能超过 1024 字节。</li>
<li><code>keylen</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要生成的密钥的长度。
必须大于 0。
最大允许值是所选摘要函数生成的字节数的 <code>255</code> 倍（例如，<code>sha512</code> 生成 64 字节哈希，使最大 HKDF 输出为 16320 字节）。</li>
<li>返回: <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a></li>
</ul>
<p>提供 RFC 5869 中定义的同步 HKDF 密钥派生函数。
给定的 <code>key</code>、<code>salt</code> 和 <code>info</code> 与 <code>digest</code> 一起使用以导出 <code>keylen</code> 字节的密钥。</p>
<p>成功生成的 <code>derivedKey</code> 将作为 <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> 返回。</p>
<p>如果任何输入参数指定无效值或类型，或者无法生成派生密钥，则会抛出错误。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  hkdfSync,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> derivedKey = hkdfSync(<span class="hljs-string">'sha512'</span>, <span class="hljs-string">'key'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-string">'info'</span>, <span class="hljs-number">64</span>);
<span class="hljs-built_in">console</span>.log(Buffer.from(derivedKey).toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '24156e2...5391653'</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  hkdfSync,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> derivedKey = hkdfSync(<span class="hljs-string">'sha512'</span>, <span class="hljs-string">'key'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-string">'info'</span>, <span class="hljs-number">64</span>);
<span class="hljs-built_in">console</span>.log(Buffer.from(derivedKey).toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '24156e2...5391653'</span></code></pre>
<h4><code>crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)</code><span><a class="mark" href="#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback" id="crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_pbkdf2_password_salt_iterations_keylen_digest_callback">
                <a href="crypto/crypto_pbkdf2_password_salt_iterations_keylen_digest_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>密码和盐参数也可以是 ArrayBuffer 实例。</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>参数 <code>iterations</code> 现在限制为正值。 早期版本将其他值视为一。</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>现在总是需要 <code>digest</code> 参数。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>现在不推荐在不传入 <code>digest</code> 参数的情况下调用此函数，并将触发警告。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><code>password</code> 的默认编码，如果它是从 <code>binary</code> 更改为 <code>utf8</code> 的字符串。</p></td></tr>
<tr><td>v0.5.5</td>
<td><p><span>新增于: v0.5.5</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>password</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>salt</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>iterations</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>keylen</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>digest</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>derivedKey</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
</ul>
<p>提供异步基于密码的密钥派生函数 2 (PBKDF2) 实现。
应用由 <code>digest</code> 指定的选定 HMAC 摘要算法以从 <code>password</code>、<code>salt</code> 和 <code>iterations</code> 导出请求字节长度 (<code>keylen</code>) 的密钥。</p>
<p>提供的 <code>callback</code> 函数使用两个参数调用：<code>err</code> 和 <code>derivedKey</code>。
如果在派生密钥时发生错误，则设置 <code>err</code>；否则 <code>err</code> 将是 <code>null</code>。
默认情况下，成功生成的 <code>derivedKey</code> 将作为 <a href="buffer.html"><code>Buffer</code></a> 传给回调。
如果任何输入参数指定了无效的值或类型，则会抛出错误。</p>
<p>如果 <code>digest</code> 是 <code>null</code>，则将使用 <code>'sha1'</code>。
此行为已弃用，请显式指定 <code>digest</code>。</p>
<p><code>iterations</code> 参数必须是尽可能高的数字。
迭代次数越多，派生密钥就越安全，但需要更长的时间才能完成。</p>
<p><code>salt</code> 应该尽可能唯一。
建议盐是随机的，长度至少为 16 字节。
有关详细信息，请参阅 <a href="http://url.nodejs.cn/DbTtwt">NIST SP 800-132</a>。</p>
<p>为 <code>password</code> 或 <code>salt</code> 传入字符串时，请考虑到<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">当使用字符串作为加密 API 输入时的注意事项</a>。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  pbkdf2,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

pbkdf2(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">64</span>, <span class="hljs-string">'sha512'</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span>
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  pbkdf2,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

pbkdf2(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">64</span>, <span class="hljs-string">'sha512'</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span>
});</code></pre>
<p><code>crypto.DEFAULT_ENCODING</code> 属性可用于更改 <code>derivedKey</code> 传给回调的方式。
但是，此属性已被弃用，应避免使用。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
crypto.DEFAULT_ENCODING = <span class="hljs-string">'hex'</span>;
crypto.pbkdf2(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">512</span>, <span class="hljs-string">'sha512'</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey);  <span class="hljs-comment">// '3745e48...aa39b34'</span>
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
crypto.DEFAULT_ENCODING = <span class="hljs-string">'hex'</span>;
crypto.pbkdf2(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">512</span>, <span class="hljs-string">'sha512'</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey);  <span class="hljs-comment">// '3745e48...aa39b34'</span>
});</code></pre>
<p>可以使用 <a href="crypto.html#crypto_crypto_gethashes"><code>crypto.getHashes()</code></a> 检索支持的摘要函数数组。</p>
<p>此 API 使用 libuv 的线程池，这对某些应用程序可能会产生意外的负面性能影响；有关更多信息，请参阅 <a href="cli.html#cli_uv_threadpool_size_size"><code>UV_THREADPOOL_SIZE</code></a> 文档。</p>
<h4><code>crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)</code><span><a class="mark" href="#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest" id="crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_pbkdf2sync_password_salt_iterations_keylen_digest">
                <a href="crypto/crypto_pbkdf2sync_password_salt_iterations_keylen_digest.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>参数 <code>iterations</code> 现在限制为正值。 早期版本将其他值视为一。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>现在不推荐在不传入 <code>digest</code> 参数的情况下调用此函数，并将触发警告。</p></td></tr>
<tr><td>v6.0.0</td>
<td><p><code>password</code> 的默认编码，如果它是从 <code>binary</code> 更改为 <code>utf8</code> 的字符串。</p></td></tr>
<tr><td>v0.9.3</td>
<td><p><span>新增于: v0.9.3</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>password</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>salt</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>iterations</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>keylen</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>digest</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>提供同步的基于密码的密钥派生函数 2 (PBKDF2) 实现。
应用由 <code>digest</code> 指定的选定 HMAC 摘要算法以从 <code>password</code>、<code>salt</code> 和 <code>iterations</code> 导出请求字节长度 (<code>keylen</code>) 的密钥。</p>
<p>如果发生错误，将抛出 <code>Error</code>，否则派生密钥将作为 <a href="buffer.html"><code>Buffer</code></a> 返回。</p>
<p>如果 <code>digest</code> 是 <code>null</code>，则将使用 <code>'sha1'</code>。
此行为已弃用，请显式指定 <code>digest</code>。</p>
<p><code>iterations</code> 参数必须是尽可能高的数字。
迭代次数越多，派生密钥就越安全，但需要更长的时间才能完成。</p>
<p><code>salt</code> 应该尽可能唯一。
建议盐是随机的，长度至少为 16 字节。
有关详细信息，请参阅 <a href="http://url.nodejs.cn/DbTtwt">NIST SP 800-132</a>。</p>
<p>为 <code>password</code> 或 <code>salt</code> 传入字符串时，请考虑到<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">当使用字符串作为加密 API 输入时的注意事项</a>。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  pbkdf2Sync,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> key = pbkdf2Sync(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">64</span>, <span class="hljs-string">'sha512'</span>);
<span class="hljs-built_in">console</span>.log(key.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  pbkdf2Sync,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> key = pbkdf2Sync(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">64</span>, <span class="hljs-string">'sha512'</span>);
<span class="hljs-built_in">console</span>.log(key.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span></code></pre>
<p><code>crypto.DEFAULT_ENCODING</code> 属性可用于更改返回 <code>derivedKey</code> 的方式。
但是，此属性已被弃用，应避免使用。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
crypto.DEFAULT_ENCODING = <span class="hljs-string">'hex'</span>;
<span class="hljs-keyword">const</span> key = crypto.pbkdf2Sync(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">512</span>, <span class="hljs-string">'sha512'</span>);
<span class="hljs-built_in">console</span>.log(key);  <span class="hljs-comment">// '3745e48...aa39b34'</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
crypto.DEFAULT_ENCODING = <span class="hljs-string">'hex'</span>;
<span class="hljs-keyword">const</span> key = crypto.pbkdf2Sync(<span class="hljs-string">'secret'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">512</span>, <span class="hljs-string">'sha512'</span>);
<span class="hljs-built_in">console</span>.log(key);  <span class="hljs-comment">// '3745e48...aa39b34'</span></code></pre>
<p>可以使用 <a href="crypto.html#crypto_crypto_gethashes"><code>crypto.getHashes()</code></a> 检索支持的摘要函数数组。</p>
<h4><code>crypto.privateDecrypt(privateKey, buffer)</code><span><a class="mark" href="#crypto_crypto_privatedecrypt_privatekey_buffer" id="crypto_crypto_privatedecrypt_privatekey_buffer">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_privatedecrypt_privatekey_buffer">
                <a href="crypto/crypto_privatedecrypt_privatekey_buffer.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>添加了字符串、ArrayBuffer 和 CryptoKey 作为允许的密钥类型。 oaepLabel 可以是 ArrayBuffer。 缓冲区可以是字符串或 ArrayBuffer。 所有接受缓冲区的类型都被限制为最多 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v12.11.0</td>
<td><p>添加了 <code>oaepLabel</code> 选项。</p></td></tr>
<tr><td>v12.9.0</td>
<td><p>添加了 <code>oaepHash</code> 选项。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>此函数现在支持密钥对象。</p></td></tr>
<tr><td>v0.11.14</td>
<td><p><span>新增于: v0.11.14</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>privateKey</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
<ul>
<li><code>oaepHash</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 用于 OAEP 填充和 MGF1 的哈希函数。
<strong>默认值:</strong> <code>'sha1'</code></li>
<li><code>oaepLabel</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 用于 OAEP 填充的标签。
如果未指定，则不使用标签。</li>
<li><code>padding</code> <a href="crypto.html#crypto_crypto_constants_1" rel="nofollow" class="type">&lt;crypto.constants&gt;</a> <code>crypto.constants</code> 中定义的可选填充值，可以是：<code>crypto.constants.RSA_NO_PADDING</code>、<code>crypto.constants.RSA_PKCS1_PADDING</code> 或 <code>crypto.constants.RSA_PKCS1_OAEP_PADDING</code>。</li>
</ul>
</li>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 带有解密内容的新 <code>Buffer</code>。
  <!--lint enable maximum-line-length remark-lint-->
</li>
</ul>
<p>用 <code>privateKey</code> 解密 <code>buffer</code>。
<code>buffer</code> 之前使用相应的公钥加密，例如使用 <a href="crypto.html#crypto_crypto_publicencrypt_key_buffer"><code>crypto.publicEncrypt()</code></a>。</p>
<p>如果 <code>privateKey</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>privateKey</code> 传给 <a href="crypto.html#crypto_crypto_createprivatekey_key"><code>crypto.createPrivateKey()</code></a> 一样。
如果是对象，则可以传入 <code>padding</code> 属性。
否则，该函数使用 <code>RSA_PKCS1_OAEP_PADDING</code>。</p>
<h4><code>crypto.privateEncrypt(privateKey, buffer)</code><span><a class="mark" href="#crypto_crypto_privateencrypt_privatekey_buffer" id="crypto_crypto_privateencrypt_privatekey_buffer">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_privateencrypt_privatekey_buffer">
                <a href="crypto/crypto_privateencrypt_privatekey_buffer.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>添加了字符串、ArrayBuffer 和 CryptoKey 作为允许的密钥类型。 密码可以是 ArrayBuffer。 缓冲区可以是字符串或 ArrayBuffer。 所有接受缓冲区的类型都被限制为最多 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>此函数现在支持密钥对象。</p></td></tr>
<tr><td>v1.1.0</td>
<td><p><span>新增于: v1.1.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>privateKey</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
PEM 编码的私钥。</li>
<li><code>passphrase</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 可选的私钥密码。</li>
<li><code>padding</code> <a href="crypto.html#crypto_crypto_constants_1" rel="nofollow" class="type">&lt;crypto.constants&gt;</a> <code>crypto.constants</code> 中定义的可选填充值，可以是：<code>crypto.constants.RSA_NO_PADDING</code> 或 <code>crypto.constants.RSA_PKCS1_PADDING</code>。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>buffer</code>、<code>key</code> 或 <code>passphrase</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 带有加密内容的新 <code>Buffer</code>。
  <!--lint enable maximum-line-length remark-lint-->
</li>
</ul>
<p>用 <code>privateKey</code> 加密 <code>buffer</code>。
返回的数据可以使用相应的公钥解密，例如使用 <a href="crypto.html#crypto_crypto_publicdecrypt_key_buffer"><code>crypto.publicDecrypt()</code></a>。</p>
<p>如果 <code>privateKey</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>privateKey</code> 传给 <a href="crypto.html#crypto_crypto_createprivatekey_key"><code>crypto.createPrivateKey()</code></a> 一样。
如果是对象，则可以传入 <code>padding</code> 属性。
否则，该函数使用 <code>RSA_PKCS1_PADDING</code>。</p>
<h4><code>crypto.publicDecrypt(key, buffer)</code><span><a class="mark" href="#crypto_crypto_publicdecrypt_key_buffer" id="crypto_crypto_publicdecrypt_key_buffer">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_publicdecrypt_key_buffer">
                <a href="crypto/crypto_publicdecrypt_key_buffer.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>添加了字符串、ArrayBuffer 和 CryptoKey 作为允许的密钥类型。 密码可以是 ArrayBuffer。 缓冲区可以是字符串或 ArrayBuffer。 所有接受缓冲区的类型都被限制为最多 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>此函数现在支持密钥对象。</p></td></tr>
<tr><td>v1.1.0</td>
<td><p><span>新增于: v1.1.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
<ul>
<li><code>passphrase</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 可选的私钥密码。</li>
<li><code>padding</code> <a href="crypto.html#crypto_crypto_constants_1" rel="nofollow" class="type">&lt;crypto.constants&gt;</a> <code>crypto.constants</code> 中定义的可选填充值，可以是：<code>crypto.constants.RSA_NO_PADDING</code> 或 <code>crypto.constants.RSA_PKCS1_PADDING</code>。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>buffer</code>、<code>key</code> 或 <code>passphrase</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 带有解密内容的新 <code>Buffer</code>。
  <!--lint enable maximum-line-length remark-lint-->
</li>
</ul>
<p>使用 <code>key</code>.<code>buffer</code> 解密 <code>buffer</code> 之前使用相应的私钥加密，例如使用 <a href="crypto.html#crypto_crypto_privateencrypt_privatekey_buffer"><code>crypto.privateEncrypt()</code></a>。</p>
<p>如果 <code>key</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>key</code> 传给 <a href="crypto.html#crypto_crypto_createpublickey_key"><code>crypto.createPublicKey()</code></a> 一样。
如果是对象，则可以传入 <code>padding</code> 属性。
否则，该函数使用 <code>RSA_PKCS1_PADDING</code>。</p>
<p>由于 RSA 公钥可以从私钥派生，因此可以传入私钥而不是公钥。</p>
<h4><code>crypto.publicEncrypt(key, buffer)</code><span><a class="mark" href="#crypto_crypto_publicencrypt_key_buffer" id="crypto_crypto_publicencrypt_key_buffer">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_publicencrypt_key_buffer">
                <a href="crypto/crypto_publicencrypt_key_buffer.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>添加了字符串、ArrayBuffer 和 CryptoKey 作为允许的密钥类型。 oaepLabel 和密码可以是 ArrayBuffers。 缓冲区可以是字符串或 ArrayBuffer。 所有接受缓冲区的类型都被限制为最多 2 ** 31 - 1 个字节。</p></td></tr>
<tr><td>v12.11.0</td>
<td><p>添加了 <code>oaepLabel</code> 选项。</p></td></tr>
<tr><td>v12.9.0</td>
<td><p>添加了 <code>oaepHash</code> 选项。</p></td></tr>
<tr><td>v11.6.0</td>
<td><p>此函数现在支持密钥对象。</p></td></tr>
<tr><td>v0.11.14</td>
<td><p><span>新增于: v0.11.14</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>
PEM 编码的公钥或私钥、<a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> 或 <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>。</li>
<li><code>oaepHash</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 用于 OAEP 填充和 MGF1 的哈希函数。
<strong>默认值:</strong> <code>'sha1'</code></li>
<li><code>oaepLabel</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 用于 OAEP 填充的标签。
如果未指定，则不使用标签。</li>
<li><code>passphrase</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 可选的私钥密码。</li>
<li><code>padding</code> <a href="crypto.html#crypto_crypto_constants_1" rel="nofollow" class="type">&lt;crypto.constants&gt;</a> <code>crypto.constants</code> 中定义的可选填充值，可以是：<code>crypto.constants.RSA_NO_PADDING</code>、<code>crypto.constants.RSA_PKCS1_PADDING</code> 或 <code>crypto.constants.RSA_PKCS1_OAEP_PADDING</code>。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <code>buffer</code>、<code>key</code>、<code>oaepLabel</code> 或 <code>passphrase</code> 是字符串时使用的字符串编码。</li>
</ul>
</li>
<li><code>buffer</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 带有加密内容的新 <code>Buffer</code>。
  <!--lint enable maximum-line-length remark-lint-->
</li>
</ul>
<p>用 <code>key</code> 加密 <code>buffer</code> 的内容，并返回带有加密内容的新 <a href="buffer.html"><code>Buffer</code></a>。
返回的数据可以使用相应的私钥解密，例如使用 <a href="crypto.html#crypto_crypto_privatedecrypt_privatekey_buffer"><code>crypto.privateDecrypt()</code></a>。</p>
<p>如果 <code>key</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>key</code> 传给 <a href="crypto.html#crypto_crypto_createpublickey_key"><code>crypto.createPublicKey()</code></a> 一样。
如果是对象，则可以传入 <code>padding</code> 属性。
否则，该函数使用 <code>RSA_PKCS1_OAEP_PADDING</code>。</p>
<p>由于 RSA 公钥可以从私钥派生，因此可以传入私钥而不是公钥。</p>
<h4><code>crypto.randomBytes(size[, callback])</code><span><a class="mark" href="#crypto_crypto_randombytes_size_callback" id="crypto_crypto_randombytes_size_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_randombytes_size_callback">
                <a href="crypto/crypto_randombytes_size_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v9.0.0</td>
<td><p>将 <code>null</code> 作为 <code>callback</code> 参数传入现在会抛出 <code>ERR_INVALID_CALLBACK</code>。</p></td></tr>
<tr><td>v0.5.8</td>
<td><p><span>新增于: v0.5.8</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要生成的字节数。
<code>size</code> 不得大于 <code>2**31 - 1</code>。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>buf</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 如果未提供 <code>callback</code> 函数。</li>
</ul>
<p>生成加密强伪随机数据。
<code>size</code> 参数是数字，指示要生成的字节数。</p>
<p>如果提供了 <code>callback</code> 函数，则异步生成字节，并使用两个参数调用 <code>callback</code> 函数：<code>err</code> 和 <code>buf</code>。
如果发生错误，则 <code>err</code> 将是 <code>Error</code> 对象；否则就是 <code>null</code>。
<code>buf</code> 参数是包含生成字节的 <a href="buffer.html"><code>Buffer</code></a>。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-comment">// 异步的</span>
<span class="hljs-keyword">const</span> {
  randomBytes,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

randomBytes(<span class="hljs-number">256</span>, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${buf.length}</span> bytes of random data: <span class="hljs-subst">${buf.toString(<span class="hljs-string">'hex'</span>)}</span>`</span>);
});</code><code class="language-js cjs"><span class="hljs-comment">// 异步的</span>
<span class="hljs-keyword">const</span> {
  randomBytes,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

randomBytes(<span class="hljs-number">256</span>, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${buf.length}</span> bytes of random data: <span class="hljs-subst">${buf.toString(<span class="hljs-string">'hex'</span>)}</span>`</span>);
});</code></pre>
<p>如果未提供 <code>callback</code> 函数，则同步生成随机字节并作为 <a href="buffer.html"><code>Buffer</code></a> 返回。
如果生成字节出现问题，则会抛出错误。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-comment">// 同步的</span>
<span class="hljs-keyword">const</span> {
  randomBytes,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> buf = randomBytes(<span class="hljs-number">256</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">`<span class="hljs-subst">${buf.length}</span> bytes of random data: <span class="hljs-subst">${buf.toString(<span class="hljs-string">'hex'</span>)}</span>`</span>);</code><code class="language-js cjs"><span class="hljs-comment">// 同步的</span>
<span class="hljs-keyword">const</span> {
  randomBytes,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> buf = randomBytes(<span class="hljs-number">256</span>);
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">`<span class="hljs-subst">${buf.length}</span> bytes of random data: <span class="hljs-subst">${buf.toString(<span class="hljs-string">'hex'</span>)}</span>`</span>);</code></pre>
<p><code>crypto.randomBytes()</code> 方法将不会完成，直到有足够的可用熵。
这通常不会超过几毫秒。
可以想象，生成随机字节的唯一时间可能会阻塞更长的时间是在启动之后，此时整个系统的熵仍然很低。</p>
<p>此 API 使用 libuv 的线程池，这对某些应用程序可能会产生意外的负面性能影响；有关更多信息，请参阅 <a href="cli.html#cli_uv_threadpool_size_size"><code>UV_THREADPOOL_SIZE</code></a> 文档。</p>
<p><code>crypto.randomBytes()</code> 的异步版本是在单个线程池请求中执行的。
为了最大限度地减少线程池任务长度变化，在执行客户端请求时将大型 <code>randomBytes</code> 请求分区。</p>
<h4><code>crypto.randomFillSync(buffer[, offset][, size])</code><span><a class="mark" href="#crypto_crypto_randomfillsync_buffer_offset_size" id="crypto_crypto_randomfillsync_buffer_offset_size">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_randomfillsync_buffer_offset_size">
                <a href="crypto/crypto_randomfillsync_buffer_offset_size.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v9.0.0</td>
<td><p>参数 <code>buffer</code> 可以是任何 <code>TypedArray</code> 或 <code>DataView</code>。</p></td></tr>
<tr><td>v7.10.0, v6.13.0</td>
<td><p><span>新增于: v7.10.0, v6.13.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>buffer</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 必须提供。
所提供的 <code>buffer</code> 的尺寸不得大于 <code>2**31 - 1</code>。</li>
<li><code>offset</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>0</code></li>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>buffer.length - offset</code>。 <code>size</code> 不得大于 <code>2**31 - 1</code>。</li>
<li>返回: <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 对象作为 <code>buffer</code> 参数传入。</li>
</ul>
<p><a href="crypto.html#crypto_crypto_randomfill_buffer_offset_size_callback"><code>crypto.randomFill()</code></a> 的同步版本。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  randomFillSync,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(randomFillSync(buf).toString(<span class="hljs-string">'hex'</span>));

randomFillSync(buf, <span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));

<span class="hljs-comment">// 以上等价于以下内容：</span>
randomFillSync(buf, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  randomFillSync,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(randomFillSync(buf).toString(<span class="hljs-string">'hex'</span>));

randomFillSync(buf, <span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));

<span class="hljs-comment">// 以上等价于以下内容：</span>
randomFillSync(buf, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));</code></pre>
<p>任何 <code>ArrayBuffer</code>、<code>TypedArray</code> 或 <code>DataView</code> 实例都可以作为 <code>buffer</code> 传入。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  randomFillSync,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(Buffer.from(randomFillSync(a).buffer,
                        a.byteOffset, a.byteLength).toString(<span class="hljs-string">'hex'</span>));

<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>));
<span class="hljs-built_in">console</span>.log(Buffer.from(randomFillSync(b).buffer,
                        b.byteOffset, b.byteLength).toString(<span class="hljs-string">'hex'</span>));

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(Buffer.from(randomFillSync(c)).toString(<span class="hljs-string">'hex'</span>));</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  randomFillSync,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(Buffer.from(randomFillSync(a).buffer,
                        a.byteOffset, a.byteLength).toString(<span class="hljs-string">'hex'</span>));

<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>));
<span class="hljs-built_in">console</span>.log(Buffer.from(randomFillSync(b).buffer,
                        b.byteOffset, b.byteLength).toString(<span class="hljs-string">'hex'</span>));

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>);
<span class="hljs-built_in">console</span>.log(Buffer.from(randomFillSync(c)).toString(<span class="hljs-string">'hex'</span>));</code></pre>
<h4><code>crypto.randomFill(buffer[, offset][, size], callback)</code><span><a class="mark" href="#crypto_crypto_randomfill_buffer_offset_size_callback" id="crypto_crypto_randomfill_buffer_offset_size_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_randomfill_buffer_offset_size_callback">
                <a href="crypto/crypto_randomfill_buffer_offset_size_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v9.0.0</td>
<td><p>参数 <code>buffer</code> 可以是任何 <code>TypedArray</code> 或 <code>DataView</code>。</p></td></tr>
<tr><td>v7.10.0, v6.13.0</td>
<td><p><span>新增于: v7.10.0, v6.13.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>buffer</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> 必须提供。
所提供的 <code>buffer</code> 的尺寸不得大于 <code>2**31 - 1</code>。</li>
<li><code>offset</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>0</code></li>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <strong>默认值:</strong> <code>buffer.length - offset</code>。 <code>size</code> 不得大于 <code>2**31 - 1</code>。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> <code>function(err, buf) {}</code>.</li>
</ul>
<p>此函数类似于 <a href="crypto.html#crypto_crypto_randombytes_size_callback"><code>crypto.randomBytes()</code></a>，但要求第一个参数是将被填充的 <a href="buffer.html"><code>Buffer</code></a>。
它还要求传入回调。</p>
<p>如果未提供 <code>callback</code> 函数，则会抛出错误。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  randomFill,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">10</span>);
randomFill(buf, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));
});

randomFill(buf, <span class="hljs-number">5</span>, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));
});

<span class="hljs-comment">// 以上等价于以下内容：</span>
randomFill(buf, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  randomFill,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">10</span>);
randomFill(buf, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));
});

randomFill(buf, <span class="hljs-number">5</span>, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));
});

<span class="hljs-comment">// 以上等价于以下内容：</span>
randomFill(buf, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">'hex'</span>));
});</code></pre>
<p>任何 <code>ArrayBuffer</code>、<code>TypedArray</code> 或 <code>DataView</code> 实例都可以作为 <code>buffer</code> 传入。</p>
<p>虽然这包括 <code>Float32Array</code> 和 <code>Float64Array</code> 的实例，但不应使用此函数生成随机浮点数。
结果可能包含 <code>+Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code>，即使数组只包含有限数字，它们也不是从均匀随机分布中抽取的，并且没有有意义的下限或上限。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  randomFill,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(<span class="hljs-number">10</span>);
randomFill(a, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
    .toString(<span class="hljs-string">'hex'</span>));
});

<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>));
randomFill(b, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
    .toString(<span class="hljs-string">'hex'</span>));
});

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>);
randomFill(c, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(buf).toString(<span class="hljs-string">'hex'</span>));
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  randomFill,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(<span class="hljs-number">10</span>);
randomFill(a, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
    .toString(<span class="hljs-string">'hex'</span>));
});

<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>));
randomFill(b, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
    .toString(<span class="hljs-string">'hex'</span>));
});

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>);
randomFill(c, <span class="hljs-function">(<span class="hljs-params">err, buf</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(Buffer.from(buf).toString(<span class="hljs-string">'hex'</span>));
});</code></pre>
<p>此 API 使用 libuv 的线程池，这对某些应用程序可能会产生意外的负面性能影响；有关更多信息，请参阅 <a href="cli.html#cli_uv_threadpool_size_size"><code>UV_THREADPOOL_SIZE</code></a> 文档。</p>
<p><code>crypto.randomFill()</code> 的异步版本是在单个线程池请求中执行的。
为了最大限度地减少线程池任务长度变化，在执行客户端请求时将大型 <code>randomFill</code> 请求分区。</p>
<h4><code>crypto.randomInt([min, ]max[, callback])</code><span><a class="mark" href="#crypto_crypto_randomint_min_max_callback" id="crypto_crypto_randomint_min_max_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_randomint_min_max_callback">
                <a href="crypto/crypto_randomint_min_max_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v14.10.0, v12.19.0</span>
</div>
<ul>
<li><code>min</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 随机范围的开始（包括）。 <strong>默认值:</strong> <code>0</code>。</li>
<li><code>max</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 随机范围的结束（不包括）。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> <code>function(err, n) {}</code>.</li>
</ul>
<p>返回随机整数 <code>n</code>，使得 <code>min &lt;= n &lt; max</code>。
这种实现避免了<a href="http://url.nodejs.cn/ucie85">模偏差</a>。</p>
<p>范围 (<code>max - min</code>) 必须小于 2<sup>48</sup>。
<code>min</code> 和 <code>max</code> 必须是<a href="http://url.nodejs.cn/km9EMH">安全整数</a>。</p>
<p>如果不提供 <code>callback</code> 函数，则同步生成随机整数。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-comment">// 异步的</span>
<span class="hljs-keyword">const</span> {
  randomInt,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

randomInt(<span class="hljs-number">3</span>, <span class="hljs-function">(<span class="hljs-params">err, n</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Random number chosen from (0, 1, 2): <span class="hljs-subst">${n}</span>`</span>);
});</code><code class="language-js cjs"><span class="hljs-comment">// 异步的</span>
<span class="hljs-keyword">const</span> {
  randomInt,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

randomInt(<span class="hljs-number">3</span>, <span class="hljs-function">(<span class="hljs-params">err, n</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Random number chosen from (0, 1, 2): <span class="hljs-subst">${n}</span>`</span>);
});</code></pre>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-comment">// 同步的</span>
<span class="hljs-keyword">const</span> {
  randomInt,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> n = randomInt(<span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Random number chosen from (0, 1, 2): <span class="hljs-subst">${n}</span>`</span>);</code><code class="language-js cjs"><span class="hljs-comment">// 同步的</span>
<span class="hljs-keyword">const</span> {
  randomInt,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> n = randomInt(<span class="hljs-number">3</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Random number chosen from (0, 1, 2): <span class="hljs-subst">${n}</span>`</span>);</code></pre>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-comment">// 带有 `min` 参数</span>
<span class="hljs-keyword">const</span> {
  randomInt,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> n = randomInt(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The dice rolled: <span class="hljs-subst">${n}</span>`</span>);</code><code class="language-js cjs"><span class="hljs-comment">// 带有 `min` 参数</span>
<span class="hljs-keyword">const</span> {
  randomInt,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> n = randomInt(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The dice rolled: <span class="hljs-subst">${n}</span>`</span>);</code></pre>
<h4><code>crypto.randomUUID([options])</code><span><a class="mark" href="#crypto_crypto_randomuuid_options" id="crypto_crypto_randomuuid_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_randomuuid_options">
                <a href="crypto/crypto_randomuuid_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>disableEntropyCache</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 默认情况下，为了提高性能，Node.js 会生成并缓存足够多的随机数据，以生成多达 128 个随机 UUID。
要在不使用缓存的情况下生成 UUID，请将 <code>disableEntropyCache</code> 设置为 <code>true</code>。
<strong>默认值:</strong> <code>false</code>。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>生成随机的 <a href="http://url.nodejs.cn/pupRCA">RFC 4122</a> 版本 4 UUID。
UUID 是使用加密伪随机数生成器生成的。</p>
<h4><code>crypto.scrypt(password, salt, keylen[, options], callback)</code><span><a class="mark" href="#crypto_crypto_scrypt_password_salt_keylen_options_callback" id="crypto_crypto_scrypt_password_salt_keylen_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_scrypt_password_salt_keylen_options_callback">
                <a href="crypto/crypto_scrypt_password_salt_keylen_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>密码和盐参数也可以是 ArrayBuffer 实例。</p></td></tr>
<tr><td>v12.8.0, v10.17.0</td>
<td><p><code>maxmem</code> 值现在可以是任何安全整数。</p></td></tr>
<tr><td>v10.9.0</td>
<td><p>添加了 <code>cost</code>、<code>blockSize</code> 和 <code>parallelization</code> 选项名称。</p></td></tr>
<tr><td>v10.5.0</td>
<td><p><span>新增于: v10.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>password</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>salt</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>keylen</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>cost</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> CPU/内存成本参数。
必须是大于 1 的 2 的幂。 <strong>默认值:</strong> <code>16384</code>。</li>
<li><code>blockSize</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 块大小参数。 <strong>默认值:</strong> <code>8</code>。</li>
<li><code>parallelization</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 并行化参数。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>N</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>cost</code> 的别名。
只能指定两者之一。</li>
<li><code>r</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>blockSize</code> 的别名。
只能指定两者之一。</li>
<li><code>p</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>parallelization</code> 的别名。
只能指定两者之一。</li>
<li><code>maxmem</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 内存上限。
当（大约）<code>128 * N * r &gt; maxmem</code> 时，则为错误。 <strong>默认值:</strong> <code>32 * 1024 * 1024</code>。</li>
</ul>
</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>derivedKey</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
</ul>
<p>提供异步 <a href="http://url.nodejs.cn/757w2j">scrypt</a> 实现。
Scrypt 是一个基于密码的密钥派生函数，其设计在计算和内存方面都非常昂贵，以使蛮力攻击毫无回报。</p>
<p><code>salt</code> 应该尽可能唯一。
建议盐是随机的，长度至少为 16 字节。
有关详细信息，请参阅 <a href="http://url.nodejs.cn/DbTtwt">NIST SP 800-132</a>。</p>
<p>为 <code>password</code> 或 <code>salt</code> 传入字符串时，请考虑到<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">当使用字符串作为加密 API 输入时的注意事项</a>。</p>
<p><code>callback</code> 函数使用两个参数调用：<code>err</code> 和 <code>derivedKey</code>。
当密钥派生失败时 <code>err</code> 为异常对象，否则 <code>err</code> 为 <code>null</code>。
<code>derivedKey</code> 作为 <a href="buffer.html"><code>Buffer</code></a> 传给回调。</p>
<p>当任何输入参数指定无效值或类型时，将抛出异常。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  scrypt,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 使用出厂默认设置。</span>
scrypt(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span>
});
<span class="hljs-comment">// 使用自定义 N 参数。必须是二的幂。</span>
scrypt(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>, { <span class="hljs-attr">N</span>: <span class="hljs-number">1024</span> }, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...aa39b34'</span>
});</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  scrypt,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 使用出厂默认设置。</span>
scrypt(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span>
});
<span class="hljs-comment">// 使用自定义 N 参数。必须是二的幂。</span>
scrypt(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>, { <span class="hljs-attr">N</span>: <span class="hljs-number">1024</span> }, <span class="hljs-function">(<span class="hljs-params">err, derivedKey</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  <span class="hljs-built_in">console</span>.log(derivedKey.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...aa39b34'</span>
});</code></pre>
<h4><code>crypto.scryptSync(password, salt, keylen[, options])</code><span><a class="mark" href="#crypto_crypto_scryptsync_password_salt_keylen_options" id="crypto_crypto_scryptsync_password_salt_keylen_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_scryptsync_password_salt_keylen_options">
                <a href="crypto/crypto_scryptsync_password_salt_keylen_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.8.0, v10.17.0</td>
<td><p><code>maxmem</code> 值现在可以是任何安全整数。</p></td></tr>
<tr><td>v10.9.0</td>
<td><p>添加了 <code>cost</code>、<code>blockSize</code> 和 <code>parallelization</code> 选项名称。</p></td></tr>
<tr><td>v10.5.0</td>
<td><p><span>新增于: v10.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>password</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>salt</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>keylen</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>cost</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> CPU/内存成本参数。
必须是大于 1 的 2 的幂。 <strong>默认值:</strong> <code>16384</code>。</li>
<li><code>blockSize</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 块大小参数。 <strong>默认值:</strong> <code>8</code>。</li>
<li><code>parallelization</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 并行化参数。 <strong>默认值:</strong> <code>1</code>。</li>
<li><code>N</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>cost</code> 的别名。
只能指定两者之一。</li>
<li><code>r</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>blockSize</code> 的别名。
只能指定两者之一。</li>
<li><code>p</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>parallelization</code> 的别名。
只能指定两者之一。</li>
<li><code>maxmem</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 内存上限。
当（大约）<code>128 * N * r &gt; maxmem</code> 时，则为错误。 <strong>默认值:</strong> <code>32 * 1024 * 1024</code>。</li>
</ul>
</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
<p>提供同步的 <a href="http://url.nodejs.cn/757w2j">scrypt</a> 实现。
Scrypt 是一个基于密码的密钥派生函数，其设计在计算和内存方面都非常昂贵，以使蛮力攻击毫无回报。</p>
<p><code>salt</code> 应该尽可能唯一。
建议盐是随机的，长度至少为 16 字节。
有关详细信息，请参阅 <a href="http://url.nodejs.cn/DbTtwt">NIST SP 800-132</a>。</p>
<p>为 <code>password</code> 或 <code>salt</code> 传入字符串时，请考虑到<a href="crypto.html#crypto_using_strings_as_inputs_to_cryptographic_apis">当使用字符串作为加密 API 输入时的注意事项</a>。</p>
<p>当密钥派生失败时抛出异常，否则派生的密钥作为 <a href="buffer.html"><code>Buffer</code></a> 返回。</p>
<p>当任何输入参数指定无效值或类型时，将抛出异常。</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  scryptSync,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-comment">// 使用出厂默认设置。</span>

<span class="hljs-keyword">const</span> key1 = scryptSync(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>);
<span class="hljs-built_in">console</span>.log(key1.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span>
<span class="hljs-comment">// 使用自定义 N 参数。必须是二的幂。</span>
<span class="hljs-keyword">const</span> key2 = scryptSync(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>, { <span class="hljs-attr">N</span>: <span class="hljs-number">1024</span> });
<span class="hljs-built_in">console</span>.log(key2.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...aa39b34'</span></code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  scryptSync,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-comment">// 使用出厂默认设置。</span>

<span class="hljs-keyword">const</span> key1 = scryptSync(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>);
<span class="hljs-built_in">console</span>.log(key1.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...08d59ae'</span>
<span class="hljs-comment">// 使用自定义 N 参数。必须是二的幂。</span>
<span class="hljs-keyword">const</span> key2 = scryptSync(<span class="hljs-string">'password'</span>, <span class="hljs-string">'salt'</span>, <span class="hljs-number">64</span>, { <span class="hljs-attr">N</span>: <span class="hljs-number">1024</span> });
<span class="hljs-built_in">console</span>.log(key2.toString(<span class="hljs-string">'hex'</span>));  <span class="hljs-comment">// '3745e48...aa39b34'</span></code></pre>
<h4><code>crypto.secureHeapUsed()</code><span><a class="mark" href="#crypto_crypto_secureheapused" id="crypto_crypto_secureheapused">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_secureheapused">
                <a href="crypto/crypto_secureheapused.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.6.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>total</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 使用 <code>--secure-heap=n</code> 命令行标志指定的总分配安全堆大小。</li>
<li><code>min</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 使用 <code>--secure-heap-min</code> 命令行标志指定的安全堆的最小分配。</li>
<li><code>used</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 当前从安全堆分配的总字节数。</li>
<li><code>utilization</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>used</code> 与 <code>total</code> 分配字节的计算比率。</li>
</ul>
</li>
</ul>
<h4><code>crypto.setEngine(engine[, flags])</code><span><a class="mark" href="#crypto_crypto_setengine_engine_flags" id="crypto_crypto_setengine_engine_flags">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_setengine_engine_flags">
                <a href="crypto/crypto_setengine_engine_flags.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.11</span>
</div>
<ul>
<li><code>engine</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>flags</code> <a href="crypto.html#crypto_crypto_constants_1" rel="nofollow" class="type">&lt;crypto.constants&gt;</a> <strong>默认值:</strong> <code>crypto.constants.ENGINE_METHOD_ALL</code></li>
</ul>
<p>为部分或所有 OpenSSL 功能（由标志选择）加载并设置 <code>engine</code>。</p>
<p><code>engine</code> 可以是 id 或引擎共享库的路径。</p>
<p>可选的 <code>flags</code> 参数默认使用 <code>ENGINE_METHOD_ALL</code>。
<code>flags</code> 是采用以下标志之一或混合的位字段（在 <code>crypto.constants</code> 中定义）：</p>
<ul>
<li><code>crypto.constants.ENGINE_METHOD_RSA</code></li>
<li><code>crypto.constants.ENGINE_METHOD_DSA</code></li>
<li><code>crypto.constants.ENGINE_METHOD_DH</code></li>
<li><code>crypto.constants.ENGINE_METHOD_RAND</code></li>
<li><code>crypto.constants.ENGINE_METHOD_EC</code></li>
<li><code>crypto.constants.ENGINE_METHOD_CIPHERS</code></li>
<li><code>crypto.constants.ENGINE_METHOD_DIGESTS</code></li>
<li><code>crypto.constants.ENGINE_METHOD_PKEY_METHS</code></li>
<li><code>crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS</code></li>
<li><code>crypto.constants.ENGINE_METHOD_ALL</code></li>
<li><code>crypto.constants.ENGINE_METHOD_NONE</code></li>
</ul>
<p>以下标志在 OpenSSL-1.1.0 中已弃用。</p>
<ul>
<li><code>crypto.constants.ENGINE_METHOD_ECDH</code></li>
<li><code>crypto.constants.ENGINE_METHOD_ECDSA</code></li>
<li><code>crypto.constants.ENGINE_METHOD_STORE</code></li>
</ul>
<h4><code>crypto.setFips(bool)</code><span><a class="mark" href="#crypto_crypto_setfips_bool" id="crypto_crypto_setfips_bool">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_setfips_bool">
                <a href="crypto/crypto_setfips_bool.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.0.0</span>
</div>
<ul>
<li><code>bool</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> <code>true</code> 启用 FIPS 模式。</li>
</ul>
<p>在启用 FIPS 的 Node.js 构建中启用符合 FIPS 的加密提供程序。
如果 FIPS 模式不可用，则会抛出错误。</p>
<h4><code>crypto.sign(algorithm, data, key[, callback])</code><span><a class="mark" href="#crypto_crypto_sign_algorithm_data_key_callback" id="crypto_crypto_sign_algorithm_data_key_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_sign_algorithm_data_key_callback">
                <a href="crypto/crypto_sign_algorithm_data_key_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.12.0</td>
<td><p>添加了可选的回调参数。</p></td></tr>
<tr><td>v13.2.0, v12.16.0</td>
<td><p>此函数现在支持 IEEE-P1363 DSA 和 ECDSA 签名。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p><span>新增于: v12.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="http://url.nodejs.cn/8ym6ow" rel="nofollow" class="type">&lt;undefined&gt;</a></li>
<li><code>data</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>key</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a></li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>signature</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a></li>
</ul>
</li>
<li>返回: <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 如果未提供 <code>callback</code> 函数。
  <!--lint enable maximum-line-length remark-lint-->
</li>
</ul>
<p>使用给定的私钥和算法计算并返回 <code>data</code> 的签名。
如果 <code>algorithm</code> 是 <code>null</code> 或 <code>undefined</code>，则算法取决于密钥类型（尤其是 Ed25519 和 Ed448）。</p>
<p>如果 <code>key</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>key</code> 传给 <a href="crypto.html#crypto_crypto_createprivatekey_key"><code>crypto.createPrivateKey()</code></a> 一样。
如果是对象，则可以传入以下额外属性：</p>
<ul>
<li>
<p><code>dsaEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 对于 DSA 和 ECDSA，此选项指定生成签名的格式。
它可以是以下之一：</p>
<ul>
<li><code>'der'</code>（默认）：DER 编码的 ASN.1 签名结构编码 <code>(r, s)</code>。</li>
<li><code>'ieee-p1363'</code>: IEEE-P1363 中提议的签名格式 <code>r || s</code>。</li>
</ul>
</li>
<li>
<p><code>padding</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> RSA 的可选填充值，以下之一：</p>
<ul>
<li><code>crypto.constants.RSA_PKCS1_PADDING</code>（默认）</li>
<li><code>crypto.constants.RSA_PKCS1_PSS_PADDING</code></li>
</ul>
<p><code>RSA_PKCS1_PSS_PADDING</code> 将使用 MGF1 与用于签署消息的相同散列函数，如 <a href="http://url.nodejs.cn/o3Gr5v">RFC 4055</a> 的第 3.1 节中指定的那样。</p>
</li>
<li>
<p><code>saltLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 填充为 <code>RSA_PKCS1_PSS_PADDING</code> 时的盐长度。
特殊值 <code>crypto.constants.RSA_PSS_SALTLEN_DIGEST</code> 将盐长度设置为摘要大小，<code>crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN</code>（默认值）将其设置为最大允许值。</p>
</li>
</ul>
<p>如果提供了 <code>callback</code> 函数，则该函数使用 libuv 的线程池。</p>
<h4><code>crypto.timingSafeEqual(a, b)</code><span><a class="mark" href="#crypto_crypto_timingsafeequal_a_b" id="crypto_crypto_timingsafeequal_a_b">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_timingsafeequal_a_b">
                <a href="crypto/crypto_timingsafeequal_a_b.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.0.0</td>
<td><p>a 和 b 参数也可以是 ArrayBuffer。</p></td></tr>
<tr><td>v6.6.0</td>
<td><p><span>新增于: v6.6.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>a</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>b</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>该函数基于恒定时间算法。
如果 <code>a</code> 等于 <code>b</code>，则返回 true，而不会泄露允许攻击者猜测其中一个值的时间信息。
这适用于比较 HMAC 摘要或秘密值，如身份验证 cookie 或<a href="http://url.nodejs.cn/RjMmbw">功能网址</a>。</p>
<p><code>a</code> 和 <code>b</code> 必须都是 <code>Buffer</code>、<code>TypedArray</code>s 或 <code>DataView</code>，并且它们的字节长度必须相同。</p>
<p>如果 <code>a</code> 和 <code>b</code> 中的至少一个是每个条目超过一个字节的 <code>TypedArray</code>，例如 <code>Uint16Array</code>，则将使用平台字节顺序计算结果。</p>
<p>使用 <code>crypto.timingSafeEqual</code> 并不能保证周围的代码是时间安全的。
应注意确保周围的代码不会引入时序漏洞。</p>
<h4><code>crypto.verify(algorithm, data, key, signature[, callback])</code><span><a class="mark" href="#crypto_crypto_verify_algorithm_data_key_signature_callback" id="crypto_crypto_verify_algorithm_data_key_signature_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_verify_algorithm_data_key_signature_callback">
                <a href="crypto/crypto_verify_algorithm_data_key_signature_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.12.0</td>
<td><p>添加了可选的回调参数。</p></td></tr>
<tr><td>v15.0.0</td>
<td><p>数据、密钥和签名参数也可以是 ArrayBuffer。</p></td></tr>
<tr><td>v13.2.0, v12.16.0</td>
<td><p>此函数现在支持 IEEE-P1363 DSA 和 ECDSA 签名。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p><span>新增于: v12.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--lint disable maximum-line-length remark-lint-->
<ul>
<li><code>algorithm</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="http://url.nodejs.cn/8ym6ow" rel="nofollow" class="type">&lt;undefined&gt;</a></li>
<li><code>data</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>key</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a> | <a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a></li>
<li><code>signature</code> <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" class="type">&lt;ArrayBuffer&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a></li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>result</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果未提供 <code>callback</code> 函数，则 <code>true</code> 或 <code>false</code> 取决于数据和公钥签名的有效性。
  <!--lint enable maximum-line-length remark-lint-->
</li>
</ul>
<p>使用给定的密钥和算法验证 <code>data</code> 的给定签名。
如果 <code>algorithm</code> 是 <code>null</code> 或 <code>undefined</code>，则算法取决于密钥类型（尤其是 Ed25519 和 Ed448）。</p>
<p>如果 <code>key</code> 不是 <a href="crypto.html#crypto_class_keyobject"><code>KeyObject</code></a>，则此函数的行为就像将 <code>key</code> 传给 <a href="crypto.html#crypto_crypto_createpublickey_key"><code>crypto.createPublicKey()</code></a> 一样。
如果是对象，则可以传入以下额外属性：</p>
<ul>
<li>
<p><code>dsaEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 对于 DSA 和 ECDSA，此选项指定签名的格式。
它可以是以下之一：</p>
<ul>
<li><code>'der'</code>（默认）：DER 编码的 ASN.1 签名结构编码 <code>(r, s)</code>。</li>
<li><code>'ieee-p1363'</code>: IEEE-P1363 中提议的签名格式 <code>r || s</code>。</li>
</ul>
</li>
<li>
<p><code>padding</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> RSA 的可选填充值，以下之一：</p>
<ul>
<li><code>crypto.constants.RSA_PKCS1_PADDING</code>（默认）</li>
<li><code>crypto.constants.RSA_PKCS1_PSS_PADDING</code></li>
</ul>
<p><code>RSA_PKCS1_PSS_PADDING</code> 将使用 MGF1 与用于签署消息的相同散列函数，如 <a href="http://url.nodejs.cn/o3Gr5v">RFC 4055</a> 的第 3.1 节中指定的那样。</p>
</li>
<li>
<p><code>saltLength</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 填充为 <code>RSA_PKCS1_PSS_PADDING</code> 时的盐长度。
特殊值 <code>crypto.constants.RSA_PSS_SALTLEN_DIGEST</code> 将盐长度设置为摘要大小，<code>crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN</code>（默认值）将其设置为最大允许值。</p>
</li>
</ul>
<p><code>signature</code> 参数是先前为 <code>data</code> 计算的签名。</p>
<p>因为公钥可以从私钥派生出来，所以可以为 <code>key</code> 传入私钥或公钥。</p>
<p>如果提供了 <code>callback</code> 函数，则该函数使用 libuv 的线程池。</p>
<h4><code>crypto.webcrypto</code><span><a class="mark" href="#crypto_crypto_webcrypto" id="crypto_crypto_webcrypto">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_webcrypto">
                <a href="crypto/crypto_webcrypto.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<p>Type: <a href="webcrypto.html#webcrypto_class_crypto" rel="nofollow" class="type">&lt;Crypto&gt;</a> Web 加密 API 标准的实现。</p>
<p>有关详细信息，请参阅 <a href="webcrypto.html">Web 加密 API 文档</a>。</p>
</section><section><h3>注意事项<span><a class="mark" href="#crypto_notes" id="crypto_notes">#</a></span></h3>
<h4>使用字符串作为加密 API 的输入<span><a class="mark" href="#crypto_using_strings_as_inputs_to_cryptographic_apis" id="crypto_using_strings_as_inputs_to_cryptographic_apis">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="using_strings_as_inputs_to_cryptographic_apis">
                <a href="crypto/using_strings_as_inputs_to_cryptographic_apis.html" class="tip_trans">中英对照</a>
                </p>
<p>由于历史原因，Node.js 提供的许多加密 API 都接受字符串作为输入，其中底层加密算法处理字节序列。
这些实例包括明文、密文、对称密钥、初始化向量、密码、盐、认证标签和额外的认证数据。</p>
<p>将字符串传给加密 API 时，请考虑以下因素。</p>
<ul>
<li>
<p>并非所有字节序列都是有效的 UTF-8 字符串。
因此，当从字符串中导出长度为 <code>n</code> 的字节序列时，其熵通常低于随机或伪随机 <code>n</code> 字节序列的熵。
例如，没有 UTF-8 字符串将导致字节序列 <code>c0 af</code>。
秘密密钥应该几乎完全是随机或伪随机字节序列。</p>
</li>
<li>
<p>同样，在将随机或伪随机字节序列转换为 UTF-8 字符串时，不代表有效代码点的子序列可能会被 Unicode 替换字符 (<code>U+FFFD</code>) 替换。
因此，生成的 Unicode 字符串的字节表示可能不等于创建字符串的字节序列。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> original = [<span class="hljs-number">0xc0</span>, <span class="hljs-number">0xaf</span>];
<span class="hljs-keyword">const</span> bytesAsString = Buffer.from(original).toString(<span class="hljs-string">'utf8'</span>);
<span class="hljs-keyword">const</span> stringAsBytes = Buffer.from(bytesAsString, <span class="hljs-string">'utf8'</span>);
<span class="hljs-built_in">console</span>.log(stringAsBytes);
<span class="hljs-comment">// 打印 '&lt;Buffer ef bf bd ef bf bd&gt;'</span></code></pre>
<p>密码、散列函数、签名算法和密钥派生函数的输出是伪随机字节序列，不应用作 Unicode 字符串。</p>
</li>
<li>
<p>从用户输入中获取字符串时，某些 Unicode 字符可以用多种等效方式表示，从而产生不同的字节序列。
例如，将用户密码传递给密钥派生函数（例如 PBKDF2 或 scrypt）时，密钥派生函数的结果取决于字符串是使用组合字符还是分解字符。
Node.js 不会规范化字符表示。
在将用户输入传给加密 API 之前，开发人员应考虑在用户输入上使用 <a href="http://url.nodejs.cn/wzacDq"><code>String.prototype.normalize()</code></a>。</p>
</li>
</ul>
<h4>旧版的流 API（Node.js v0.10 之前）<span><a class="mark" href="#crypto_legacy_streams_api_prior_to_node_js_0_10" id="crypto_legacy_streams_api_prior_to_node_js_0_10">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="legacy_streams_api_prior_to_node_js_0_10">
                <a href="crypto/legacy_streams_api_prior_to_node_js_0_10.html" class="tip_trans">中英对照</a>
                </p>
<p>加密模块是在 Node.js 出现统一的流 API 概念之前添加的，在 <a href="buffer.html"><code>Buffer</code></a> 对象用于处理二进制数据之前。
因此，许多 <code>crypto</code> 定义的类具有在其他实现<a href="stream.html">流</a> API 的 Node.js 类（例如 <code>update()</code>、<code>final()</code> 或 <code>digest()</code>）上通常找不到的方法。
此外，许多方法默认接受并返回 <code>'latin1'</code> 编码字符串，而不是 <code>Buffer</code>。
此默认值在 Node.js v0.8 之后更改为默认使用 <a href="buffer.html"><code>Buffer</code></a> 对象。</p>
<h4>ECDH 近期的变化<span><a class="mark" href="#crypto_recent_ecdh_changes" id="crypto_recent_ecdh_changes">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="recent_ecdh_changes">
                <a href="crypto/recent_ecdh_changes.html" class="tip_trans">中英对照</a>
                </p>
<p><code>ECDH</code> 与非动态生成的密钥对的使用已得到简化。
现在，可以使用预选的私钥调用 <a href="crypto.html#crypto_ecdh_setprivatekey_privatekey_encoding"><code>ecdh.setPrivateKey()</code></a>，并且关联的公钥（密钥）将被计算并存储在对象中。
这允许代码仅存储和提供 EC 密钥对的私有部分。
<a href="crypto.html#crypto_ecdh_setprivatekey_privatekey_encoding"><code>ecdh.setPrivateKey()</code></a> 现在还验证私钥对所选曲线是否有效。</p>
<p><a href="crypto.html#crypto_ecdh_setpublickey_publickey_encoding"><code>ecdh.setPublicKey()</code></a> 方法现在已被弃用，因为它包含在 API 中没有用。
要么应设置先前存储的私钥，它会自动生成关联的公钥，要么应调用 <a href="crypto.html#crypto_ecdh_generatekeys_encoding_format"><code>ecdh.generateKeys()</code></a>。
使用 <a href="crypto.html#crypto_ecdh_setpublickey_publickey_encoding"><code>ecdh.setPublicKey()</code></a> 的主要缺点是它可用于将 ECDH 密钥对置于不一致的状态。</p>
<h4>弱算法或受损算法的支持<span><a class="mark" href="#crypto_support_for_weak_or_compromised_algorithms" id="crypto_support_for_weak_or_compromised_algorithms">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="support_for_weak_or_compromised_algorithms">
                <a href="crypto/support_for_weak_or_compromised_algorithms.html" class="tip_trans">中英对照</a>
                </p>
<p><code>crypto</code> 模块仍然支持一些已经被破坏并且目前不推荐使用的算法。
API 还允许使用对于安全使用来说太弱的小密钥大小的密码和散列。</p>
<p>用户应根据自己的安全要求对选择加密算法和密钥大小负全部责任。</p>
<p>基于 <a href="http://url.nodejs.cn/tNMwGm">NIST SP 800-131A</a> 的建议：</p>
<ul>
<li>MD5 和 SHA-1 在需要抗碰撞性（例如数字签名）的情况下不再被接受。</li>
<li>RSA、DSA 和 DH 算法使用的密钥建议至少 2048 位，ECDSA 和 ECDH 的曲线至少 224 位，才能安全使用几年。</li>
<li><code>modp1</code>、<code>modp2</code>、<code>modp5</code> 的 DH 组密钥长度小于 2048 位，不推荐使用。</li>
</ul>
<p>有关其他建议和详细信息，请参阅参考资料。</p>
<h4>CCM 模式<span><a class="mark" href="#crypto_ccm_mode" id="crypto_ccm_mode">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="ccm_mode">
                <a href="crypto/ccm_mode.html" class="tip_trans">中英对照</a>
                </p>
<p>CCM 是支持的 <a href="http://url.nodejs.cn/oJCCfc">AEAD 算法</a>之一。
使用此模式的应用程序在使用密码 API 时必须遵守某些限制：</p>
<ul>
<li>身份验证标签长度必须在密码创建期间通过设置 <code>authTagLength</code> 选项指定，并且必须是 4、6、8、10、12、14 或 16 字节之一。</li>
<li>初始化向量 (nonce) <code>N</code> 的长度必须介于 7 到 13 个字节 (<code>7 ≤ N ≤ 13</code>) 之间。</li>
<li>明文的长度限制为 <code>2 ** (8 * (15 - N))</code> 个字节。</li>
<li>解密时，必须在调用 <code>update()</code> 之前通过 <code>setAuthTag()</code> 设置认证标签。
否则，解密将失败并且 <code>final()</code> 将根据 <a href="http://url.nodejs.cn/w4NGuq">RFC 3610</a> 的第 2.6 节抛出错误。</li>
<li>在 CCM 模式下使用 <code>write(data)</code>、<code>end(data)</code> 或 <code>pipe()</code> 等流方法可能会失败，因为 CCM 无法处理每个实例的多个数据块。</li>
<li>当传入额外的认证数据 (AAD) 时，必须通过 <code>plaintextLength</code> 选项将实际消息的长度（以字节为单位）传递给 <code>setAAD()</code>。
许多加密库在密文中包含认证标签，这意味着它们产生长度为 <code>plaintextLength + authTagLength</code> 的密文。
Node.js 不包含认证标签，所以密文长度始终为 <code>plaintextLength</code>。
如果没有使用 AAD，则这不是必需的。</li>
<li>由于 CCM 一次处理整个消息，因此必须恰好调用 <code>update()</code> 一次。</li>
<li>即使调用 <code>update()</code> 足以加密/解密消息，应用程序必须调用 <code>final()</code> 来计算或验证身份验证标签。</li>
</ul>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">const</span> {
  createCipheriv,
  createDecipheriv,
  randomBytes,
} = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> key = <span class="hljs-string">'keykeykeykeykeykeykeykey'</span>;
<span class="hljs-keyword">const</span> nonce = randomBytes(<span class="hljs-number">12</span>);

<span class="hljs-keyword">const</span> aad = Buffer.from(<span class="hljs-string">'0123456789'</span>, <span class="hljs-string">'hex'</span>);

<span class="hljs-keyword">const</span> cipher = createCipheriv(<span class="hljs-string">'aes-192-ccm'</span>, key, nonce, {
  <span class="hljs-attr">authTagLength</span>: <span class="hljs-number">16</span>
});
<span class="hljs-keyword">const</span> plaintext = <span class="hljs-string">'Hello world'</span>;
cipher.setAAD(aad, {
  <span class="hljs-attr">plaintextLength</span>: Buffer.byteLength(plaintext)
});
<span class="hljs-keyword">const</span> ciphertext = cipher.update(plaintext, <span class="hljs-string">'utf8'</span>);
cipher.final();
<span class="hljs-keyword">const</span> tag = cipher.getAuthTag();

<span class="hljs-comment">// 现在传输 { ciphertext, nonce, tag }。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(<span class="hljs-string">'aes-192-ccm'</span>, key, nonce, {
  <span class="hljs-attr">authTagLength</span>: <span class="hljs-number">16</span>
});
decipher.setAuthTag(tag);
decipher.setAAD(aad, {
  <span class="hljs-attr">plaintextLength</span>: ciphertext.length
});
<span class="hljs-keyword">const</span> receivedPlaintext = decipher.update(ciphertext, <span class="hljs-literal">null</span>, <span class="hljs-string">'utf8'</span>);

<span class="hljs-keyword">try</span> {
  decipher.final();
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Authentication failed!'</span>);
  <span class="hljs-keyword">return</span>;
}

<span class="hljs-built_in">console</span>.log(receivedPlaintext);</code><code class="language-js cjs"><span class="hljs-keyword">const</span> {
  createCipheriv,
  createDecipheriv,
  randomBytes,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-keyword">const</span> key = <span class="hljs-string">'keykeykeykeykeykeykeykey'</span>;
<span class="hljs-keyword">const</span> nonce = randomBytes(<span class="hljs-number">12</span>);

<span class="hljs-keyword">const</span> aad = Buffer.from(<span class="hljs-string">'0123456789'</span>, <span class="hljs-string">'hex'</span>);

<span class="hljs-keyword">const</span> cipher = createCipheriv(<span class="hljs-string">'aes-192-ccm'</span>, key, nonce, {
  <span class="hljs-attr">authTagLength</span>: <span class="hljs-number">16</span>
});
<span class="hljs-keyword">const</span> plaintext = <span class="hljs-string">'Hello world'</span>;
cipher.setAAD(aad, {
  <span class="hljs-attr">plaintextLength</span>: Buffer.byteLength(plaintext)
});
<span class="hljs-keyword">const</span> ciphertext = cipher.update(plaintext, <span class="hljs-string">'utf8'</span>);
cipher.final();
<span class="hljs-keyword">const</span> tag = cipher.getAuthTag();

<span class="hljs-comment">// 现在传输 { ciphertext, nonce, tag }。</span>

<span class="hljs-keyword">const</span> decipher = createDecipheriv(<span class="hljs-string">'aes-192-ccm'</span>, key, nonce, {
  <span class="hljs-attr">authTagLength</span>: <span class="hljs-number">16</span>
});
decipher.setAuthTag(tag);
decipher.setAAD(aad, {
  <span class="hljs-attr">plaintextLength</span>: ciphertext.length
});
<span class="hljs-keyword">const</span> receivedPlaintext = decipher.update(ciphertext, <span class="hljs-literal">null</span>, <span class="hljs-string">'utf8'</span>);

<span class="hljs-keyword">try</span> {
  decipher.final();
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Authentication failed!'</span>);
  <span class="hljs-keyword">return</span>;
}

<span class="hljs-built_in">console</span>.log(receivedPlaintext);</code></pre>
</section><section><h3>加密常量<span><a class="mark" href="#crypto_crypto_constants_1" id="crypto_crypto_constants_1">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="crypto_constants_1">
                <a href="crypto/crypto_constants_1.html" class="tip_trans">中英对照</a>
                </p>
<p><code>crypto.constants</code> 导出的以下常量适用于 <code>crypto</code>、<code>tls</code> 和 <code>https</code> 模块的各种用途，并且通常特定于 OpenSSL。</p>
<h4>OpenSSL 选项<span><a class="mark" href="#crypto_openssl_options" id="crypto_openssl_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="openssl_options">
                <a href="crypto/openssl_options.html" class="tip_trans">中英对照</a>
                </p>
<table>
  <tbody><tr>
    <th>常量</th>
    <th>描述</th>
  </tr>
  <tr>
    <td><code>SSL_OP_ALL</code></td>
    <td>在 OpenSSL 中应用多个错误解决方法。
详情请参阅 <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html">https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html</a>。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_ALLOW_NO_DHE_KEX</code></td>
    <td>指示 OpenSSL 允许 TLS v1.3 的非基于 [EC]DHE 的密钥交换模式</td>
  </tr>
  <tr>
    <td><code>SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION</code></td>
    <td>允许在 OpenSSL 和未打补丁的客户端或服务器之间进行旧版的不安全重新协商。
详情请参阅 <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html">https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html</a>。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_CIPHER_SERVER_PREFERENCE</code></td>
    <td>在选择密码时尝试使用服务器的首选项而不是客户端的首选项。
行为取决于协议版本。
详情请参阅 <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html">https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html</a>。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_CISCO_ANYCONNECT</code></td>
    <td>指示 OpenSSL 使用思科的 "speshul" 版本的 DTLSBADVER。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_COOKIE_EXCHANGE</code></td>
    <td>指示 OpenSSL 打开 cookie 交换。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_CRYPTOPRO_TLSEXT_BUG</code></td>
    <td>指示 OpenSSL 从早期版本的 cryptopro 草案中添加 server-hello 扩展。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS</code></td>
    <td>指示 OpenSSL 禁用在 OpenSSL 0.9.6d 中添加的 SSL 3.0/TLS 1.0 漏洞解决方法。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_EPHEMERAL_RSA</code></td>
    <td>指示 OpenSSL 在执行 RSA 操作时始终使用 tmp_rsa 密钥。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_LEGACY_SERVER_CONNECT</code></td>
    <td>允许初始连接到不支持 RI 的服务器。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_MICROSOFT_SESS_ID_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_MSIE_SSLV2_RSA_PADDING</code></td>
    <td>指示 OpenSSL 禁用 SSL 2.0 服务器实现中的中间人协议版本漏洞的解决方法。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NETSCAPE_CA_DN_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_NETSCAPE_CHALLENGE_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_COMPRESSION</code></td>
    <td>指示 OpenSSL 禁用对 SSL/TLS 压缩的支持。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_ENCRYPT_THEN_MAC</code></td>
    <td>指示 OpenSSL 禁用 encrypt-then-MAC。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_QUERY_MTU</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_RENEGOTIATION</code></td>
    <td>指示 OpenSSL 禁用重新协商。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION</code></td>
    <td>指示 OpenSSL 在执行重新协商时始终启动新会话。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_SSLv2</code></td>
    <td>指示 OpenSSL 关闭 SSL v2</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_SSLv3</code></td>
    <td>指示 OpenSSL 关闭 SSL v3</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_TICKET</code></td>
    <td>指示 OpenSSL 禁用 RFC4507bis 票证的使用。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_TLSv1</code></td>
    <td>指示 OpenSSL 关闭 TLS v1</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_TLSv1_1</code></td>
    <td>指示 OpenSSL 关闭 TLS v1.1</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_TLSv1_2</code></td>
    <td>指示 OpenSSL 关闭 TLS v1.2</td>
  </tr>
  <tr>
    <td><code>SSL_OP_NO_TLSv1_3</code></td>
    <td>指示 OpenSSL 关闭 TLS v1.3</td>
  </tr>
    <tr><td><code>SSL_OP_PKCS1_CHECK_1</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_PKCS1_CHECK_2</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_PRIORITIZE_CHACHA</code></td>
    <td>当客户端这样做时，指示 OpenSSL 服务器优先考虑 ChaCha20Poly1305。
如果 <code>SSL_OP_CIPHER_SERVER_PREFERENCE</code> 未启用，则此选项无效。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_SINGLE_DH_USE</code></td>
    <td>指示 OpenSSL 在使用临时/短暂 DH 参数时始终创建新密钥。</td>
  </tr>
  <tr>
    <td><code>SSL_OP_SINGLE_ECDH_USE</code></td>
    <td>指示 OpenSSL 在使用临时/短暂 ECDH 参数时始终创建新密钥。</td>
  </tr>
    <tr><td><code>SSL_OP_SSLEAY_080_CLIENT_DH_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_TLS_BLOCK_PADDING_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_TLS_D5_BUG</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>SSL_OP_TLS_ROLLBACK_BUG</code></td>
    <td>指示 OpenSSL 禁用版本回滚攻击检测。</td>
  </tr>
</tbody></table>
<h4>OpenSSL 引擎的常量<span><a class="mark" href="#crypto_openssl_engine_constants" id="crypto_openssl_engine_constants">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="openssl_engine_constants">
                <a href="crypto/openssl_engine_constants.html" class="tip_trans">中英对照</a>
                </p>
<table>
  <tbody><tr>
    <th>常量</th>
    <th>描述</th>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_RSA</code></td>
    <td>将引擎使用限制为 RSA</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_DSA</code></td>
    <td>将引擎使用限制为 DSA</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_DH</code></td>
    <td>将引擎使用限制为 DH</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_RAND</code></td>
    <td>将引擎使用限制为 RAND</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_EC</code></td>
    <td>将引擎使用限制为 EC</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_CIPHERS</code></td>
    <td>将引擎使用限制为 CIPHERS</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_DIGESTS</code></td>
    <td>将引擎使用限制为 DIGESTS</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_PKEY_METHS</code></td>
    <td>将引擎使用限制为 PKEY_METHDS</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_PKEY_ASN1_METHS</code></td>
    <td>将引擎使用限制为 PKEY_ASN1_METHS</td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_ALL</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>ENGINE_METHOD_NONE</code></td>
    <td></td>
  </tr>
</tbody></table>
<h4>其他 OpenSSL 常量<span><a class="mark" href="#crypto_other_openssl_constants" id="crypto_other_openssl_constants">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="other_openssl_constants">
                <a href="crypto/other_openssl_constants.html" class="tip_trans">中英对照</a>
                </p>
<p>有关详细信息，请参阅 <a href="http://url.nodejs.cn/QxXQf5">SSL OP 标志列表</a>。</p>
<table>
  <tbody><tr>
    <th>常量</th>
    <th>描述</th>
  </tr>
  <tr>
    <td><code>DH_CHECK_P_NOT_SAFE_PRIME</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>DH_CHECK_P_NOT_PRIME</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>DH_UNABLE_TO_CHECK_GENERATOR</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>DH_NOT_SUITABLE_GENERATOR</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>ALPN_ENABLED</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>RSA_PKCS1_PADDING</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>RSA_SSLV23_PADDING</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>RSA_NO_PADDING</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>RSA_PKCS1_OAEP_PADDING</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>RSA_X931_PADDING</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>RSA_PKCS1_PSS_PADDING</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>RSA_PSS_SALTLEN_DIGEST</code></td>
    <td>在签名或验证时将 <code>RSA_PKCS1_PSS_PADDING</code> 的盐长度设置为摘要大小。</td>
  </tr>
  <tr>
    <td><code>RSA_PSS_SALTLEN_MAX_SIGN</code></td>
    <td>将 <code>RSA_PKCS1_PSS_PADDING</code> 的盐长度设置为签名数据时的最大允许值。</td>
  </tr>
  <tr>
    <td><code>RSA_PSS_SALTLEN_AUTO</code></td>
    <td>导致在验证签名时自动确定 <code>RSA_PKCS1_PSS_PADDING</code> 的盐长度。</td>
  </tr>
  <tr>
    <td><code>POINT_CONVERSION_COMPRESSED</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>POINT_CONVERSION_UNCOMPRESSED</code></td>
    <td></td>
  </tr>
  <tr>
    <td><code>POINT_CONVERSION_HYBRID</code></td>
    <td></td>
  </tr>
</tbody></table>
<h4>Node.js 加密常量<span><a class="mark" href="#crypto_node_js_crypto_constants" id="crypto_node_js_crypto_constants">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="node_js_crypto_constants">
                <a href="crypto/node_js_crypto_constants.html" class="tip_trans">中英对照</a>
                </p>
<table>
  <tbody><tr>
    <th>常量</th>
    <th>描述</th>
  </tr>
  <tr>
    <td><code>defaultCoreCipherList</code></td>
    <td>指定 Node.js 使用的内置默认密码列表。</td>
  </tr>
  <tr>
    <td><code>defaultCipherList</code></td>
    <td>指定当前 Node.js 进程使用的活动默认密码列表。</td>
  </tr>
</tbody></table></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  
  <!-- <script src="//cdn.staticfile.org/highlight.js/10.2.1/highlight.min.js"></script> -->
  
  


</body></html>