<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>stream 流 | Node.js API 文档</title>
  <link rel="icon" sizes="32x32" type="image/png" href="//static.nodejs.cn/_static/img/favicon.png">
  <link href="css/api.css?1625411158752" rel="stylesheet">
</head>

<body class="alt apidoc" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="/" rel="nofollow">
          Node.js 中文网
        </a>

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.4.1</a></li>
        </ul> -->
      <div id="biz_nav"><a title="云服务器" target="_blank" rel="nofollow"><img></a></div>
      <div class="line"></div>
      <ul>
<li><a href="assert.html" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="buffer.html" rel="nofollow">Buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="child_process.html" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="console.html" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="crypto.html" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="debugger.html" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="dgram.html" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="net.html" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="process.html" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="string_decoder.html" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" rel="nofollow">timer<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" rel="nofollow">wasi<span class="api_nav_cn_name">WebAssembly系统接口</span></a></li>
<li><a href="webcrypto.html" rel="nofollow">webcrypto<span class="api_nav_cn_name">Web加密</span></a></li>
<li><a href="worker_threads.html" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>
<hr class="line">
<ul>
<li><a href="documentation.html" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" rel="nofollow">用法与示例</a></li>
<li><a href="cli.html" rel="nofollow">命令行选项</a></li>
<li><a href="modules.html" rel="nofollow">CommonJS<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="esm.html" rel="nofollow">ECMAScript<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="packages.html" rel="nofollow">包模块</a></li>
<li><a href="addons.html" rel="nofollow">C++<span class="api_nav_cn_name">插件</span></a></li>
<li><a href="embedding.html" rel="nofollow">C++<span class="api_nav_cn_name">嵌入器</span></a></li>
<li><a href="n-api.html" rel="nofollow">N-API</a></li>
<li><a href="async_context.html" rel="nofollow">异步上下文跟踪</a></li>
<li><a href="policy.html" rel="nofollow">安全策略</a></li>
<li><a href="deprecations.html" rel="nofollow">弃用的<span class="api_nav_cn_name">API</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="stream" class="interior">
      <header>
        <div class="header-container">
          <h1>Node.js v16.4.1 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li>
              <a href="./">返回文档首页</a>
            </li>
            <li>
              <a href="http://api.nodejs.cn/">搜索</a>
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#stream_stream">stream 流</a></span>
<ul>
<li><a href="#stream_organization_of_this_document">本文档的组织结构</a></li>
<li><a href="#stream_types_of_streams">流的类型</a>
<ul>
<li><a href="#stream_streams_promises_api">流的 Promise API</a></li>
<li><a href="#stream_object_mode">对象模式</a></li>
<li><a href="#stream_buffering">缓冲</a></li>
</ul>
</li>
<li><a href="#stream_api_for_stream_consumers">用于消费流的 API</a>
<ul>
<li><a href="#stream_writable_streams">可写流</a>
<ul>
<li><a href="#stream_class_stream_writable"><code>stream.Writable</code> 类</a>
<ul>
<li><a href="#stream_event_close"><code>'close'</code> 事件</a></li>
<li><a href="#stream_event_drain"><code>'drain'</code> 事件</a></li>
<li><a href="#stream_event_error"><code>'error'</code> 事件</a></li>
<li><a href="#stream_event_finish"><code>'finish'</code> 事件</a></li>
<li><a href="#stream_event_pipe"><code>'pipe'</code> 事件</a></li>
<li><a href="#stream_event_unpipe"><code>'unpipe'</code> 事件</a></li>
<li><a href="#stream_writable_cork"><code>writable.cork()</code></a></li>
<li><a href="#stream_writable_destroy_error"><code>writable.destroy([error])</code></a></li>
<li><a href="#stream_writable_destroyed"><code>writable.destroyed</code></a></li>
<li><a href="#stream_writable_end_chunk_encoding_callback"><code>writable.end([chunk[, encoding]][, callback])</code></a></li>
<li><a href="#stream_writable_setdefaultencoding_encoding"><code>writable.setDefaultEncoding(encoding)</code></a></li>
<li><a href="#stream_writable_uncork"><code>writable.uncork()</code></a></li>
<li><a href="#stream_writable_writable"><code>writable.writable</code></a></li>
<li><a href="#stream_writable_writableended"><code>writable.writableEnded</code></a></li>
<li><a href="#stream_writable_writablecorked"><code>writable.writableCorked</code></a></li>
<li><a href="#stream_writable_writablefinished"><code>writable.writableFinished</code></a></li>
<li><a href="#stream_writable_writablehighwatermark"><code>writable.writableHighWaterMark</code></a></li>
<li><a href="#stream_writable_writablelength"><code>writable.writableLength</code></a></li>
<li><a href="#stream_writable_writableneeddrain"><code>writable.writableNeedDrain</code></a></li>
<li><a href="#stream_writable_writableobjectmode"><code>writable.writableObjectMode</code></a></li>
<li><a href="#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk[, encoding][, callback])</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#stream_readable_streams">可读流</a>
<ul>
<li><a href="#stream_two_reading_modes">两种读取模式</a></li>
<li><a href="#stream_three_states">三种状态</a></li>
<li><a href="#stream_choose_one_api_style">选择一种接口风格</a></li>
<li><a href="#stream_class_stream_readable"><code>stream.Readable</code> 类</a>
<ul>
<li><a href="#stream_event_close_1"><code>'close'</code> 事件</a></li>
<li><a href="#stream_event_data"><code>'data'</code> 事件</a></li>
<li><a href="#stream_event_end"><code>'end'</code> 事件</a></li>
<li><a href="#stream_event_error_1"><code>'error'</code> 事件</a></li>
<li><a href="#stream_event_pause"><code>'pause'</code> 事件</a></li>
<li><a href="#stream_event_readable"><code>'readable'</code> 事件</a></li>
<li><a href="#stream_event_resume"><code>'resume'</code> 事件</a></li>
<li><a href="#stream_readable_destroy_error"><code>readable.destroy([error])</code></a></li>
<li><a href="#stream_readable_destroyed"><code>readable.destroyed</code></a></li>
<li><a href="#stream_readable_ispaused"><code>readable.isPaused()</code></a></li>
<li><a href="#stream_readable_pause"><code>readable.pause()</code></a></li>
<li><a href="#stream_readable_pipe_destination_options"><code>readable.pipe(destination[, options])</code></a></li>
<li><a href="#stream_readable_read_size"><code>readable.read([size])</code></a></li>
<li><a href="#stream_readable_readable"><code>readable.readable</code></a></li>
<li><a href="#stream_readable_readableencoding"><code>readable.readableEncoding</code></a></li>
<li><a href="#stream_readable_readableended"><code>readable.readableEnded</code></a></li>
<li><a href="#stream_readable_readableflowing"><code>readable.readableFlowing</code></a></li>
<li><a href="#stream_readable_readablehighwatermark"><code>readable.readableHighWaterMark</code></a></li>
<li><a href="#stream_readable_readablelength"><code>readable.readableLength</code></a></li>
<li><a href="#stream_readable_readableobjectmode"><code>readable.readableObjectMode</code></a></li>
<li><a href="#stream_readable_resume"><code>readable.resume()</code></a></li>
<li><a href="#stream_readable_setencoding_encoding"><code>readable.setEncoding(encoding)</code></a></li>
<li><a href="#stream_readable_unpipe_destination"><code>readable.unpipe([destination])</code></a></li>
<li><a href="#stream_readable_unshift_chunk_encoding"><code>readable.unshift(chunk[, encoding])</code></a></li>
<li><a href="#stream_readable_wrap_stream"><code>readable.wrap(stream)</code></a></li>
<li><a href="#stream_readable_symbol_asynciterator"><code>readable[Symbol.asyncIterator]()</code></a></li>
<li><span class="stability_1"><a href="#stream_readable_iterator_options"><code>readable.iterator([options])</code></a></span></li>
</ul>
</li>
</ul>
</li>
<li><a href="#stream_duplex_and_transform_streams">双工流与转换流</a>
<ul>
<li><a href="#stream_class_stream_duplex"><code>stream.Duplex</code> 类</a></li>
<li><a href="#stream_class_stream_transform"><code>stream.Transform</code> 类</a>
<ul>
<li><a href="#stream_transform_destroy_error"><code>transform.destroy([error])</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#stream_stream_finished_stream_options_callback"><code>stream.finished(stream[, options], callback)</code></a></li>
<li><a href="#stream_stream_pipeline_source_transforms_destination_callback"><code>stream.pipeline(source[, ...transforms], destination, callback)</code></a></li>
<li><a href="#stream_stream_pipeline_streams_callback"><code>stream.pipeline(streams, callback)</code></a></li>
<li><a href="#stream_stream_readable_from_iterable_options"><code>stream.Readable.from(iterable, [options])</code></a></li>
<li><a href="#stream_stream_addabortsignal_signal_stream"><code>stream.addAbortSignal(signal, stream)</code></a></li>
</ul>
</li>
<li><a href="#stream_api_for_stream_implementers">用于实现流的 API</a>
<ul>
<li><a href="#stream_simplified_construction">简单的实现</a></li>
<li><a href="#stream_implementing_a_writable_stream">实现可写流</a>
<ul>
<li><a href="#stream_new_stream_writable_options"><code>new stream.Writable([options])</code></a></li>
<li><a href="#stream_writable_construct_callback"><code>writable._construct(callback)</code></a></li>
<li><a href="#stream_writable_write_chunk_encoding_callback_1"><code>writable._write(chunk, encoding, callback)</code></a></li>
<li><a href="#stream_writable_writev_chunks_callback"><code>writable._writev(chunks, callback)</code></a></li>
<li><a href="#stream_writable_destroy_err_callback"><code>writable._destroy(err, callback)</code></a></li>
<li><a href="#stream_writable_final_callback"><code>writable._final(callback)</code></a></li>
<li><a href="#stream_errors_while_writing">写入时的异常处理</a></li>
<li><a href="#stream_an_example_writable_stream">可写流的例子</a></li>
<li><a href="#stream_decoding_buffers_in_a_writable_stream">在可写流中解码 buffer</a></li>
</ul>
</li>
<li><a href="#stream_implementing_a_readable_stream">实现可读流</a>
<ul>
<li><a href="#stream_new_stream_readable_options"><code>new stream.Readable([options])</code></a></li>
<li><a href="#stream_readable_construct_callback"><code>readable._construct(callback)</code></a></li>
<li><a href="#stream_readable_read_size_1"><code>readable._read(size)</code></a></li>
<li><a href="#stream_readable_destroy_err_callback"><code>readable._destroy(err, callback)</code></a></li>
<li><a href="#stream_readable_push_chunk_encoding"><code>readable.push(chunk[, encoding])</code></a></li>
<li><a href="#stream_errors_while_reading">读取时的异常处理</a></li>
<li><a href="#stream_an_example_counting_stream">可读流的例子</a></li>
</ul>
</li>
<li><a href="#stream_implementing_a_duplex_stream">实现双工流</a>
<ul>
<li><a href="#stream_new_stream_duplex_options"><code>new stream.Duplex(options)</code></a></li>
<li><a href="#stream_an_example_duplex_stream">双工流的例子</a></li>
<li><a href="#stream_object_mode_duplex_streams">对象模式的双工流</a></li>
</ul>
</li>
<li><a href="#stream_implementing_a_transform_stream">实现转换流</a>
<ul>
<li><a href="#stream_new_stream_transform_options"><code>new stream.Transform([options])</code></a></li>
<li><a href="#stream_event_end_1"><code>'end'</code> 事件</a></li>
<li><a href="#stream_event_finish_1"><code>'finish'</code> 事件</a></li>
<li><a href="#stream_transform_flush_callback"><code>transform._flush(callback)</code></a></li>
<li><a href="#stream_transform_transform_chunk_encoding_callback"><code>transform._transform(chunk, encoding, callback)</code></a></li>
<li><a href="#stream_class_stream_passthrough">stream.PassThrough 类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#stream_additional_notes">其他注意事项</a>
<ul>
<li><a href="#stream_streams_compatibility_with_async_generators_and_async_iterators">流与异步生成器和异步迭代器的兼容性</a>
<ul>
<li><a href="#stream_consuming_readable_streams_with_async_iterators">使用异步迭代器消费可读流</a></li>
<li><a href="#stream_creating_readable_streams_with_async_generators">使用异步生成器创建可读流</a></li>
<li><a href="#stream_piping_to_writable_streams_from_async_iterators">从异步迭代器传送到可写流</a></li>
</ul>
</li>
<li><a href="#stream_compatibility_with_older_node_js_versions">兼容旧版本的 Node.js</a></li>
<li><a href="#stream_readable_read_0"><code>readable.read(0)</code></a></li>
<li><a href="#stream_readable_push"><code>readable.push('')</code></a></li>
<li><a href="#stream_highwatermark_discrepancy_after_calling_readable_setencoding">调用 `readable.setEncoding()` 之后 `highWaterMark` 的差异</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <!-- <div id="biz_content">
          <a href="http://www.tp-shop.cn/index.php?http_referer=node" target="_blank">
            <img src="//static.nodejs.cn/_static/img/ad/api_content_tpshop.jpg" />
          </a>
        </div> -->

      <div id="apicontent">
        <h2>stream 流<span><a class="mark" href="#stream_stream" id="stream_stream">#</a></span></h2><p class="tip_wrap" data-show_trans="1" data-item_id="stream">
                <a href="stream/stream.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.10.0-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">稳定性: 2</a> - 稳定</div><p></p>
<p><strong>源代码:</strong> <a rel="nofollow" href="http://url.nodejs.cn/wjPkXP">lib/stream.js</a></p>
<p>流（stream）是 Node.js 中处理流式数据的抽象接口。
<code>stream</code> 模块用于构建实现了流接口的对象。</p>
<p>Node.js 提供了多种流对象。
例如，<a href="http.html#http_class_http_incomingmessage">HTTP 服务器的请求</a>和 <a href="process.html#process_process_stdout"><code>process.stdout</code></a> 都是流的实例。</p>
<p>流可以是可读的、可写的、或者可读可写的。
所有的流都是 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> 的实例。</p>
<p>访问 <code>stream</code> 模块：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> stream = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);</code></pre>
<p>尽管理解流的工作方式很重要，但是 <code>stream</code> 模块主要用于开发者创建新类型的流实例。
对于以消费流对象为主的开发者，极少需要直接使用 <code>stream</code> 模块。</p>
<section><h3>本文档的组织结构<span><a class="mark" href="#stream_organization_of_this_document" id="stream_organization_of_this_document">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="organization_of_this_document">
                <a href="stream/organization_of_this_document.html" class="tip_trans">中英对照</a>
                </p>
<p>本文档分为两个主要章节，外加其他注意事项作为第三章节。
第一章节阐述了在应用程序中使用流时需要的 API。
第二章节阐述了实现新类型的流时需要的 API。</p>
</section><section><h3>流的类型<span><a class="mark" href="#stream_types_of_streams" id="stream_types_of_streams">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="types_of_streams">
                <a href="stream/types_of_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>Node.js 中有四种基本的流类型：</p>
<ul>
<li><a href="stream.html#stream_class_stream_writable"><code>Writable</code></a> - 可写入数据的流（例如 <a href="fs.html#fs_fs_createwritestream_path_options"><code>fs.createWriteStream()</code></a>）。</li>
<li><a href="stream.html#stream_class_stream_readable"><code>Readable</code></a> - 可读取数据的流（例如 <a href="fs.html#fs_fs_createreadstream_path_options"><code>fs.createReadStream()</code></a>）。</li>
<li><a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> - 可读又可写的流（例如 <a href="net.html#net_class_net_socket"><code>net.Socket</code></a>）。</li>
<li><a href="stream.html#stream_class_stream_transform"><code>Transform</code></a> - 在读写过程中可以修改或转换数据的 <code>Duplex</code> 流（例如 <a href="zlib.html#zlib_zlib_createdeflate_options"><code>zlib.createDeflate()</code></a>）。</li>
</ul>
<p>此外，该模块还包括实用函数 <a href="stream.html#stream_stream_pipeline_source_transforms_destination_callback"><code>stream.pipeline()</code></a>、<a href="stream.html#stream_stream_finished_stream_options_callback"><code>stream.finished()</code></a> 和 <a href="stream.html#stream_stream_readable_from_iterable_options"><code>stream.Readable.from()</code></a>。</p>
<h4>流的 Promise API<span><a class="mark" href="#stream_streams_promises_api" id="stream_streams_promises_api">#</a></span></h4><p class="tip_wrap" data-item_id="streams_promises_api"></p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<p>The <code>stream/promises</code> API provides an alternative set of asynchronous utility
functions for streams that return <code>Promise</code> objects rather than using
callbacks. The API is accessible via <code>require('stream/promises')</code>
or <code>require('stream').promises</code>.</p>
<h4>对象模式<span><a class="mark" href="#stream_object_mode" id="stream_object_mode">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="object_mode">
                <a href="stream/object_mode.html" class="tip_trans">中英对照</a>
                </p>
<p>Node.js 创建的流都是运作在字符串和&nbsp;<code>Buffer</code>（或 <code>Uint8Array</code>）上。
当然，流的实现也可以使用其它类型的 JavaScript 值（除了 <code>null</code>）。
这些流会以“对象模式”进行操作。</p>
<p>当创建流时，可以使用 <code>objectMode</code> 选项把流实例切换到对象模式。
将已存在的流切换到对象模式是不安全的。</p>
<h4>缓冲<span><a class="mark" href="#stream_buffering" id="stream_buffering">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="buffering">
                <a href="stream/buffering.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p><a href="stream.html#stream_class_stream_writable">可写流</a>和<a href="stream.html#stream_class_stream_readable">可读流</a>都会在内部的缓冲器中存储数据，可以分别使用的 <code>writable.writableBuffer</code> 或 <code>readable.readableBuffer</code> 来获取。</p>
<p>可缓冲的数据大小取决于传入流构造函数的 <code>highWaterMark</code> 选项。
对于普通的流，<code>highWaterMark</code> 指定了<a href="stream.html#stream_highwatermark_discrepancy_after_calling_readable_setencoding">字节的总数</a>。
对于对象模式的流，<code>highWaterMark</code> 指定了对象的总数。</p>
<p>当调用 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a> 时，数据会被缓冲在可读流中。
如果流的消费者没有调用 <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a>，则数据会保留在内部队列中直到被消费。</p>
<p>一旦内部的可读缓冲的总大小达到 <code>highWaterMark</code> 指定的阈值时，流会暂时停止从底层资源读取数据，直到当前缓冲的数据被消费
（也就是说，流会停止调用内部的用于填充可读缓冲的 <code>readable._read()</code>）。</p>
<p>当调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> 时，数据会被缓冲在可写流中。
当内部的可写缓冲的总大小小于 <code>highWaterMark</code> 设置的阈值时，调用 <code>writable.write()</code> 会返回 <code>true</code>。
一旦内部缓冲的大小达到或超过 <code>highWaterMark</code> 时，则会返回 <code>false</code>。</p>
<p><code>stream</code> API 的主要目标，特别是 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a>，是为了限制数据的缓冲到可接受的程度，也就是读写速度不一致的源头与目的地不会压垮内存。</p>
<p>The <code>highWaterMark</code> option is a threshold, not a limit: it dictates the amount
of data that a stream buffers before it stops asking for more data. It does not
enforce a strict memory limitation in general. Specific stream implementations
may choose to enforce stricter limits but doing so is optional.</p>
<p>因为 <a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> 和 <a href="stream.html#stream_class_stream_transform"><code>Transform</code></a> 都是可读又可写的，所以它们各自维护着两个相互独立的内部缓冲器用于读取和写入，
这使得它们在维护数据流时，读取和写入两边可以各自独立地运作。
例如，<a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 实例是 <a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> 流，它的可读端可以消费从 socket 接收的数据，而可写端则可以将数据写入到 socket。
因为数据写入到 socket 的速度可能比接收数据的速度快或者慢，所以读写两端应该独立地进行操作（或缓冲）。</p>
</section><section><h3>用于消费流的 API<span><a class="mark" href="#stream_api_for_stream_consumers" id="stream_api_for_stream_consumers">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="api_for_stream_consumers">
                <a href="stream/api_for_stream_consumers.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p>几乎所有的 Node.js 应用都在某种程度上使用了流。
下面是一个例子，使用流实现了一个 HTTP 服务器：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
 &nbsp;<span class="hljs-comment">// req 是一个 http.IncomingMessage 实例，它是可读流。</span>
 &nbsp;<span class="hljs-comment">// res 是一个 http.ServerResponse 实例，它是可写流。</span>

  <span class="hljs-keyword">let</span> body = <span class="hljs-string">''</span>;
 &nbsp;<span class="hljs-comment">// 接收数据为 utf8 字符串，</span>
 &nbsp;<span class="hljs-comment">// 如果没有设置字符编码，则会接收到 Buffer 对象。</span>
 &nbsp;req.setEncoding(<span class="hljs-string">'utf8'</span>);

 &nbsp;<span class="hljs-comment">// 如果添加了监听器，则可读流会触发 'data' 事件。</span>
  req.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    body += chunk;
  });

 &nbsp;<span class="hljs-comment">// 'end' 事件表明整个请求体已被接收。 </span>
  req.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(body);
 &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 响应信息给用户。</span>
 &nbsp; &nbsp; &nbsp;res.write(<span class="hljs-keyword">typeof</span> data);
      res.end();
    } <span class="hljs-keyword">catch</span> (er) {
 &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// json 解析失败。</span>
      res.statusCode = <span class="hljs-number">400</span>;
      <span class="hljs-keyword">return</span> res.end(<span class="hljs-string">`错误: <span class="hljs-subst">${er.message}</span>`</span>);
    }
  });
});

server.listen(<span class="hljs-number">1337</span>);

<span class="hljs-comment">// $ curl localhost:1337 -d "{}"</span>
<span class="hljs-comment">// object</span>
<span class="hljs-comment">// $ curl localhost:1337 -d "\"foo\""</span>
<span class="hljs-comment">// string</span>
<span class="hljs-comment">// $ curl localhost:1337 -d "not json"</span>
<span class="hljs-comment">// 错误: Unexpected token o in JSON at position 1</span></code></pre>
<p><a href="stream.html#stream_class_stream_writable">可写流</a>（比如例子中的 <code>res</code>）会暴露了一些方法，比如 <code>write()</code> 和&nbsp;<code>end()</code> 用于写入数据到流。</p>
<p>当数据可以从流读取时，<a href="stream.html#stream_class_stream_readable">可读流</a>会使用&nbsp;<a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> API 来通知应用程序。
从流读取数据的方式有很多种。</p>
<p><a href="stream.html#stream_class_stream_writable">可写流</a>和<a href="stream.html#stream_class_stream_readable">可读流</a>都通过多种方式使用 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> API 来通讯流的当前状态。</p>
<p><a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> 流和 <a href="stream.html#stream_class_stream_transform"><code>Transform</code></a> 流都是可写又可读的。</p>
<p>对于只需写入数据到流或从流消费数据的应用程序，并不需要直接实现流的接口，通常也不需要调用 <code>require('stream')</code>。</p>
<p>对于需要实现新类型的流的开发者，可以参见<a href="stream.html#stream_api_for_stream_implementers">用于实现流的API</a>章节。</p>
<h4>可写流<span><a class="mark" href="#stream_writable_streams" id="stream_writable_streams">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="writable_streams">
                <a href="stream/writable_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>可写流是对数据要被写入的目的地的一种抽象。</p>
<p>可写流的例子包括：</p>
<ul>
<li><a href="http.html#http_class_http_clientrequest">客户端的 HTTP 请求</a></li>
<li><a href="http.html#http_class_http_serverresponse">服务器的 HTTP 响应</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs 的写入流</a></li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
<li><a href="net.html#net_class_net_socket">TCP socket</a></li>
<li><a href="child_process.html#child_process_subprocess_stdin">子进程 stdin</a></li>
<li><a href="process.html#process_process_stdout"><code>process.stdout</code></a>、<a href="process.html#process_process_stderr"><code>process.stderr</code></a></li>
</ul>
<p>上面的一些例子事实上是实现了可写流接口的 <a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> 流。</p>
<p>所有可写流都实现了 <code>stream.Writable</code> 类定义的接口。</p>
<p>尽管可写流的具体实例可能略有差别，但所有的可写流都遵循同一基本的使用模式，如以下例子所示：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myStream = getWritableStreamSomehow();
myStream.write(<span class="hljs-string">'一些数据'</span>);
myStream.write(<span class="hljs-string">'更多数据'</span>);
myStream.end(<span class="hljs-string">'完成写入数据'</span>);</code></pre>
<h5><code>stream.Writable</code> 类<span><a class="mark" href="#stream_class_stream_writable" id="stream_class_stream_writable">#</a></span></h5><p class="tip_wrap" data-item_id="class_stream_writable"></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<!--type=class-->
<h6><code>'close'</code> 事件<span><a class="mark" href="#stream_event_close" id="stream_event_close">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_close">
                <a href="stream/event_close.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>Add <code>emitClose</code> option to specify if <code>'close'</code> is emitted on destroy.</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>当流或其底层资源（比如文件描述符）被关闭时触发。
表明不会再触发其他事件，也不会再发生操作。</p>
<p>如果使用 <code>emitClose</code> 选项创建<a href="stream.html#stream_class_stream_writable">可写流</a>，则它将会始终发出 <code>'close'</code> 事件。</p>
<h6><code>'drain'</code> 事件<span><a class="mark" href="#stream_event_drain" id="stream_event_drain">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_drain">
                <a href="stream/event_drain.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>如果调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> 返回 <code>false</code>，则当可以继续写入数据到流时会触发 <code>'drain'</code> 事件。</p>
<pre><code class="language-js"><span class="hljs-comment">// 向可写流中写入数据一百万次。</span>
<span class="hljs-comment">// 留意背压（back-pressure）。</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeOneMillionTimes</span>(<span class="hljs-params">writer, data, encoding, callback</span>) </span>{
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">1000000</span>;
  write();
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> ok = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">do</span> {
      i--;
      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 最后一次写入。</span>
 &nbsp; &nbsp; &nbsp; &nbsp;writer.write(data, encoding, callback);
      } <span class="hljs-keyword">else</span> {
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 检查是否可以继续写入。 </span>
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 不要传入回调，因为写入还没有结束。</span>
 &nbsp; &nbsp; &nbsp; &nbsp;ok = writer.write(data, encoding);
      }
    } <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; ok);
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
 &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 被提前中止。</span>
 &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// 当触发 'drain' 事件时继续写入。</span>
      writer.once(<span class="hljs-string">'drain'</span>, write);
    }
  }
}</code></pre>
<h6><code>'error'</code> 事件<span><a class="mark" href="#stream_event_error" id="stream_event_error">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_error">
                <a href="stream/event_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
</ul>
<p>如果在写入或管道数据时发生错误，则会触发 <code>'error'</code> 事件。
当调用时，监听器回调会传入一个 <code>Error</code> 参数。</p>
<p>除非在创建流时将 <a href="stream.html#stream_new_stream_writable_options"><code>autoDestroy</code></a> 选项设置为 <code>false</code>，否则在触发 <code>'error'</code> 事件时流会被关闭。</p>
<p>在 <code>'error'</code> 之后，除 <code>'close'</code> 事件外，不应再触发其他事件（包括 <code>'error'</code> 事件）。</p>
<h6><code>'finish'</code> 事件<span><a class="mark" href="#stream_event_finish" id="stream_event_finish">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_finish">
                <a href="stream/event_finish.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>调用 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 且缓冲数据都已传给底层系统之后触发。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> writer = getWritableStreamSomehow();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  writer.write(<span class="hljs-string">`写入 #<span class="hljs-subst">${i}</span>!\n`</span>);
}
writer.on(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'写入已完成'</span>);
});
writer.end(<span class="hljs-string">'写入结尾\n'</span>);</code></pre>
<h6><code>'pipe'</code> 事件<span><a class="mark" href="#stream_event_pipe" id="stream_event_pipe">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_pipe">
                <a href="stream/event_pipe.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>src</code> <a href="stream.html#stream_class_stream_readable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a> 通过管道流入到可写流的来源流。</li>
</ul>
<p>当在可读流上调用 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> 方法时会发出 <code>'pipe'</code> 事件，并将此可写流添加到其目标集。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> writer = getWritableStreamSomehow();
<span class="hljs-keyword">const</span> reader = getReadableStreamSomehow();
writer.on(<span class="hljs-string">'pipe'</span>, <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'有数据正通过管道流入写入器'</span>);
  assert.equal(src, reader);
});
reader.pipe(writer);</code></pre>
<h6><code>'unpipe'</code> 事件<span><a class="mark" href="#stream_event_unpipe" id="stream_event_unpipe">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_unpipe">
                <a href="stream/event_unpipe.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>src</code> <a href="stream.html#stream_class_stream_readable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a> 要<a href="stream.html#stream_readable_unpipe_destination">移除</a>可写流管道的来源流。</li>
</ul>
<p>在可读流上调用 <a href="stream.html#stream_readable_unpipe_destination"><code>stream.unpipe()</code></a> 方法时会发出 <code>'unpipe'</code>事件，从其目标集中移除此可写流。</p>
<p>当可读流通过管道流向可写流发生错误时，也会触发此事件。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> writer = getWritableStreamSomehow();
<span class="hljs-keyword">const</span> reader = getReadableStreamSomehow();
writer.on(<span class="hljs-string">'unpipe'</span>, <span class="hljs-function">(<span class="hljs-params">src</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'已移除可写流管道'</span>);
  assert.equal(src, reader);
});
reader.pipe(writer);
reader.unpipe(writer);</code></pre>
<h6><code>writable.cork()</code><span><a class="mark" href="#stream_writable_cork" id="stream_writable_cork">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_cork">
                <a href="stream/writable_cork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.2</span>
</div>
<p><code>writable.cork()</code> 方法强制把所有写入的数据都缓冲到内存中。
当调用 <a href="stream.html#stream_writable_uncork"><code>stream.uncork()</code></a> 或 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 方法时，缓冲的数据才会被输出。</p>
<p><code>writable.cork()</code> 的主要目的是为了适应将几个数据快速连续地写入流的情况。
<code>writable.cork()</code> 不会立即将它们转发到底层的目标，而是缓冲所有数据块，直到调用 <code>writable.uncork()</code>，这会将它们全部传给 <code>writable._writev()</code>（如果存在）。
这可以防止出现行头阻塞的情况，在这种情况下，正在等待第一个数据块被处理的同时对数据进行缓冲。
但是，使用 <code>writable.cork()</code> 而不实现 <code>writable._writev()</code> 可能会对吞吐量产生不利影响。</p>
<p>也可参见：<a href="stream.html#stream_writable_uncork"><code>writable.uncork()</code></a>、<a href="stream.html#stream_writable_writev_chunks_callback"><code>writable._writev()</code></a>。</p>
<h6><code>writable.destroy([error])</code><span><a class="mark" href="#stream_writable_destroy_error" id="stream_writable_destroy_error">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_destroy_error">
                <a href="stream/writable_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>Work as a no-op on a stream that has already been destroyed.</p></td></tr>
<tr><td>v8.0.0</td>
<td><p><span>新增于: v8.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>error</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> 可选，使用 <code>'error'</code> 事件触发的错误。</li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁流。
可选地触发 <code>'error'</code>，并且触发 <code>'close'</code> 事件（除非将 <code>emitClose</code> 设置为 <code>false</code>）。
调用该方法后，可写流就结束了，之后再调用 <code>write()</code> 或 <code>end()</code> 都会导致 <code>ERR_STREAM_DESTROYED</code> 错误。
这是销毁流的最直接的方式。
前面对 <code>write()</code> 的调用可能没有耗尽，并且可能触发 <code>ERR_STREAM_DESTROYED</code> 错误。
如果数据在关闭之前应该刷新，则使用 <code>end()</code> 而不是销毁，或者在销毁流之前等待 <code>'drain'</code> 事件。</p>
<p>一旦调用 <code>destroy()</code>，则不会再执行任何其他操作，并且除了 <code>_destroy()</code> 以外的其他错误都不会作为 <code>'error'</code> 触发。</p>
<p>实现者不应该重写此方法，而应该实现 <a href="stream.html#stream_writable_destroy_err_callback"><code>writable._destroy()</code></a>。</p>
<h6><code>writable.destroyed</code><span><a class="mark" href="#stream_writable_destroyed" id="stream_writable_destroyed">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_destroyed">
                <a href="stream/writable_destroyed.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用了 <a href="stream.html#stream_writable_destroy_error"><code>writable.destroy()</code></a> 之后为 <code>true</code>。</p>
<h6><code>writable.end([chunk[, encoding]][, callback])</code><span><a class="mark" href="#stream_writable_end_chunk_encoding_callback" id="stream_writable_end_chunk_encoding_callback">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_end_chunk_encoding_callback">
                <a href="stream/writable_end_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>The <code>callback</code> is invoked if 'finish' or 'error' is emitted.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>This method now returns a reference to <code>writable</code>.</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>chunk</code> argument can now be a <code>Uint8Array</code> instance.</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>chunk</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 要写入的数据。
对于非对象模式的流，<code>chunk</code> 必须是字符串、<code>Buffer</code>、或 <code>Uint8Array</code>。
对于对象模式的流， <code>chunk</code> 可以是任何 JavaScript 值，除了 <code>null</code>。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 如果 <code>chunk</code> 是字符串，则指定字符编码。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当流结束或报错时的回调函数。</li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>调用 <code>writable.end()</code> 表明已没有数据要被写入<a href="stream.html#stream_class_stream_writable">可写流</a>。
可选的 <code>chunk</code> 和 <code>encoding</code> 参数可以在关闭流之前再写入一块数据。
如果传入了 <code>callback</code> 函数，则会做为监听器添加到 <a href="stream.html#stream_event_finish"><code>'finish'</code></a> 事件和 <code>'error'</code> 事件。</p>
<p>调用 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 之后再调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 会导致错误。</p>
<pre><code class="language-js"><span class="hljs-comment">// 先写入 'hello, '，结束前再写入 'world!'。</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> file = fs.createWriteStream(<span class="hljs-string">'例子.txt'</span>);
file.write(<span class="hljs-string">'hello, '</span>);
file.end(<span class="hljs-string">'world!'</span>);
<span class="hljs-comment">// 后面不允许再写入数据！</span></code></pre>
<h6><code>writable.setDefaultEncoding(encoding)</code><span><a class="mark" href="#stream_writable_setdefaultencoding_encoding" id="stream_writable_setdefaultencoding_encoding">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_setdefaultencoding_encoding">
                <a href="stream/writable_setdefaultencoding_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.1.0</td>
<td><p>This method now returns a reference to <code>writable</code>.</p></td></tr>
<tr><td>v0.11.15</td>
<td><p><span>新增于: v0.11.15</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 默认的字符编码。</li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>writable.setDefaultEncoding()</code> 方法为<a href="stream.html#stream_class_stream_writable">可写流</a>设置默认的 <code>encoding</code>。</p>
<h6><code>writable.uncork()</code><span><a class="mark" href="#stream_writable_uncork" id="stream_writable_uncork">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_uncork">
                <a href="stream/writable_uncork.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.2</span>
</div>
<p><code>writable.uncork()</code> 方法将调用 <a href="stream.html#stream_writable_cork"><code>stream.cork()</code></a> 后缓冲的所有数据输出到目标。</p>
<p>当使用 <a href="stream.html#stream_writable_cork"><code>writable.cork()</code></a> 和 <code>writable.uncork()</code> 来管理流的写入缓冲时，建议使用 <code>process.nextTick()</code> 来延迟调用 <code>writable.uncork()</code>。
通过这种方式，可以对单个 Node.js 事件循环中调用的所有 <code>writable.write()</code> 进行批处理。</p>
<pre><code class="language-js">stream.cork();
stream.write(<span class="hljs-string">'一些 '</span>);
stream.write(<span class="hljs-string">'数据 '</span>);
process.nextTick(<span class="hljs-function">() =&gt;</span> stream.uncork());</code></pre>
<p>如果一个流上多次调用 <a href="stream.html#stream_writable_cork"><code>writable.cork()</code></a>，则必须调用同样次数的 <code>writable.uncork()</code> 才能输出缓冲的数据。</p>
<pre><code class="language-js">stream.cork();
stream.write(<span class="hljs-string">'一些 '</span>);
stream.cork();
stream.write(<span class="hljs-string">'数据 '</span>);
process.nextTick(<span class="hljs-function">() =&gt;</span> {
  stream.uncork();
  <span class="hljs-comment">// 数据不会被输出，直到第二次调用 uncork()。</span>
  stream.uncork();
});</code></pre>
<p>也可参见：<a href="stream.html#stream_writable_cork"><code>writable.cork()</code></a>。</p>
<h6><code>writable.writable</code><span><a class="mark" href="#stream_writable_writable" id="stream_writable_writable">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writable">
                <a href="stream/writable_writable.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.4.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>writable.write()</code></a> 是安全的（这意味着流没有被破坏、报错、或结束），则为 <code>true</code>。</p>
<h6><code>writable.writableEnded</code><span><a class="mark" href="#stream_writable_writableended" id="stream_writable_writableended">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writableended">
                <a href="stream/writable_writableended.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.9.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用了 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>writable.end()</code></a> 之后为 <code>true</code>。
此属性不表明数据是否已刷新，对此请使用 <a href="stream.html#stream_writable_writablefinished"><code>writable.writableFinished</code></a>。</p>
<h6><code>writable.writableCorked</code><span><a class="mark" href="#stream_writable_writablecorked" id="stream_writable_writablecorked">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writablecorked">
                <a href="stream/writable_writablecorked.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v13.2.0, v12.16.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>为了完全 uncork 流所需要调用的 <a href="stream.html#stream_writable_uncork"><code>writable.uncork()</code></a> 的次数。</p>
<h6><code>writable.writableFinished</code><span><a class="mark" href="#stream_writable_writablefinished" id="stream_writable_writablefinished">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writablefinished">
                <a href="stream/writable_writablefinished.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.6.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在触发 <a href="stream.html#stream_event_finish"><code>'finish'</code></a> 事件之前立即设置为 <code>true</code>。</p>
<h6><code>writable.writableHighWaterMark</code><span><a class="mark" href="#stream_writable_writablehighwatermark" id="stream_writable_writablehighwatermark">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writablehighwatermark">
                <a href="stream/writable_writablehighwatermark.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.3.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>返回构造可写流时传入的 <code>highWaterMark</code> 的值。</p>
<h6><code>writable.writableLength</code><span><a class="mark" href="#stream_writable_writablelength" id="stream_writable_writablelength">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writablelength">
                <a href="stream/writable_writablelength.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.4.0</span>
</div>
<p>此属性包含准备写入的队列中的字节数（或对象）。
该值提供有关 <code>highWaterMark</code> 状态的内省数据。</p>
<h6><code>writable.writableNeedDrain</code><span><a class="mark" href="#stream_writable_writableneeddrain" id="stream_writable_writableneeddrain">#</a></span></h6><p class="tip_wrap" data-item_id="writable_writableneeddrain"></p>
<div class="api_metadata">
<span>新增于: v15.2.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>Is <code>true</code> if the stream's buffer has been full and stream will emit <code>'drain'</code>.</p>
<h6><code>writable.writableObjectMode</code><span><a class="mark" href="#stream_writable_writableobjectmode" id="stream_writable_writableobjectmode">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writableobjectmode">
                <a href="stream/writable_writableobjectmode.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>获取用于给定 <code>Writable</code> 流的 <code>objectMode</code> 属性。</p>
<h6><code>writable.write(chunk[, encoding][, callback])</code><span><a class="mark" href="#stream_writable_write_chunk_encoding_callback" id="stream_writable_write_chunk_encoding_callback">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="writable_write_chunk_encoding_callback">
                <a href="stream/writable_write_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>chunk</code> argument can now be a <code>Uint8Array</code> instance.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>Passing <code>null</code> as the <code>chunk</code> parameter will always be considered invalid now, even in object mode.</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>chunk</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 要写入的数据。</li>
</ul>
<p>&nbsp;对于非对象模式的流，<code>chunk</code> 必须是字符串、<code>Buffer</code> 或 <code>Uint8Array</code>。
对于对象模式的流，<code>chunk</code> 可以是任何 JavaScript 值，除了 <code>null</code>。</p>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 如果 <code>chunk</code> 是字符串，则指定字符编码。<strong>默认值:</strong> <code>'utf8'</code>。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当数据块被输出到目标后的回调函数。</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果流需要等待 <code>'drain'</code> 事件触发才能继续写入更多数据，则返回 <code>false</code>，否则返回 <code>true</code>。</li>
</ul>
<p><code>writable.write()</code> 写入数据到流，并在数据被完全处理之后调用 <code>callback</code>。
如果发生错误，则 <code>callback</code> 可能被调用也可能不被调用。
为了可靠地检测错误，可以为 <code>'error'</code> 事件添加监听器。
<code>callback</code> 会在触发 <code>'error'</code> 之前被异步地调用。</p>
<p>在接收了 <code>chunk</code> 后，如果内部的缓冲小于创建流时配置的 <code>highWaterMark</code>，则返回 <code>true</code> 。
如果返回 <code>false</code> ，则应该停止向流写入数据，直到 <a href="stream.html#stream_event_drain"><code>'drain'</code></a> 事件被触发。</p>
<p>当流还未被排空时，调用 <code>write()</code> 会缓冲 <code>chunk</code>，并返回 <code>false</code>。
一旦所有当前缓冲的数据块都被排空了（被操作系统接收并传输），则触发 <code>'drain'</code> 事件。
建议一旦 <code>write()</code> 返回 false，则不再写入任何数据块，直到 <code>'drain'</code> 事件被触发。
当流还未被排空时，也是可以调用 <code>write()</code>，Node.js 会缓冲所有被写入的数据块，直到达到最大内存占用，这时它会无条件中止。
甚至在它中止之前， 高内存占用将会导致垃圾回收器的性能变差和 RSS 变高（即使内存不再需要，通常也不会被释放回系统）。
如果远程的另一端没有读取数据，TCP 的 socket 可能永远也不会排空，所以写入到一个不会排空的 socket 可能会导致远程可利用的漏洞。</p>
<p>对于 <a href="stream.html#stream_class_stream_transform"><code>Transform</code></a>, 写入数据到一个不会排空的流尤其成问题，因为 <code>Transform</code> 流默认会被暂停，直到它们被 pipe 或者添加了 <code>'data'</code> 或 <code>'readable'</code> 事件句柄。</p>
<p>如果要被写入的数据可以根据需要生成或者取得，建议将逻辑封装为一个<a href="stream.html#stream_class_stream_readable">可读流</a>并且使用 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a>。
如果要优先调用 <code>write()</code>，则可以使用 <a href="stream.html#stream_event_drain"><code>'drain'</code></a> 事件来防止背压与避免内存问题:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params">data, cb</span>) </span>{
  <span class="hljs-keyword">if</span> (!stream.write(data)) {
    stream.once(<span class="hljs-string">'drain'</span>, cb);
  } <span class="hljs-keyword">else</span> {
    process.nextTick(cb);
  }
}

<span class="hljs-comment">// 在回调函数被执行后再进行其他的写入。</span>
write(<span class="hljs-string">'hello'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'完成写入，可以进行更多的写入'</span>);
});</code></pre>
<p>对象模式下的可写流将会始终忽略 <code>encoding</code> 参数。</p>
<h4>可读流<span><a class="mark" href="#stream_readable_streams" id="stream_readable_streams">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="readable_streams">
                <a href="stream/readable_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>可读流是对提供数据的来源的一种抽象。</p>
<p>可读流的例子包括：</p>
<ul>
<li><a href="http.html#http_class_http_incomingmessage">客户端的 HTTP 响应</a></li>
<li><a href="http.html#http_class_http_incomingmessage">服务器的 HTTP 请求</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs 的读取流</a></li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
<li><a href="net.html#net_class_net_socket">TCP socket</a></li>
<li><a href="child_process.html#child_process_subprocess_stdout">子进程 stdout 与 stderr</a></li>
<li><a href="process.html#process_process_stdin"><code>process.stdin</code></a></li>
</ul>
<p>所有<a href="stream.html#stream_class_stream_readable">可读流</a>都实现了 <code>stream.Readable</code> 类定义的接口。</p>
<h5>两种读取模式<span><a class="mark" href="#stream_two_reading_modes" id="stream_two_reading_modes">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="two_reading_modes">
                <a href="stream/two_reading_modes.html" class="tip_trans">中英对照</a>
                </p>
<p>可读流运作于两种模式之一：流动模式（flowing）或暂停模式（paused）。
这些模式与<a href="stream.html#stream_object_mode">对象模式</a>分开。
无论是否处于流动模式或暂停模式，<a href="stream.html#stream_class_stream_readable">可读流</a>都可以处于对象模式。</p>
<ul>
<li>在流动模式中，数据自动从底层系统读取，并通过 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> 接口的事件尽可能快地被提供给应用程序。</li>
<li>在暂停模式中，必须显式调用 <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 读取数据块。</li>
</ul>
<p>所有<a href="stream.html#stream_class_stream_readable">可读流</a>都开始于暂停模式，可以通过以下方式切换到流动模式：</p>
<ul>
<li>添加 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件句柄。</li>
<li>调用 <a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> 方法。</li>
<li>调用 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> 方法将数据发送到<a href="stream.html#stream_class_stream_writable">可写流</a>。</li>
</ul>
<p>可读流可以通过以下方式切换回暂停模式：</p>
<ul>
<li>如果没有管道目标，则调用 <a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a>。</li>
<li>如果有管道目标，则移除所有管道目标。调用 <a href="stream.html#stream_readable_unpipe_destination"><code>stream.unpipe()</code></a> 可以移除多个管道目标。</li>
</ul>
<p>只有提供了消费或忽略数据的机制后，可读流才会产生数据。
如果消费的机制被禁用或移除，则可读流会停止产生数据。</p>
<p>为了向后兼容，移除 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件句柄不会自动地暂停流。
如果有管道目标，一旦目标变为 <code>drain</code> 状态并请求接收数据时，则调用 <a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> 也不能保证流会保持暂停模式。</p>
<p>如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。
例如，当调用 <code>readable.resume()</code> 时，没有监听 <code>'data'</code> 事件或 <code>'data'</code> 事件句柄已移除。</p>
<p>添加 <a href="stream.html#stream_event_readable"><code>'readable'</code></a> 事件句柄会使流自动停止流动，并通过 <a href="stream.html#stream_readable_read_size"><code>readable.read()</code></a> 消费数据。
如果 <a href="stream.html#stream_event_readable"><code>'readable'</code></a> 事件句柄被移除，且存在 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件句柄，则流会再次开始流动。</p>
<h5>三种状态<span><a class="mark" href="#stream_three_states" id="stream_three_states">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="three_states">
                <a href="stream/three_states.html" class="tip_trans">中英对照</a>
                </p>
<p>可读流的两种模式是对发生在可读流中更加复杂的内部状态管理的一种简化的抽象。</p>
<p>在任意时刻，可读流会处于以下三种状态之一：</p>
<ul>
<li><code>readable.readableFlowing === null</code></li>
<li><code>readable.readableFlowing === false</code></li>
<li><code>readable.readableFlowing === true</code></li>
</ul>
<p>当 <code>readable.readableFlowing</code> 为 <code>null</code> 时，没有提供消费流数据的机制，所以流不会产生数据。
在这个状态下，监听 <code>'data'</code> 事件、调用 <code>readable.pipe()</code>、或调用 <code>readable.resume()</code> 都会使 <code>readable.readableFlowing</code> 切换到 <code>true</code>，可读流开始主动地产生数据并触发事件。</p>
<p>调用 <code>readable.pause()</code>、<code>readable.unpipe()</code>、或接收到背压，则 <code>readable.readableFlowing</code> 会被设为 <code>false</code>，暂时停止事件流动但不会停止数据的生成。
在这个状态下，为 <code>'data'</code> 事件绑定监听器不会使 <code>readable.readableFlowing</code> 切换到&nbsp;<code>true</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { PassThrough, Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> pass = <span class="hljs-keyword">new</span> PassThrough();
<span class="hljs-keyword">const</span> writable = <span class="hljs-keyword">new</span> Writable();

pass.pipe(writable);
pass.unpipe(writable);
<span class="hljs-comment">// readableFlowing 现在为 false。</span>

pass.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> { <span class="hljs-built_in">console</span>.log(chunk.toString()); });
pass.write(<span class="hljs-string">'ok'</span>); <span class="hljs-comment">// 不会触发 'data' 事件。</span>
pass.resume(); <span class="hljs-comment">// 必须调用它才会触发 'data' 事件。</span></code></pre>
<p>当 <code>readable.readableFlowing</code> 为 <code>false</code> 时，数据可能会堆积在流的内部缓冲中。</p>
<h5>选择一种接口风格<span><a class="mark" href="#stream_choose_one_api_style" id="stream_choose_one_api_style">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="choose_one_api_style">
                <a href="stream/choose_one_api_style.html" class="tip_trans">中英对照</a>
                </p>
<p>可读流的 API 贯穿了多个 Node.js 版本，且提供了多种方法来消费流数据。
开发者通常应该选择其中一种方法来消费数据，不要在单个流使用多种方法来消费数据。
混合使用 <code>on('data')</code>、<code>on('readable')</code>、<code>pipe()</code> 或异步迭代器，会导致不明确的行为。</p>
<p>对于大多数用户，建议使用 <code>readable.pipe()</code>，因为它是消费流数据最简单的方式。
如果开发者需要精细地控制数据的传递与产生，可以使用 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a>、<code>readable.on('readable')</code>/<code>readable.read()</code> 或 <code>readable.pause()</code>/<code>readable.resume()</code>。</p>
<h5><code>stream.Readable</code> 类<span><a class="mark" href="#stream_class_stream_readable" id="stream_class_stream_readable">#</a></span></h5><p class="tip_wrap" data-item_id="class_stream_readable"></p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<!--type=class-->
<h6><code>'close'</code> 事件<span><a class="mark" href="#stream_event_close_1" id="stream_event_close_1">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_close_1">
                <a href="stream/event_close_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>当流或其底层资源（比如文件描述符）被关闭时触发 <code>'close'</code> 事件。
该事件表明不会再触发其他事件，也不会再发生操作。</p>
<p>如果使用 <code>emitClose</code> 选项创建<a href="stream.html#stream_class_stream_readable">可读流</a>，则它将会始终发出 <code>'close'</code> 事件。</p>
<h6><code>'data'</code> 事件<span><a class="mark" href="#stream_event_data" id="stream_event_data">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_data">
                <a href="stream/event_data.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 数据块。
对于非对象模式的流， <code>chunk</code> 可以是字符串或 <code>Buffer</code>。
对于对象模式的流，<code>chunk</code> 可以是任何 JavaScript 值，除了 <code>null</code>。</li>
</ul>
<p>当流将数据块传送给消费者后触发。
当调用 <code>readable.pipe()</code>，<code>readable.resume()</code> 或绑定监听器到 <code>'data'</code> 事件时，流会转换到流动模式。
当调用 <code>readable.read()</code> 且有数据块返回时，也会触发 <code>'data'</code> 事件。</p>
<p>将 <code>'data'</code> 事件监听器附加到尚未显式暂停的流将会使流切换为流动模式。
数据将会在可用时立即传递。</p>
<p>如果使用 <code>readable.setEncoding()</code> 为流指定了默认的字符编码，则监听器回调传入的数据为字符串，否则传入的数据为 <code>Buffer</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
readable.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`接收到 <span class="hljs-subst">${chunk.length}</span> 个字节的数据`</span>);
});</code></pre>
<h6><code>'end'</code> 事件<span><a class="mark" href="#stream_event_end" id="stream_event_end">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_end">
                <a href="stream/event_end.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>当流中没有数据可供消费时触发。</p>
<p><code>'end'</code> 事件只有在数据被完全消费掉后才会触发。
要想触发该事件，可以将流转换到流动模式，或反复调用 <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 直到数据被消费完。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
readable.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`接收到 <span class="hljs-subst">${chunk.length}</span> 个字节的数据`</span>);
});
readable.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'已没有数据'</span>);
});</code></pre>
<h6><code>'error'</code> 事件<span><a class="mark" href="#stream_event_error_1" id="stream_event_error_1">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_error_1">
                <a href="stream/event_error_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
</ul>
<p><code>'error'</code> 事件可能随时由 <code>Readable</code> 实现触发。
通常，如果底层的流由于底层内部的故障而无法生成数据，或者流的实现尝试推送无效的数据块，则可能会发生这种情况。</p>
<p>监听器回调将会传入一个 <code>Error</code> 对象。</p>
<h6><code>'pause'</code> 事件<span><a class="mark" href="#stream_event_pause" id="stream_event_pause">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_pause">
                <a href="stream/event_pause.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>当调用 <a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> 并且 <code>readsFlowing</code> 不为 <code>false</code> 时，就会触发 <code>'pause'</code> 事件。</p>
<h6><code>'readable'</code> 事件<span><a class="mark" href="#stream_event_readable" id="stream_event_readable">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_readable">
                <a href="stream/event_readable.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>The <code>'readable'</code> is always emitted in the next tick after <code>.push()</code> is called.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>Using <code>'readable'</code> requires calling <code>.read()</code>.</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<p>当有数据可从流中读取时，就会触发 <code>'readable'</code> 事件。
在某些情况下，为 <code>'readable'</code> 事件附加监听器将会导致将一些数据读入内部缓冲区。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
readable.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// 有数据可读取。</span>
  <span class="hljs-keyword">let</span> data;

  <span class="hljs-keyword">while</span> (data = <span class="hljs-built_in">this</span>.read()) {
    <span class="hljs-built_in">console</span>.log(data);
  }
});</code></pre>
<p>当到达流数据的尽头时，<code>'readable'</code> 事件也会触发，但是在 <code>'end'</code> 事件之前触发。</p>
<p><code>'readable'</code> 事件表明流有新的动态：要么有新的数据，要么到达流的尽头。
对于前者，<a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 会返回可用的数据。
对于后者，<a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 会返回 <code>null</code>。
例如，下面的例子中，<code>foo.txt</code> 是一个空文件：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> rr = fs.createReadStream(<span class="hljs-string">'foo.txt'</span>);
rr.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`读取的数据: <span class="hljs-subst">${rr.read()}</span>`</span>);
});
rr.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'结束'</span>);
});</code></pre>
<p>运行上面的脚本输出如下：</p>
<pre><code class="language-console"><span class="hljs-meta">$</span><span class="bash"> node test.js</span>
读取的数据: null
结束</code></pre>
<p>通常情况下，<code>readable.pipe()</code> 和 <code>'data'</code> 事件的机制比 <code>'readable'</code> 事件更容易理解。
处理 <code>'readable'</code> 事件可能造成吞吐量升高。</p>
<p>如果同时使用 <code>'readable'</code> 事件和 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件，则 <code>'readable'</code> 事件会优先控制流，也就是说，当调用 <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> 时才会触发 <code>'data'</code> 事件。
<code>readableFlowing</code> 属性会变成 <code>false</code>。
当移除 <code>'readable'</code> 事件时，如果存在 <code>'data'</code> 事件监听器，则流会开始流动，也就是说，无需调用 <code>.resume()</code> 也会触发 <code>'data'</code> 事件。</p>
<h6><code>'resume'</code> 事件<span><a class="mark" href="#stream_event_resume" id="stream_event_resume">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="event_resume">
                <a href="stream/event_resume.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<p>当调用 <a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> 并且 <code>readsFlowing</code> 不为 <code>true</code> 时，将会触发 <code>'resume'</code> 事件。</p>
<h6><code>readable.destroy([error])</code><span><a class="mark" href="#stream_readable_destroy_error" id="stream_readable_destroy_error">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_destroy_error">
                <a href="stream/readable_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>Work as a no-op on a stream that has already been destroyed.</p></td></tr>
<tr><td>v8.0.0</td>
<td><p><span>新增于: v8.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>error</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> 将会在 <code>'error'</code> 事件中作为负载传入的错误。</li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁流。
可选地触发 <code>'error'</code> 事件，并触发 <code>'close'</code> 事件（除非将 <code>emitClose</code> 设置为 <code>false</code>）。
在此调用之后，可读流将会释放所有内部的资源，并且将会忽略对 <code>push()</code> 的后续调用。</p>
<p>一旦调用 <code>destroy()</code>，则不会再执行任何其他操作，并且除了 <code>_destroy()</code> 以外的其他错误都不会作为 <code>'error'</code> 触发。</p>
<p>实现者不应该重写此方法，而应该实现 <a href="stream.html#stream_readable_destroy_err_callback"><code>readable._destroy()</code></a>。</p>
<h6><code>readable.destroyed</code><span><a class="mark" href="#stream_readable_destroyed" id="stream_readable_destroyed">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_destroyed">
                <a href="stream/readable_destroyed.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>在调用 <a href="stream.html#stream_readable_destroy_error"><code>readable.destroy()</code></a> 之后为 <code>true</code>。</p>
<h6><code>readable.isPaused()</code><span><a class="mark" href="#stream_readable_ispaused" id="stream_readable_ispaused">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_ispaused">
                <a href="stream/readable_ispaused.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul>
<li>返回： <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p><code>readable.isPaused()</code> 方法返回可读流当前的操作状态。
主要用于 <code>readable.pipe()</code> 底层的机制。
大多数情况下无需直接使用该方法。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = <span class="hljs-keyword">new</span> stream.Readable();

readable.isPaused(); <span class="hljs-comment">// === false</span>
readable.pause();
readable.isPaused(); <span class="hljs-comment">// === true</span>
readable.resume();
readable.isPaused(); <span class="hljs-comment">// === false</span></code></pre>
<h6><code>readable.pause()</code><span><a class="mark" href="#stream_readable_pause" id="stream_readable_pause">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_pause">
                <a href="stream/readable_pause.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.pause()</code> 方法使流动模式的流停止触发 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件，并切换出流动模式。
任何可用的数据都会保留在内部缓存中。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
readable.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`接收到 <span class="hljs-subst">${chunk.length}</span> 字节的数据`</span>);
  readable.pause();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'暂停一秒'</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据重新开始流动'</span>);
    readable.resume();
  }, <span class="hljs-number">1000</span>);
});</code></pre>
<p>如果存在 <code>'readable'</code> 事件监听器，则 <code>readable.pause()</code> 方法不起作用。</p>
<h6><code>readable.pipe(destination[, options])</code><span><a class="mark" href="#stream_readable_pipe_destination_options" id="stream_readable_pipe_destination_options">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_pipe_destination_options">
                <a href="stream/readable_pipe_destination_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>destination</code> <a href="stream.html#stream_class_stream_writable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a> 数据写入的目标。</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 管道选项。
<ul>
<li><code>end</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 当读取器结束时终止写入器。<strong>默认值:</strong> <code>true</code>。</li>
</ul>
</li>
<li>返回: <a href="stream.html#stream_class_stream_writable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a> 目标可写流，如果是 <a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> 流或 <a href="stream.html#stream_class_stream_transform"><code>Transform</code></a> 流则可以形成管道链。</li>
</ul>
<p><code>readable.pipe()</code> 方法绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。
数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。</p>
<p>例子，将可读流的所有数据通过管道推送到 <code>file.txt</code> 文件：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
<span class="hljs-keyword">const</span> writable = fs.createWriteStream(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-comment">// readable 的所有数据都推送到 'file.txt'。</span>
readable.pipe(writable);</code></pre>
<p>可以在单个可读流上绑定多个可写流。</p>
<p><code>readable.pipe()</code> 会返回目标流的引用，这样就可以对流进行链式地管道操作：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> r = fs.createReadStream(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-keyword">const</span> z = zlib.createGzip();
<span class="hljs-keyword">const</span> w = fs.createWriteStream(<span class="hljs-string">'file.txt.gz'</span>);
r.pipe(z).pipe(w);</code></pre>
<p>默认情况下，当来源可读流触发 <a href="stream.html#stream_event_end"><code>'end'</code></a> 事件时，目标可写流也会调用 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 结束写入。
若要禁用这种默认行为，<code>end</code> 选项应设为 <code>false</code>，这样目标流就会保持打开：</p>
<pre><code class="language-js">reader.pipe(writer, { <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> });
reader.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  writer.end(<span class="hljs-string">'结束'</span>);
});</code></pre>
<p>如果可读流在处理期间发送错误，则可写流目标不会自动关闭。
如果发生错误，则需要手动关闭每个流以防止内存泄漏。</p>
<p><a href="process.html#process_process_stderr"><code>process.stderr</code></a> 和 <a href="process.html#process_process_stdout"><code>process.stdout</code></a> 可写流在 Node.js 进程退出之前永远不会关闭，无论指定的选项如何。</p>
<h6><code>readable.read([size])</code><span><a class="mark" href="#stream_readable_read_size" id="stream_readable_read_size">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_read_size">
                <a href="stream/readable_read_size.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要读取的数据的字节数。</li>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>从内部缓冲拉取并返回数据。
如果没有可读的数据，则返回 <code>null</code>。
默认情况下，<code>readable.read()</code> 返回的数据是 <code>Buffer</code> 对象，除非使用 <code>readable.setEncoding()</code> 指定字符编码或流处于对象模式。</p>
<p>可选的 <code>size</code> 参数指定要读取的特定字节数。
如果无法读取 <code>size</code> 个字节，则除非流已结束，否则将会返回 <code>null</code>，在这种情况下，将会返回内部 buffer 中剩余的所有数据。</p>
<p>如果没有指定 <code>size</code> 参数，则返回内部缓冲中的所有数据。</p>
<p><code>size</code> 参数必须小于或等于 1 GiB。</p>
<p><code>readable.read()</code> 应该只对处于暂停模式的可读流调用。
在流动模式中，<code>readable.read()</code> 会自动调用直到内部缓冲的数据完全耗尽。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();

<span class="hljs-comment">// 'readable' may be triggered multiple times as data is buffered in</span>
readable.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> chunk;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Stream is readable (new data received in buffer)'</span>);
  <span class="hljs-comment">// Use a loop to make sure we read all currently available data</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = readable.read())) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`读取 <span class="hljs-subst">${chunk.length}</span> 字节的数据`</span>);
  }
});

<span class="hljs-comment">// 'end' will be triggered once when there is no more data available</span>
readable.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Reached end of stream.'</span>);
});</code></pre>
<p>Each call to <code>readable.read()</code> returns a chunk of data, or <code>null</code>. The chunks
are not concatenated. A <code>while</code> loop is necessary to consume all data
currently in the buffer. When reading a large file <code>.read()</code> may return <code>null</code>,
having consumed all buffered content so far, but there is still more data to
come not yet buffered. In this case a new <code>'readable'</code> event will be emitted
when there is more data in the buffer. Finally the <code>'end'</code> event will be
emitted when there is no more data to come.</p>
<p>Therefore to read a file's whole contents from a <code>readable</code>, it is necessary
to collect chunks across multiple <code>'readable'</code> events:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> chunks = [];

readable.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> chunk;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = readable.read())) {
    chunks.push(chunk);
  }
});

readable.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> content = chunks.join(<span class="hljs-string">''</span>);
});</code></pre>
<p>使用 <code>readable.read()</code> 处理数据时，<code>while</code> 循环是必需的。
只有在 <code>readable.read()</code> 返回 <code>null</code> 之后，才会触发 <a href="stream.html#stream_event_readable"><code>'readable'</code></a>。</p>
<p>对象模式下的可读流将会始终从调用 <a href="stream.html#stream_readable_read_size"><code>readable.read(size)</code></a> 返回单个子项，而不管 <code>size</code> 参数的值如何。</p>
<p>如果 <code>readable.read()</code> 返回一个数据块，则 <code>'data'</code> 事件也会触发。</p>
<p>在 <a href="stream.html#stream_event_end"><code>'end'</code></a> 事件触发后再调用 <a href="stream.html#stream_readable_read_size"><code>stream.read([size])</code></a> 会返回 <code>null</code>。
不会引发运行时错误。</p>
<h6><code>readable.readable</code><span><a class="mark" href="#stream_readable_readable" id="stream_readable_readable">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_readable">
                <a href="stream/readable_readable.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.4.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果可以安全地调用 <a href="stream.html#stream_readable_read_size"><code>readable.read()</code></a>（这意味着流没有被破坏或触发 <code>'error'</code> 或 <code>'end'</code>），则为 <code>true</code>。</p>
<h6><code>readable.readableEncoding</code><span><a class="mark" href="#stream_readable_readableencoding" id="stream_readable_readableencoding">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_readableencoding">
                <a href="stream/readable_readableencoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.7.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>获取用于给定可读流的 <code>encoding</code> 属性。
可以使用 <a href="stream.html#stream_readable_setencoding_encoding"><code>readable.setEncoding()</code></a> 方法设置 <code>encoding</code> 属性。</p>
<h6><code>readable.readableEnded</code><span><a class="mark" href="#stream_readable_readableended" id="stream_readable_readableended">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_readableended">
                <a href="stream/readable_readableended.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.9.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>当 <a href="stream.html#stream_event_end"><code>'end'</code></a> 事件被触发时变为 <code>true</code>。</p>
<h6><code>readable.readableFlowing</code><span><a class="mark" href="#stream_readable_readableflowing" id="stream_readable_readableflowing">#</a></span></h6><p class="tip_wrap" data-item_id="readable_readableflowing"></p>
<div class="api_metadata">
<span>新增于: v9.4.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>This property reflects the current state of a <code>Readable</code> stream as described
in the <a href="stream.html#stream_three_states">Three states</a> section.</p>
<h6><code>readable.readableHighWaterMark</code><span><a class="mark" href="#stream_readable_readablehighwatermark" id="stream_readable_readablehighwatermark">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_readablehighwatermark">
                <a href="stream/readable_readablehighwatermark.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.3.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>返回构造可读流时传入的 <code>highWaterMark</code> 的值。</p>
<h6><code>readable.readableLength</code><span><a class="mark" href="#stream_readable_readablelength" id="stream_readable_readablelength">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_readablelength">
                <a href="stream/readable_readablelength.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v9.4.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
<p>此属性包含准备读取的队列中的字节数（或对象数）。
该值提供有关 <code>highWaterMark</code> 状态的内省数据。</p>
<h6><code>readable.readableObjectMode</code><span><a class="mark" href="#stream_readable_readableobjectmode" id="stream_readable_readableobjectmode">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_readableobjectmode">
                <a href="stream/readable_readableobjectmode.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>获取用于给定可读流的 <code>objectMode</code> 属性。</p>
<h6><code>readable.resume()</code><span><a class="mark" href="#stream_readable_resume" id="stream_readable_resume">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_resume">
                <a href="stream/readable_resume.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v10.0.0</td>
<td><p>The <code>resume()</code> has no effect if there is a <code>'readable'</code> event listening.</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.resume()</code> 方法将被暂停的可读流恢复触发 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件，并将流切换到流动模式。</p>
<p><code>readable.resume()</code> 方法可以用来充分消耗流中的数据，但无需实际处理任何数据：</p>
<pre><code class="language-js">getReadableStreamSomehow()
  .resume()
  .on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'到达流的尽头，但无需读取任何数据'</span>);
  });</code></pre>
<p>当存在 <code>'readable'</code> 事件监听器时，<code>readable.resume()</code> 方法不起作用。</p>
<h6><code>readable.setEncoding(encoding)</code><span><a class="mark" href="#stream_readable_setencoding_encoding" id="stream_readable_setencoding_encoding">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_setencoding_encoding">
                <a href="stream/readable_setencoding_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 字符编码。</li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.setEncoding()</code> 方法为从可读流读取的数据设置字符编码。</p>
<p>默认情况下没有设置字符编码，流数据返回的是 <code>Buffer</code> 对象。
如果设置了字符编码，则流数据返回指定编码的字符串。
例如，调用 <code>readable.setEncoding('utf-8')</code> 会将数据解析为 UTF-8 数据，并返回字符串，调用 <code>readable.setEncoding('hex')</code> 则会将数据编码成十六进制字符串。</p>
<p>可读流将会正确地处理通过流传递的多字节字符，否则如果简单地从流中作为 <code>Buffer</code> 对象拉出，则会被不正确地解码。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
readable.setEncoding(<span class="hljs-string">'utf8'</span>);
readable.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  assert.equal(<span class="hljs-keyword">typeof</span> chunk, <span class="hljs-string">'string'</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'读取到 %d 个字符的字符串数据'</span>, chunk.length);
});</code></pre>
<h6><code>readable.unpipe([destination])</code><span><a class="mark" href="#stream_readable_unpipe_destination" id="stream_readable_unpipe_destination">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_unpipe_destination">
                <a href="stream/readable_unpipe_destination.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>destination</code> <a href="stream.html#stream_class_stream_writable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a> 要移除管道的可写流。</li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p><code>readable.unpipe()</code> 方法解绑之前使用 <a href="stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> 方法绑定的可写流。</p>
<p>如果没有指定 <code>destination</code>, 则解绑所有管道.</p>
<p>如果指定了 <code>destination</code>, 但它没有建立管道，则不起作用.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> readable = getReadableStreamSomehow();
<span class="hljs-keyword">const</span> writable = fs.createWriteStream(<span class="hljs-string">'file.txt'</span>);
<span class="hljs-comment">// 可读流的所有数据开始传输到 'file.txt'，但一秒后停止。</span>
readable.pipe(writable);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'停止写入 file.txt'</span>);
  readable.unpipe(writable);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'手动关闭文件流'</span>);
  writable.end();
}, <span class="hljs-number">1000</span>);</code></pre>
<h6><code>readable.unshift(chunk[, encoding])</code><span><a class="mark" href="#stream_readable_unshift_chunk_encoding" id="stream_readable_unshift_chunk_encoding">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_unshift_chunk_encoding">
                <a href="stream/readable_unshift_chunk_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>chunk</code> argument can now be a <code>Uint8Array</code> instance.</p></td></tr>
<tr><td>v0.9.11</td>
<td><p><span>新增于: v0.9.11</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 要推回可读队列的数据块。
对于非对象模式的流，<code>chunk</code> 必须是字符串、<code>Buffer</code>、<code>Uint8Array</code> 或 <code>null</code>。
对于对象模式的流，<code>chunk</code> 可以是任何 JavaScript 值。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 字符串块的编码。 必须是有效的 <code>Buffer</code> 编码，例如 <code>'utf8'</code> 或 <code>'ascii'</code>。</li>
</ul>
<p>将 <code>chunk</code> 作为 <code>null</code> 传递信号表示流的末尾（EOF），其行为与 <code>readable.push(null)</code> 相同，之后不能再写入数据。
EOF 信号会被放在 buffer 的末尾，任何缓冲的数据仍将会被刷新。</p>
<p><code>readable.unshift()</code> 方法将数据块推回内部缓冲。
可用于以下情景：正被消费中的流需要将一些已经被拉出的数据重置为未消费状态，以便这些数据可以传给其他方。</p>
<p>触发 <a href="stream.html#stream_event_end"><code>'end'</code></a> 事件或抛出运行时错误之后，不能再调用 <code>stream.unshift()</code> 方法。</p>
<p>使用 <code>stream.unshift()</code> 的开发者可以考虑切换到 <a href="stream.html#stream_class_stream_transform"><code>Transform</code></a> 流。
详见<a href="stream.html#stream_api_for_stream_implementers">用于实现流的API</a>。</p>
<pre><code class="language-js"><span class="hljs-comment">// 拉出由 \n\n 分隔的标题。</span>
<span class="hljs-comment">// 如果获取太多，则使用 unshift()。</span>
<span class="hljs-comment">// 使用 (error, header, stream) 调用回调。</span>
<span class="hljs-keyword">const</span> { StringDecoder } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'string_decoder'</span>);
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseHeader</span>(<span class="hljs-params">stream, callback</span>) </span>{
  stream.on(<span class="hljs-string">'error'</span>, callback);
  stream.on(<span class="hljs-string">'readable'</span>, onReadable);
  <span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> StringDecoder(<span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">let</span> header = <span class="hljs-string">''</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onReadable</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> chunk;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = stream.read())) {
      <span class="hljs-keyword">const</span> str = decoder.write(chunk);
      <span class="hljs-keyword">if</span> (str.match(<span class="hljs-regexp">/\n\n/</span>)) {
        <span class="hljs-comment">// 发现头部边界。</span>
        <span class="hljs-keyword">const</span> split = str.split(<span class="hljs-regexp">/\n\n/</span>);
        header += split.shift();
        <span class="hljs-keyword">const</span> remaining = split.join(<span class="hljs-string">'\n\n'</span>);
        <span class="hljs-keyword">const</span> buf = Buffer.from(remaining, <span class="hljs-string">'utf8'</span>);
        stream.removeListener(<span class="hljs-string">'error'</span>, callback);
        <span class="hljs-comment">// 在调用 unshift() 前移除 'readable' 监听器。</span>
        stream.removeListener(<span class="hljs-string">'readable'</span>, onReadable);
        <span class="hljs-keyword">if</span> (buf.length)
          stream.unshift(buf);
        <span class="hljs-comment">// 现在可以从流中读取消息的主体。</span>
        callback(<span class="hljs-literal">null</span>, header, stream);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 继续读取头部。</span>
        header += str;
      }
    }
  }
}</code></pre>
<p>与 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a> 不同，<code>stream.unshift(chunk)</code> 不会通过重置流的内部读取状态来结束读取过程。
如果在读取期间调用 <code>readable.unshift()</code>（即从自定义的流上的 <a href="stream.html#stream_readable_read_size_1"><code>stream._read()</code></a> 实现中调用），则会导致意外结果。
在使用立即的 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push('')</code></a> 调用 <code>readable.unshift()</code> 之后，将适当地重置读取状态，但最好在执行读取的过程中避免调用 <code>readable.unshift()</code>。</p>
<h6><code>readable.wrap(stream)</code><span><a class="mark" href="#stream_readable_wrap_stream" id="stream_readable_wrap_stream">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_wrap_stream">
                <a href="stream/readable_wrap_stream.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>stream</code> <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream&gt;</a> 老版本的可读流。</li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>在 Node.js v0.10 之前，流没有实现当前定义的所有的流模块 API。（详见<a href="stream.html#stream_compatibility_with_older_node_js_versions">兼容性</a>）</p>
<p>当使用老版本的 Node.js 时，只能触发 <a href="stream.html#stream_event_data"><code>'data'</code></a> 事件或调用 <a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> 方法，可以使用 <code>readable.wrap()</code> 创建老版本的流作为数据源。</p>
<p>现在几乎无需使用 <code>readable.wrap()</code>，该方法主要用于老版本的 Node.js 应用和库。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { OldReader } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./old-api-module.js'</span>);
<span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> oreader = <span class="hljs-keyword">new</span> OldReader();
<span class="hljs-keyword">const</span> myReader = <span class="hljs-keyword">new</span> Readable().wrap(oreader);

myReader.on(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  myReader.read(); <span class="hljs-comment">// 各种操作。</span>
});</code></pre>
<h6><code>readable[Symbol.asyncIterator]()</code><span><a class="mark" href="#stream_readable_symbol_asynciterator" id="stream_readable_symbol_asynciterator">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="readable_symbol_asynciterator">
                <a href="stream/readable_symbol_asynciterator.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v11.14.0</td>
<td><p>Symbol.asyncIterator support is no longer experimental.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>新增于: v10.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/HnG4ws" rel="nofollow" class="type">&lt;AsyncIterator&gt;</a> 用于完全地消费流。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">readable</span>) </span>{
  readable.setEncoding(<span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable) {
    data += chunk;
  }
  <span class="hljs-built_in">console</span>.log(data);
}

print(fs.createReadStream(<span class="hljs-string">'file'</span>)).catch(<span class="hljs-built_in">console</span>.error);</code></pre>
<p>如果循环以 <code>break</code> 或 <code>throw</code> 终止，则流将会被销毁。
换句话说，迭代流将完全地消费流。
将以大小等于 <code>highWaterMark</code> 选项的块读取流。
在上面的代码示例中，如果文件的数据少于 64KB，则数据将位于单个块中，因为没有为 <a href="fs.html#fs_fs_createreadstream_path_options"><code>fs.createReadStream()</code></a> 提供 <code>highWaterMark</code> 选项。</p>
<h6><code>readable.iterator([options])</code><span><a class="mark" href="#stream_readable_iterator_options" id="stream_readable_iterator_options">#</a></span></h6><p class="tip_wrap" data-item_id="readable_iterator_options"></p>
<div class="api_metadata">
<span>新增于: v16.3.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#documentation_stability_index">稳定性: 1</a> - 实验</div><p></p>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>destroyOnReturn</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> When set to <code>false</code>, calling <code>return</code> on the
async iterator, or exiting a <code>for await...of</code> iteration using a <code>break</code>,
<code>return</code>, or <code>throw</code> will not destroy the stream. <strong>默认值:</strong> <code>true</code>。</li>
<li><code>destroyOnError</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> When set to <code>false</code>, if the stream emits an
error while it's being iterated, the iterator will not destroy the stream.
<strong>默认值:</strong> <code>true</code>。</li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/HnG4ws" rel="nofollow" class="type">&lt;AsyncIterator&gt;</a> to consume the stream.</li>
</ul>
<p>The iterator created by this method gives users the option to cancel the
destruction of the stream if the <code>for await...of</code> loop is exited by <code>return</code>,
<code>break</code>, or <code>throw</code>, or if the iterator should destroy the stream if the stream
emitted an error during iteration.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printIterator</span>(<span class="hljs-params">readable</span>) </span>{
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable.iterator({ <span class="hljs-attr">destroyOnReturn</span>: <span class="hljs-literal">false</span> })) {
    <span class="hljs-built_in">console</span>.log(chunk); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-built_in">console</span>.log(readable.destroyed); <span class="hljs-comment">// false</span>

  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable.iterator({ <span class="hljs-attr">destroyOnReturn</span>: <span class="hljs-literal">false</span> })) {
    <span class="hljs-built_in">console</span>.log(chunk); <span class="hljs-comment">// Will print 2 and then 3</span>
  }

  <span class="hljs-built_in">console</span>.log(readable.destroyed); <span class="hljs-comment">// True, stream was totally consumed</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printSymbolAsyncIterator</span>(<span class="hljs-params">readable</span>) </span>{
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable) {
    <span class="hljs-built_in">console</span>.log(chunk); <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">break</span>;
  }

  <span class="hljs-built_in">console</span>.log(readable.destroyed); <span class="hljs-comment">// true</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showBoth</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> printIterator(Readable.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
  <span class="hljs-keyword">await</span> printSymbolAsyncIterator(Readable.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
}

showBoth();</code></pre>
<h4>双工流与转换流<span><a class="mark" href="#stream_duplex_and_transform_streams" id="stream_duplex_and_transform_streams">#</a></span></h4>
<h5><code>stream.Duplex</code> 类<span><a class="mark" href="#stream_class_stream_duplex" id="stream_class_stream_duplex">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="class_stream_duplex">
                <a href="stream/class_stream_duplex.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v6.8.0</td>
<td><p>Instances of <code>Duplex</code> now return <code>true</code> when checking <code>instanceof stream.Writable</code>.</p></td></tr>
<tr><td>v0.9.4</td>
<td><p><span>新增于: v0.9.4</span></p></td></tr>
</tbody></table>
</details>
</div>
<!--type=class-->
<p>双工流（Duplex）是同时实现了 <a href="stream.html#stream_class_stream_readable"><code>Readable</code></a> 和 <a href="stream.html#stream_class_stream_writable"><code>Writable</code></a> 接口的流。</p>
<p><code>Duplex</code> 流的例子包括：</p>
<ul>
<li><a href="net.html#net_class_net_socket">TCP socket</a></li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h5><code>stream.Transform</code> 类<span><a class="mark" href="#stream_class_stream_transform" id="stream_class_stream_transform">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="class_stream_transform">
                <a href="stream/class_stream_transform.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<!--type=class-->
<p>转换流（Transform）是一种 <a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> 流，但它的输出与输入是相关联的。
与 <a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a> 流一样，<code>Transform</code> 流也同时实现了 <a href="stream.html#stream_class_stream_readable"><code>Readable</code></a> 和 <a href="stream.html#stream_class_stream_writable"><code>Writable</code></a> 接口。</p>
<p><code>Transform</code> 流的例子包括：</p>
<ul>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h6><code>transform.destroy([error])</code><span><a class="mark" href="#stream_transform_destroy_error" id="stream_transform_destroy_error">#</a></span></h6><p class="tip_wrap" data-show_trans="1" data-item_id="transform_destroy_error">
                <a href="stream/transform_destroy_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>Work as a no-op on a stream that has already been destroyed.</p></td></tr>
<tr><td>v8.0.0</td>
<td><p><span>新增于: v8.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>error</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/v7Fsu2" rel="nofollow" class="type">&lt;this&gt;</a></li>
</ul>
<p>销毁流，并可选地触发 <code>'error'</code> 事件。
调用该方法后，transform 流会释放全部内部资源。
实现者不应该重写此方法，而应该实现 <a href="stream.html#stream_readable_destroy_err_callback"><code>readable._destroy()</code></a>。
<code>Transform</code> 流的 <code>_destroy()</code> 方法的默认实现会触发 <code>'close'</code> 事件，除非 <code>emitClose</code> 被设置为 <code>false</code>。</p>
<p>一旦调用 <code>destroy()</code>，则不会再执行任何其他操作，并且除了 <code>_destroy()</code> 以外的其他错误都不会作为 <code>'error'</code> 触发。</p>
<h4><code>stream.finished(stream[, options], callback)</code><span><a class="mark" href="#stream_stream_finished_stream_options_callback" id="stream_stream_finished_stream_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="stream_finished_stream_options_callback">
                <a href="stream/stream_finished_stream_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>The <code>finished(stream, cb)</code> will wait for the <code>'close'</code> event before invoking the callback. The implementation tries to detect legacy streams and only apply this behavior to streams which are expected to emit <code>'close'</code>.</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>Emitting <code>'close'</code> before <code>'end'</code> on a <code>Readable</code> stream will cause an <code>ERR_STREAM_PREMATURE_CLOSE</code> error.</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>Callback will be invoked on streams which have already finished before the call to <code>finished(stream, cb)</code>.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>新增于: v10.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>stream</code> <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream&gt;</a> 可读和/或可写流。</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>error</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果设置为 <code>false</code>，则对 <code>emit('error', err)</code> 的调用不会被视为已完成。 <strong>默认值</strong>: <code>true</code>。</li>
<li><code>readable</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 当设置为 <code>false</code> 时，即使流可能仍然可读，当流结束时也将会调用回调。<strong>默认值</strong>: <code>true</code>。</li>
<li><code>writable</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 当设置为 <code>false</code> 时，即使流可能仍然可写，当流结束时也将会调用回调。<strong>默认值</strong>: <code>true</code>。</li>
</ul>
</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 带有可选错误参数的回调函数。</li>
<li>返回: <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 清理函数，它会移除所有已注册的监听器。</li>
</ul>
<p>当流不再可读、可写、或遇到错误、或过早关闭事件时，则该函数会获得通知。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { finished } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> rs = fs.createReadStream(<span class="hljs-string">'archive.tar'</span>);

finished(rs, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'流读取失败'</span>, err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'流已完成读取'</span>);
  }
});

rs.resume(); <span class="hljs-comment">// 排空流。</span></code></pre>
<p>在错误处理场景中特别有用，该场景中的流会被过早地销毁（例如被终止的 HTTP 请求），并且不会触发 <code>'end'</code> 或 <code>'finish'</code> 事件。</p>
<p><code>finished</code> API 也可以 promise 化：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> finished = util.promisify(stream.finished);

<span class="hljs-keyword">const</span> rs = fs.createReadStream(<span class="hljs-string">'archive.tar'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> finished(rs);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'流已完成读取'</span>);
}

run().catch(<span class="hljs-built_in">console</span>.error);
rs.resume(); <span class="hljs-comment">// 排空流。</span></code></pre>
<p>在调用 <code>callback</code> 之后，<code>stream.finished()</code> 会留下悬挂的事件监听器（特别是 <code>'error'</code>、<code>'end'</code>、<code>'finish'</code> 和 <code>'close'</code>）。
这样做的原因是，意外的 <code>'error'</code> 事件（由于错误的流实现）不会导致意外的崩溃。
如果这是不想要的行为，则需要在回调中调用返回的清理函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> cleanup = finished(rs, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  cleanup();
  <span class="hljs-comment">// ...</span>
});</code></pre>
<h4><code>stream.pipeline(source[, ...transforms], destination, callback)</code><span><a class="mark" href="#stream_stream_pipeline_source_transforms_destination_callback" id="stream_stream_pipeline_source_transforms_destination_callback">#</a></span></h4>
<h4><code>stream.pipeline(streams, callback)</code><span><a class="mark" href="#stream_stream_pipeline_streams_callback" id="stream_stream_pipeline_streams_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="stream_pipeline_streams_callback">
                <a href="stream/stream_pipeline_streams_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>The <code>pipeline(..., cb)</code> will wait for the <code>'close'</code> event before invoking the callback. The implementation tries to detect legacy streams and only apply this behavior to streams which are expected to emit <code>'close'</code>.</p></td></tr>
<tr><td>v13.10.0</td>
<td><p>Add support for async generators.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p><span>新增于: v10.0.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>streams</code> <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream[]&gt;</a> | <a href="http://url.nodejs.cn/mQfCyy" rel="nofollow" class="type">&lt;Iterable[]&gt;</a> | <a href="http://url.nodejs.cn/7jqJ5Y" rel="nofollow" class="type">&lt;AsyncIterable[]&gt;</a> | <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function[]&gt;</a></li>
<li><code>source</code> <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream&gt;</a> | <a href="http://url.nodejs.cn/mQfCyy" rel="nofollow" class="type">&lt;Iterable&gt;</a> | <a href="http://url.nodejs.cn/7jqJ5Y" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a> | <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li>返回: <a href="http://url.nodejs.cn/mQfCyy" rel="nofollow" class="type">&lt;Iterable&gt;</a> | <a href="http://url.nodejs.cn/7jqJ5Y" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
</ul>
</li>
<li><code>...transforms</code> <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream&gt;</a> | <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>source</code> <a href="http://url.nodejs.cn/7jqJ5Y" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/7jqJ5Y" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
</ul>
</li>
<li><code>destination</code> <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream&gt;</a> | <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a>
<ul>
<li><code>source</code> <a href="http://url.nodejs.cn/7jqJ5Y" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/7jqJ5Y" rel="nofollow" class="type">&lt;AsyncIterable&gt;</a> | <a href="http://url.nodejs.cn/ri1kj8" rel="nofollow" class="type">&lt;Promise&gt;</a></li>
</ul>
</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当管道完全地完成时调用。
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
<li><code>val</code> <code>destination</code> 返回的 <code>Promise</code> 的 resolve 的值。</li>
</ul>
</li>
<li>返回: <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream&gt;</a></li>
</ul>
<p>一个模块方法，使用管道传送多个流和生成器，并转发错误和正确地清理，当管道完成时提供回调。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>);

<span class="hljs-comment">// 使用 pipeline API 轻松地将一系列的流通过管道一起传送，并在管道完全地完成时获得通知。</span>

<span class="hljs-comment">// 使用 pipeline 可以有效地压缩一个可能很大的 tar 文件：</span>

pipeline(
  fs.createReadStream(<span class="hljs-string">'archive.tar'</span>),
  zlib.createGzip(),
  fs.createWriteStream(<span class="hljs-string">'archive.tar.gz'</span>),
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'管道传送失败'</span>, err);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'管道传送成功'</span>);
    }
  }
);</code></pre>
<p><code>pipeline</code> API 也可以 promise 化：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> pipeline = util.promisify(stream.pipeline);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> pipeline(
    fs.createReadStream(<span class="hljs-string">'archive.tar'</span>),
    zlib.createGzip(),
    fs.createWriteStream(<span class="hljs-string">'archive.tar.gz'</span>)
  );
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'管道传送成功'</span>);
}

run().catch(<span class="hljs-built_in">console</span>.error);</code></pre>
<p><code>pipeline</code> API 还支持异步的生成器：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> pipeline = util.promisify(stream.pipeline);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> pipeline(
    fs.createReadStream(<span class="hljs-string">'lowercase.txt'</span>),
    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">source</span>) </span>{
      source.setEncoding(<span class="hljs-string">'utf8'</span>);  <span class="hljs-comment">// Work with strings rather than `Buffer`s.</span>
      <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> source) {
        <span class="hljs-keyword">yield</span> chunk.toUpperCase();
      }
    },
    fs.createWriteStream(<span class="hljs-string">'uppercase.txt'</span>)
  );
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Pipeline 成功'</span>);
}

run().catch(<span class="hljs-built_in">console</span>.error);</code></pre>
<p><code>stream.pipeline()</code> 将会在所有的流上调用 <code>stream.destroy(err)</code>，除了：</p>
<ul>
<li>已触发 <code>'end'</code> 或 <code>'close'</code> 的 <code>Readable</code> 流。</li>
<li>已触发 <code>'finish'</code> 或 <code>'close'</code> 的 <code>Writable</code> 流。</li>
</ul>
<p>在调用 <code>callback</code> 之后，<code>stream.pipeline()</code> 会将悬挂的事件监听器留在流上。
在失败后重新使用流的情况下，这可能导致事件监听器泄漏和误吞的错误。</p>
<h4><code>stream.Readable.from(iterable, [options])</code><span><a class="mark" href="#stream_stream_readable_from_iterable_options" id="stream_stream_readable_from_iterable_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="stream_readable_from_iterable_options">
                <a href="stream/stream_readable_from_iterable_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.3.0, v10.17.0</span>
</div>
<ul>
<li><code>iterable</code> <a href="http://url.nodejs.cn/mQfCyy" rel="nofollow" class="type">&lt;Iterable&gt;</a> 实现 <code>Symbol.asyncIterator</code> 或 <code>Symbol.iterator</code> 可迭代协议的对象。Emits an 'error' event if a null
value is passed.</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 提供给 <code>new stream.Readable([options])</code> 的选项。
默认情况下，<code>Readable.from()</code> 会将 <code>options.objectMode</code> 设置为 <code>true</code>，除非通过将 <code>options.objectMode</code> 设置为 <code>false</code> 显式地选择此选项。</li>
<li>返回: <a href="stream.html#stream_class_stream_readable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a></li>
</ul>
<p>一个从迭代器中创建可读流的实用方法。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">generate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'hello'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'streams'</span>;
}

<span class="hljs-keyword">const</span> readable = Readable.from(generate());

readable.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(chunk);
});</code></pre>
<p>出于性能原因，调用 <code>Readable.from(string)</code> 或 <code>Readable.from(buffer)</code> 将不会迭代字符串或 buffer 以匹配其他流的语义。</p>
<h4><code>stream.addAbortSignal(signal, stream)</code><span><a class="mark" href="#stream_stream_addabortsignal_signal_stream" id="stream_stream_addabortsignal_signal_stream">#</a></span></h4><p class="tip_wrap" data-item_id="stream_addabortsignal_signal_stream"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<ul>
<li><code>signal</code> <a href="globals.html#globals_class_abortsignal" rel="nofollow" class="type">&lt;AbortSignal&gt;</a> A signal representing possible cancellation</li>
<li><code>stream</code> <a href="stream.html#stream_stream" rel="nofollow" class="type">&lt;Stream&gt;</a> a stream to attach a signal to</li>
</ul>
<p>Attaches an AbortSignal to a readable or writeable stream. This lets code
control stream destruction using an <code>AbortController</code>.</p>
<p>Calling <code>abort</code> on the <code>AbortController</code> corresponding to the passed
<code>AbortSignal</code> will behave the same way as calling <code>.destroy(new AbortError())</code>
on the stream.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();
<span class="hljs-keyword">const</span> read = addAbortSignal(
  controller.signal,
  fs.createReadStream((<span class="hljs-string">'object.json'</span>))
);
<span class="hljs-comment">// Later, abort the operation closing the stream</span>
controller.abort();</code></pre>
<p>Or using an <code>AbortSignal</code> with a readable stream as an async iterable:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> controller.abort(), <span class="hljs-number">10_000</span>); <span class="hljs-comment">// set a timeout</span>
<span class="hljs-keyword">const</span> stream = addAbortSignal(
  controller.signal,
  fs.createReadStream((<span class="hljs-string">'object.json'</span>))
);
(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> stream) {
      <span class="hljs-keyword">await</span> process(chunk);
    }
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">if</span> (e.name === <span class="hljs-string">'AbortError'</span>) {
      <span class="hljs-comment">// The operation was cancelled</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> e;
    }
  }
})();</code></pre>
</section><section><h3>用于实现流的 API<span><a class="mark" href="#stream_api_for_stream_implementers" id="stream_api_for_stream_implementers">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="api_for_stream_implementers">
                <a href="stream/api_for_stream_implementers.html" class="tip_trans">中英对照</a>
                </p>
<!--type=misc-->
<p><code>stream</code> 模块 API 旨在为了更容易地使用 JavaScript 的原型继承模式来实现流。</p>
<p>首先，流的开发者声明一个新的 JavaScript 类，该类继承了四个基本流类之一（<code>stream.Writeable</code>、<code>stream.Readable</code>、<code>stream.Duplex</code> 或 <code>stream.Transform</code>），并确保调用了相应的父类构造函数:</p>
<!-- eslint-disable no-useless-constructor -->
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">{ highWaterMark, ...options }</span>)</span> {
    <span class="hljs-built_in">super</span>({ highWaterMark });
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>当继承流时，在传入基本构造函数之前，务必清楚使用者可以且应该提供哪些选项。
例如，如果实现需要 <code>autoDestroy</code> 和 <code>emitClose</code> 选项，则不允许使用者覆盖这些选项。
应明确要传入的选项，而不是隐式地传入所有选项。</p>
<p>新的流类必须实现一个或多个特定的方法，具体取决于要创建的流的类型，如下图所示:</p>






























<table><thead><tr><th>用例</th><th>类</th><th>需要实现的方法</th></tr></thead><tbody><tr><td>只读</td><td><a href="stream.html#stream_class_stream_readable"><code>Readable</code></a></td><td><a href="stream.html#stream_readable_read_size_1"><code>_read()</code></a></td></tr><tr><td>只写</td><td><a href="stream.html#stream_class_stream_writable"><code>Writable</code></a></td><td><a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>、<a href="stream.html#stream_writable_writev_chunks_callback"><code>_writev()</code></a>、<a href="stream.html#stream_writable_final_callback"><code>_final()</code></a></td></tr><tr><td>可读可写</td><td><a href="stream.html#stream_class_stream_duplex"><code>Duplex</code></a></td><td><a href="stream.html#stream_readable_read_size_1"><code>_read()</code></a>、<a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>、<a href="stream.html#stream_writable_writev_chunks_callback"><code>_writev()</code></a>、<a href="stream.html#stream_writable_final_callback"><code>_final()</code></a></td></tr><tr><td>对写入的数据进行操作，然后读取结果</td><td><a href="stream.html#stream_class_stream_transform"><code>Transform</code></a></td><td><a href="stream.html#stream_transform_transform_chunk_encoding_callback"><code>_transform()</code></a>、<a href="stream.html#stream_transform_flush_callback"><code>_flush()</code></a>、<a href="stream.html#stream_writable_final_callback"><code>_final()</code></a></td></tr></tbody></table>
<p>流的实现代码应永远不要调用旨在供消费者使用的公共方法（详见<a href="stream.html#stream_api_for_stream_consumers">用于消费流的API</a>）。
这样做可能会导致消费流的应用程序代码产生不利的副作用。</p>
<p>避免重写诸如 <code>write()</code>、<code>end()</code>、<code>cork()</code>、<code>uncork()</code>、<code>read()</code> 和 <code>destroy()</code> 之类的公共方法，或通过 <code>.emit()</code> 触发诸如 <code>'error'</code>、<code>'data'</code>、<code>'end'</code>、<code>'finish'</code> 和 <code>'close'</code> 之类的内部事件。
这样做会破坏当前和未来的流的不变量，从而导致与其他流、流的实用工具、以及用户期望的行为和/或兼容性问题。</p>
<h4>简单的实现<span><a class="mark" href="#stream_simplified_construction" id="stream_simplified_construction">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="simplified_construction">
                <a href="stream/simplified_construction.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v1.2.0</span>
</div>
<p>对于简单的案例，构造流可以不依赖继承。
直接创建 <code>stream.Writable</code>、<code>stream.Readable</code>、<code>stream.Duplex</code> 或 <code>stream.Transform</code> 的实例，并传入对应的方法作为构造函数选项。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myWritable = <span class="hljs-keyword">new</span> Writable({
  <span class="hljs-function"><span class="hljs-title">write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<h4>实现可写流<span><a class="mark" href="#stream_implementing_a_writable_stream" id="stream_implementing_a_writable_stream">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="implementing_a_writable_stream">
                <a href="stream/implementing_a_writable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><code>stream.Writable</code> 类可用于实现 <a href="stream.html#stream_class_stream_writable"><code>Writable</code></a> 流。</p>
<p>自定义的 <code>Writable</code> 流必须调用 <code>new stream.Writable([options])</code> 构造函数并实现 <code>writable._write()</code> 和/或 <code>writable._writev()</code> 方法。</p>
<h5><code>new stream.Writable([options])</code><span><a class="mark" href="#stream_new_stream_writable_options" id="stream_new_stream_writable_options">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="new_stream_writable_options">
                <a href="stream/new_stream_writable_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>Change <code>autoDestroy</code> option default to <code>true</code>.</p></td></tr>
<tr><td>v11.2.0, v10.16.0</td>
<td><p>Add <code>autoDestroy</code> option to automatically <code>destroy()</code> the stream when it emits <code>'finish'</code> or errors.</p></td></tr>
<tr><td>v10.0.0</td>
<td><p>Add <code>emitClose</code> option to specify if <code>'close'</code> is emitted on destroy.</p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>highWaterMark</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 当调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 开始返回 <code>false</code> 时的缓冲大小。
默认为 <code>16384</code> (16KB), 对象模式的流默认为 <code>16</code>。</li>
<li><code>decodeStrings</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 是否把传入 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>stream._write()</code></a> 的 <code>string</code> 编码为 <code>Buffer</code>，使用的字符编码为调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 时指定的。
不转换其他类型的数据（即不将 <code>Buffer</code> 解码为 <code>string</code>）。 设置为 <code>false</code> 将会阻止转换 <code>string</code>。 <strong>默认值:</strong> <code>true</code>。</li>
<li><code>defaultEncoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 当 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 的参数没有指定字符编码时默认的字符编码。<strong>默认值:</strong> <code>'utf8'</code>。</li>
<li><code>objectMode</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 是否可以调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(anyObj)</code></a>。
一旦设为 <code>true</code>，则除了字符串、<code>Buffer</code> 或 <code>Uint8Array</code>，还可以写入流实现支持的其他 JavaScript 值。<strong>默认值:</strong> <code>false</code>。</li>
<li><code>emitClose</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 流被销毁后是否触发 <code>'close'</code> 事件。<strong>默认值:</strong> <code>true</code>。</li>
<li><code>write</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>stream._write()</code></a> 方法的实现。</li>
<li><code>writev</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_writable_writev_chunks_callback"><code>stream._writev()</code></a> 方法的实现。</li>
<li><code>destroy</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_writable_destroy_err_callback"><code>stream._destroy()</code></a> 方法的实现。</li>
<li><code>final</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_writable_final_callback"><code>stream._final()</code></a> 方法的实现。</li>
<li><code>autoDestroy</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 此流是否应在结束后自动调用 <code>.destroy()</code>。<strong>默认值:</strong> <code>true</code>.</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-comment">// 调用 stream.Writable() 构造函数。</span>
    <span class="hljs-built_in">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>使用 ES6 之前的语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyWritable</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> MyWritable))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyWritable(options);
  Writable.call(<span class="hljs-built_in">this</span>, options);
}
util.inherits(MyWritable, Writable);</code></pre>
<p>使用简化的构造函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myWritable = <span class="hljs-keyword">new</span> Writable({
  <span class="hljs-function"><span class="hljs-title">write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-function"><span class="hljs-title">writev</span>(<span class="hljs-params">chunks, callback</span>)</span> {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<h5><code>writable._construct(callback)</code><span><a class="mark" href="#stream_writable_construct_callback" id="stream_writable_construct_callback">#</a></span></h5><p class="tip_wrap" data-item_id="writable_construct_callback"></p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> Call this function (optionally with an error
argument) when the stream has finished initializing.</li>
</ul>
<p>The <code>_construct()</code> method MUST NOT be called directly. It may be implemented
by child classes, and if so, will be called by the internal <code>Writable</code>
class methods only.</p>
<p>This optional function will be called in a tick after the stream constructor
has returned, delaying any <code>_write()</code>, <code>_final()</code> and <code>_destroy()</code> calls until
<code>callback</code> is called. This is useful to initialize state or asynchronously
initialize resources before the stream can be used.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">filename</span>)</span> {
    <span class="hljs-built_in">super</span>();
    <span class="hljs-built_in">this</span>.filename = filename;
  }
  <span class="hljs-function"><span class="hljs-title">_construct</span>(<span class="hljs-params">callback</span>)</span> {
    fs.open(<span class="hljs-built_in">this</span>.filename, <span class="hljs-function">(<span class="hljs-params">err, fd</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        callback(err);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">this</span>.fd = fd;
        callback();
      }
    });
  }
  <span class="hljs-function"><span class="hljs-title">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    fs.write(<span class="hljs-built_in">this</span>.fd, chunk, callback);
  }
  <span class="hljs-function"><span class="hljs-title">_destroy</span>(<span class="hljs-params">err, callback</span>)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.fd) {
      fs.close(<span class="hljs-built_in">this</span>.fd, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> callback(er || err));
    } <span class="hljs-keyword">else</span> {
      callback(err);
    }
  }
}</code></pre>
<h5><code>writable._write(chunk, encoding, callback)</code><span><a class="mark" href="#stream_writable_write_chunk_encoding_callback_1" id="stream_writable_write_chunk_encoding_callback_1">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="writable_write_chunk_encoding_callback_1">
                <a href="stream/writable_write_chunk_encoding_callback_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.11.0</td>
<td><p>_write() is optional when providing _writev().</p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 要写入的 <code>Buffer</code>，从传给 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 的 <code>string</code> 转换而来。
如果流的 <code>decodeStrings</code> 选项为 <code>false</code> 或者流在对象模式下运行，则数据块将不会被转换，并且将是传给 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 的任何内容。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 如果 <code>chunk</code> 是字符串，则指定字符编码。
如果 <code>chunk</code> 是 <code>Buffer</code> 或者流处于对象模式，则无视该选项。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当数据块被处理完成后的回调函数。</li>
</ul>
<p>所有可写流的实现必须提供 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a> 和/或 <a href="stream.html#stream_writable_writev_chunks_callback"><code>writable._writev()</code></a> 方法将数据发送到底层资源。</p>
<p><a href="stream.html#stream_class_stream_transform"><code>Transform</code></a> 流会提供自身实现的 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a>。</p>
<p>该函数不能被应用程序代码直接调用。
它应该由子类实现，且只能被内部的 <code>Writable</code> 类的方法调用。</p>
<p>必须在 <code>writable._write()</code> 内部同步地调用、或异步地（即不同的时间点）调用 <code>callback</code> 函数，以表明写入成功完成或因错误而失败。
如果调用失败，则 <code>callback</code> 的第一个参数必须是 <code>Error</code> 对象。
如果写入成功，则 <code>callback</code> 的第一个参数为 <code>null</code>。</p>
<p>在 <code>writable._write()</code> 被调用之后且 <code>callback</code> 被调用之前，所有对 <code>writable.write()</code> 的调用都会把要写入的数据缓冲起来。
当调用 <code>callback</code> 时，流将会触发 <a href="stream.html#stream_event_drain"><code>'drain'</code></a>事件。
如果流的实现需要同时处理多个数据块，则应该实现 <code>writable._writev()</code> 方法。</p>
<p>如果在构造函数选项中设置 <code>decodeStrings</code> 属性为 <code>false</code>，则 <code>chunk</code> 会保持原样传入 <code>.write()</code>，它可能是字符串而不是 <code>Buffer</code>。
这是为了实现对某些特定字符串数据编码的支持。
在这种情况下，<code>encoding</code> 参数将指示字符串的字符编码。 否则，可以安全地忽略编码参数。</p>
<p><code>writable._write()</code> 方法有下划线前缀，因为它是在定义在类的内部，不应该被用户程序直接调用。</p>
<h5><code>writable._writev(chunks, callback)</code><span><a class="mark" href="#stream_writable_writev_chunks_callback" id="stream_writable_writev_chunks_callback">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="writable_writev_chunks_callback">
                <a href="stream/writable_writev_chunks_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul>
<li><code>chunks</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object[]&gt;</a> 要写入的多个数据块。
每个数据块的格式为：<code>{ chunk: ..., encoding: ... }</code>。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当全部数据块被处理完成后的回调函数。</li>
</ul>
<p>该函数不能被应用程序代码直接调用。
该函数应该由子类实现，且只能被内部的 <code>Writable</code> 类的方法调用。</p>
<p>除了在流实现中的 <code>writable._write()</code> 之外，还可以实现 <code>writable._writev()</code> 方法，其能够一次处理多个数据块。
如果已实现且之前写入的数据有缓冲，则会调用 <code>_writev()</code> 而不是 <code>_write()</code>。</p>
<p><code>writable._writev()</code> 方法有下划线前缀，因为它是在定义在类的内部，不应该被用户程序直接调用。</p>
<h5><code>writable._destroy(err, callback)</code><span><a class="mark" href="#stream_writable_destroy_err_callback" id="stream_writable_destroy_err_callback">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="writable_destroy_err_callback">
                <a href="stream/writable_destroy_err_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> 可能发生的错误。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 回调函数。</li>
</ul>
<p><code>_destroy()</code> 方法会被&nbsp;<a href="stream.html#stream_writable_destroy_error"><code>writable.destroy()</code></a> 调用。
它可以被子类重写，但不能直接调用。</p>
<h5><code>writable._final(callback)</code><span><a class="mark" href="#stream_writable_final_callback" id="stream_writable_final_callback">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="writable_final_callback">
                <a href="stream/writable_final_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当结束写入所有剩余数据时的回调函数。</li>
</ul>
<p><code>_final()</code> 方法不能直接调用。
它应该由子类实现，且只能通过内部的 <code>Writable</code> 类的方法调用。</p>
<p>该方法会在流关闭之前被调用，且在 <code>callback</code> 被调用后触发 <code>'finish'</code> 事件。
主要用于在流结束之前关闭资源或写入缓冲的数据。</p>
<h5>写入时的异常处理<span><a class="mark" href="#stream_errors_while_writing" id="stream_errors_while_writing">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="errors_while_writing">
                <a href="stream/errors_while_writing.html" class="tip_trans">中英对照</a>
                </p>
<p>在 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>writable._write()</code></a>、<a href="stream.html#stream_writable_writev_chunks_callback"><code>writable._writev()</code></a> 和 <a href="stream.html#stream_writable_final_callback"><code>writable._final()</code></a> 方法的处理期间发生的错误必须通过调用回调并将错误作为第一个参数传入来冒泡。
从这些方法中抛出 <code>Error</code> 或手动触发 <code>'error'</code> 事件会导致未定义的行为。</p>
<p>如果 <code>Readable</code> 流通过管道传送到 <code>Writable</code> 流时 <code>Writable</code> 触发了错误，则 <code>Readable</code> 流将会被取消管道。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myWritable = <span class="hljs-keyword">new</span> Writable({
  <span class="hljs-function"><span class="hljs-title">write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-keyword">if</span> (chunk.toString().indexOf(<span class="hljs-string">'a'</span>) &gt;= <span class="hljs-number">0</span>) {
      callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'数据块是无效的'</span>));
    } <span class="hljs-keyword">else</span> {
      callback();
    }
  }
});</code></pre>
<h5>可写流的例子<span><a class="mark" href="#stream_an_example_writable_stream" id="stream_an_example_writable_stream">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="an_example_writable_stream">
                <a href="stream/an_example_writable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p>以下举例了一个相当简单（并且有点无意义）的自定义的 <code>Writable</code> 流的实现。
虽然这个特定的 <code>Writable</code> 流的实例没有任何实际的特殊用途，但该示例说明了一个自定义的 <a href="stream.html#stream_class_stream_writable"><code>Writable</code></a> 流实例的每个必需元素：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-keyword">if</span> (chunk.toString().indexOf(<span class="hljs-string">'a'</span>) &gt;= <span class="hljs-number">0</span>) {
      callback(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'数据块是无效的'</span>));
    } <span class="hljs-keyword">else</span> {
      callback();
    }
  }
}</code></pre>
<h5>在可写流中解码 buffer<span><a class="mark" href="#stream_decoding_buffers_in_a_writable_stream" id="stream_decoding_buffers_in_a_writable_stream">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="decoding_buffers_in_a_writable_stream">
                <a href="stream/decoding_buffers_in_a_writable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p>解码 buffer 是一个常见的任务，例如使用转换流处理字符串输入。
当使用多字节的字符编码（比如 UTF-8）时，这是一个重要的处理。
下面的例子展示了如何使用 <code>StringDecoder</code> 和 <a href="stream.html#stream_class_stream_writable"><code>Writable</code></a> 解码多字节的字符串。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Writable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { StringDecoder } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'string_decoder'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringWritable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Writable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-built_in">super</span>(options);
    <span class="hljs-built_in">this</span>._decoder = <span class="hljs-keyword">new</span> StringDecoder(options &amp;&amp; options.defaultEncoding);
    <span class="hljs-built_in">this</span>.data = <span class="hljs-string">''</span>;
  }
  <span class="hljs-function"><span class="hljs-title">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-keyword">if</span> (encoding === <span class="hljs-string">'buffer'</span>) {
      chunk = <span class="hljs-built_in">this</span>._decoder.write(chunk);
    }
    <span class="hljs-built_in">this</span>.data += chunk;
    callback();
  }
  <span class="hljs-function"><span class="hljs-title">_final</span>(<span class="hljs-params">callback</span>)</span> {
    <span class="hljs-built_in">this</span>.data += <span class="hljs-built_in">this</span>._decoder.end();
    callback();
  }
}

<span class="hljs-keyword">const</span> euro = [[<span class="hljs-number">0xE2</span>, <span class="hljs-number">0x82</span>], [<span class="hljs-number">0xAC</span>]].map(Buffer.from);
<span class="hljs-keyword">const</span> w = <span class="hljs-keyword">new</span> StringWritable();

w.write(<span class="hljs-string">'货币: '</span>);
w.write(euro[<span class="hljs-number">0</span>]);
w.end(euro[<span class="hljs-number">1</span>]);

<span class="hljs-built_in">console</span>.log(w.data); <span class="hljs-comment">// 货币: €</span></code></pre>
<h4>实现可读流<span><a class="mark" href="#stream_implementing_a_readable_stream" id="stream_implementing_a_readable_stream">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="implementing_a_readable_stream">
                <a href="stream/implementing_a_readable_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><code>stream.Readable</code> 类可用于实现可读流。</p>
<p>自定义的可读流必须调用 <code>new stream.Readable([options])</code> 构造函数并实现 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 方法。</p>
<h5><code>new stream.Readable([options])</code><span><a class="mark" href="#stream_new_stream_readable_options" id="stream_new_stream_readable_options">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="new_stream_readable_options">
                <a href="stream/new_stream_readable_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.0.0</td>
<td><p>Change <code>autoDestroy</code> option default to <code>true</code>.</p></td></tr>
<tr><td>v11.2.0, v10.16.0</td>
<td><p>Add <code>autoDestroy</code> option to automatically <code>destroy()</code> the stream when it emits <code>'end'</code> or errors.</p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>highWaterMark</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 从底层资源读取数据并存储在内部缓冲区中的最大<a href="stream.html#stream_highwatermark_discrepancy_after_calling_readable_setencoding">字节数</a>。
<strong>默认值:</strong> <code>16384</code> (16KB), 对象模式的流默认为 <code>16</code>。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 如果指定了，则使用指定的字符编码将 buffer 解码成字符串。
<strong>默认值:</strong> <code>null</code>。</li>
<li><code>objectMode</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 流是否可以是一个对象流。
也就是说 <a href="stream.html#stream_readable_read_size"><code>stream.read(n)</code></a> 会返回对象而不是 <code>Buffer</code>。
<strong>默认值:</strong> <code>false</code>。</li>
<li><code>emitClose</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 流被销毁后是否应该触发 <code>'close'</code>。<strong>默认值:</strong> <code>true</code>。</li>
<li><code>read</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_readable_read_size_1"><code>stream._read()</code></a> 方法的实现。</li>
<li><code>destroy</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_readable_destroy_err_callback"><code>stream._destroy()</code></a> 方法的实现。</li>
<li><code>autoDestroy</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 流是否应在结束后自动调用 <code>.destroy()</code>。<strong>默认值:</strong> <code>true</code>。</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReadable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Readable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-comment">// 调用 stream.Readable(options) 构造函数。</span>
    <span class="hljs-built_in">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>使用 ES6 之前的语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyReadable</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> MyReadable))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyReadable(options);
  Readable.call(<span class="hljs-built_in">this</span>, options);
}
util.inherits(MyReadable, Readable);</code></pre>
<p>使用简化的构造函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myReadable = <span class="hljs-keyword">new</span> Readable({
  <span class="hljs-function"><span class="hljs-title">read</span>(<span class="hljs-params">size</span>)</span> {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<h5><code>readable._construct(callback)</code><span><a class="mark" href="#stream_readable_construct_callback" id="stream_readable_construct_callback">#</a></span></h5><p class="tip_wrap" data-item_id="readable_construct_callback"></p>
<div class="api_metadata">
<span>新增于: v15.0.0</span>
</div>
<ul>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> Call this function (optionally with an error
argument) when the stream has finished initializing.</li>
</ul>
<p>The <code>_construct()</code> method MUST NOT be called directly. It may be implemented
by child classes, and if so, will be called by the internal <code>Readable</code>
class methods only.</p>
<p>This optional function will be scheduled in the next tick by the stream
constructor, delaying any <code>_read()</code> and <code>_destroy()</code> calls until <code>callback</code> is
called. This is useful to initialize state or asynchronously initialize
resources before the stream can be used.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Readable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">filename</span>)</span> {
    <span class="hljs-built_in">super</span>();
    <span class="hljs-built_in">this</span>.filename = filename;
    <span class="hljs-built_in">this</span>.fd = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-function"><span class="hljs-title">_construct</span>(<span class="hljs-params">callback</span>)</span> {
    fs.open(<span class="hljs-built_in">this</span>.filename, <span class="hljs-function">(<span class="hljs-params">err, fd</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        callback(err);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">this</span>.fd = fd;
        callback();
      }
    });
  }
  <span class="hljs-function"><span class="hljs-title">_read</span>(<span class="hljs-params">n</span>)</span> {
    <span class="hljs-keyword">const</span> buf = Buffer.alloc(n);
    fs.read(<span class="hljs-built_in">this</span>.fd, buf, <span class="hljs-number">0</span>, n, <span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">err, bytesRead</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-built_in">this</span>.destroy(err);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">this</span>.push(bytesRead &gt; <span class="hljs-number">0</span> ? buf.slice(<span class="hljs-number">0</span>, bytesRead) : <span class="hljs-literal">null</span>);
      }
    });
  }
  <span class="hljs-function"><span class="hljs-title">_destroy</span>(<span class="hljs-params">err, callback</span>)</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.fd) {
      fs.close(<span class="hljs-built_in">this</span>.fd, <span class="hljs-function">(<span class="hljs-params">er</span>) =&gt;</span> callback(er || err));
    } <span class="hljs-keyword">else</span> {
      callback(err);
    }
  }
}</code></pre>
<h5><code>readable._read(size)</code><span><a class="mark" href="#stream_readable_read_size_1" id="stream_readable_read_size_1">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="readable_read_size_1">
                <a href="stream/readable_read_size_1.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.4</span>
</div>
<ul>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 要异步读取的字节数。</li>
</ul>
<p>该函数不能被应用程序代码直接调用。
它应该由子类实现，且只能被内部的 <code>Readable</code> 类的方法调用。</p>
<p>所有可读流的实现必须提供 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 方法从底层资源获取数据。</p>
<p>当 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 被调用时，如果从资源读取到数据，则需要开始使用 <a href="stream.html#stream_readable_push_chunk_encoding"><code>this.push(dataChunk)</code></a> 推送数据到读取队列。
<code>_read()</code> 应该持续从资源读取数据并推送数据，直到 <code>readable.push()</code> 返回 <code>false</code>。
若想再次调用 <code>_read()</code> 方法，则需要恢复推送数据到队列。</p>
<p>一旦 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 方法被调用，将不会再次调用它，直到更多数据通过 <a href="stream.html#stream_readable_push_chunk_encoding"><code>readable.push()</code></a> 方法被推送。
空的数据（例如空的 buffer 和字符串）将不会导致 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 被调用。</p>
<p><code>size</code> 是可选的参数。
对于读取是一个单一操作的实现，可以使用 <code>size</code> 参数来决定要读取多少数据。
对于其他的实现，可以忽略这个参数，只要有数据就提供数据。
不需要等待指定 <code>size</code> 字节的数据在调用 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>。</p>
<p><a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 方法有下划线前缀，因为它是在定义在类的内部，不应该被用户程序直接调用。</p>
<h5><code>readable._destroy(err, callback)</code><span><a class="mark" href="#stream_readable_destroy_err_callback" id="stream_readable_destroy_err_callback">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="readable_destroy_err_callback">
                <a href="stream/readable_destroy_err_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.0.0</span>
</div>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> 可能发生的错误。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 回调函数。</li>
</ul>
<p><code>_destroy()</code> 方法会被&nbsp;<a href="stream.html#stream_readable_destroy_error"><code>readable.destroy()</code></a> 调用。
它可以被子类重写，但不能直接调用。</p>
<h5><code>readable.push(chunk[, encoding])</code><span><a class="mark" href="#stream_readable_push_chunk_encoding" id="stream_readable_push_chunk_encoding">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="readable_push_chunk_encoding">
                <a href="stream/readable_push_chunk_encoding.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>chunk</code> argument can now be a <code>Uint8Array</code> instance.</p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" class="type">&lt;Uint8Array&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 要推入读取队列的数据块。</li>
</ul>
<p>&nbsp;对于非对象模式的流，<code>chunk</code> 必须是字符串、<code>Buffer</code> 或 <code>Uint8Array</code>。
&nbsp;对于对象模式的流，<code>chunk</code> 可以是任何 JavaScript 值。</p>
<ul>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 字符串数据块的字符编码。
必须是有效的 <code>Buffer</code> 字符编码，例如 <code>'utf8'</code> 或&nbsp;<code>'ascii'</code>。</li>
<li>返回: <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果还有数据块可以继续推入，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>当 <code>chunk</code> 是 <code>Buffer</code>、<code>Uint8Array</code> 或 <code>string</code> 时，<code>chunk</code> 的数据会被添加到内部队列中供流消费。
在没有数据可写入后，给 <code>chunk</code> 传入 <code>null</code> 表示流的结束（EOF）。</p>
<p>当可读流处在暂停模式时，使用 <code>readable.push()</code> 添加的数据可以在触发 <a href="stream.html#stream_event_readable"><code>'readable'</code></a> 事件时通过调用 <a href="stream.html#stream_readable_read_size"><code>readable.read()</code></a> 读取。</p>
<p>当可读流处于流动模式时，使用 <code>readable.push()</code> 添加的数据可以通过触发 <code>'data'</code> 事件读取。</p>
<p><code>readable.push()</code> 方法被设计得尽可能的灵活。
例如，当需要封装一个带有'暂停/继续'机制与数据回调的底层数据源时，该底层数据源可以使用自定义的可读流实例封装：</p>
<pre><code class="language-js"><span class="hljs-comment">// `source` 是一个有 `readStop()` 和 `readStart()` 方法的对象，</span>
<span class="hljs-comment">// 当有数据时会调用 `ondata` 方法，</span>
<span class="hljs-comment">// 当数据结束时会调用 `onend` 方法。</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SourceWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Readable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-built_in">super</span>(options);

    <span class="hljs-built_in">this</span>._source = getLowLevelSourceObject();

    <span class="hljs-comment">// 每当有数据时，将其推入内部缓冲。</span>
    <span class="hljs-built_in">this</span>._source.ondata = <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
      <span class="hljs-comment">// 如果 push() 返回 `false`，则停止读取。</span>
      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.push(chunk))
        <span class="hljs-built_in">this</span>._source.readStop();
    };

    <span class="hljs-comment">// 当读取到尽头时，推入 `null` 表示流的结束。</span>
    <span class="hljs-built_in">this</span>._source.onend = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">this</span>.push(<span class="hljs-literal">null</span>);
    };
  }
  <span class="hljs-comment">// 当流想推送更多数据时，`_read` 会被调用。</span>
  <span class="hljs-function"><span class="hljs-title">_read</span>(<span class="hljs-params">size</span>)</span> {
    <span class="hljs-built_in">this</span>._source.readStart();
  }
}</code></pre>
<p><code>readable.push()</code> 方法用于将内容推入内部的 buffer。
它可以由 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 方法驱动。</p>
<p>对于非对象模式的流，如果 <code>readable.push()</code> 的 <code>chunk</code> 参数为 <code>undefined</code>，则它会被当成空字符串或 buffer。
详见 <a href="stream.html#stream_readable_push"><code>readable.push('')</code></a>。</p>
<h5>读取时的异常处理<span><a class="mark" href="#stream_errors_while_reading" id="stream_errors_while_reading">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="errors_while_reading">
                <a href="stream/errors_while_reading.html" class="tip_trans">中英对照</a>
                </p>
<p>在 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 执行期间发生的错误必须通过 <a href="stream.html#stream_readable_destroy_err_callback"><code>readable.destroy(err)</code></a> 方法冒泡。
从 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 中抛出 <code>Error</code> 或手动触发 <code>'error'</code> 事件会导致未定义的行为。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myReadable = <span class="hljs-keyword">new</span> Readable({
  <span class="hljs-function"><span class="hljs-title">read</span>(<span class="hljs-params">size</span>)</span> {
    <span class="hljs-keyword">const</span> err = checkSomeErrorCondition();
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-built_in">this</span>.destroy(err);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 做些处理。</span>
    }
  }
});</code></pre>
<h5>可读流的例子<span><a class="mark" href="#stream_an_example_counting_stream" id="stream_an_example_counting_stream">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="an_example_counting_stream">
                <a href="stream/an_example_counting_stream.html" class="tip_trans">中英对照</a>
                </p>
<!--type=example-->
<p>下面是一个可读流的简单例子，依次触发读取 1 到 1,000,000：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Readable</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">opt</span>)</span> {
    <span class="hljs-built_in">super</span>(opt);
    <span class="hljs-built_in">this</span>._max = <span class="hljs-number">1000000</span>;
    <span class="hljs-built_in">this</span>._index = <span class="hljs-number">1</span>;
  }

  <span class="hljs-function"><span class="hljs-title">_read</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">const</span> i = <span class="hljs-built_in">this</span>._index++;
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-built_in">this</span>._max)
      <span class="hljs-built_in">this</span>.push(<span class="hljs-literal">null</span>);
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">const</span> str = <span class="hljs-built_in">String</span>(i);
      <span class="hljs-keyword">const</span> buf = Buffer.from(str, <span class="hljs-string">'ascii'</span>);
      <span class="hljs-built_in">this</span>.push(buf);
    }
  }
}</code></pre>
<h4>实现双工流<span><a class="mark" href="#stream_implementing_a_duplex_stream" id="stream_implementing_a_duplex_stream">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="implementing_a_duplex_stream">
                <a href="stream/implementing_a_duplex_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="stream.html#stream_class_stream_duplex">双工流</a>同时实现了<a href="stream.html#stream_class_stream_readable">可读流</a>和<a href="stream.html#stream_class_stream_writable">可写流</a>，例如 TCP socket 连接。</p>
<p>因为 JavaScript 不支持多重继承，所以使用 <code>stream.Duplex</code> 类实现<a href="stream.html#stream_class_stream_duplex">双工流</a>（而不是使用 <code>stream.Readable</code> 类和 <code>stream.Writable</code> 类）。</p>
<p><code>stream.Duplex</code> 类的原型继承自 <code>stream.Readable</code> 和寄生自 <code>stream.Writable</code>，但是 <code>instanceof</code> 对这两个基础类都可用，因为重写了 <code>stream.Writable</code> 的 <a href="http://url.nodejs.cn/D1EDvM"><code>Symbol.hasInstance</code></a>。</p>
<p>自定义的双工流必须调用 <code>new stream.Duplex([options])</code> 构造函数并实现 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 和 <code>writable._write()</code> 方法。</p>
<h5><code>new stream.Duplex(options)</code><span><a class="mark" href="#stream_new_stream_duplex_options" id="stream_new_stream_duplex_options">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="new_stream_duplex_options">
                <a href="stream/new_stream_duplex_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v8.4.0</td>
<td><p>The <code>readableHighWaterMark</code> and <code>writableHighWaterMark</code> options are supported now.</p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 同时传给 <code>Writable</code> 和 <code>Readable</code> 的构造函数。
<ul>
<li><code>allowHalfOpen</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果设为 <code>false</code>，则当可读端结束时，可写端也会自动结束。
默认为 <code>true</code>。</li>
<li><code>readable</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> Sets whether the <code>Duplex</code> should be readable.
<strong>默认值:</strong> <code>true</code>。</li>
<li><code>writable</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> Sets whether the <code>Duplex</code> should be writable.
<strong>默认值:</strong> <code>true</code>。</li>
<li><code>readableObjectMode</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 设置流的可读端为 <code>objectMode</code>。
如果 <code>objectMode</code> 为 <code>true</code>，则不起作用。
默认为 <code>false</code>。</li>
<li><code>writableObjectMode</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 设置流的可写端为 <code>objectMode</code>。
如果 <code>objectMode</code> 为 <code>true</code>，则不起作用。
默认为 <code>false</code>。</li>
<li><code>readableHighWaterMark</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 设置流的可读端的 <code>highWaterMark</code>。
如果已经设置了 <code>highWaterMark</code>，则不起作用。</li>
<li><code>writableHighWaterMark</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 设置流的可写端的 <code>highWaterMark</code>。
如果已经设置了 <code>highWaterMark</code>，则不起作用。</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Duplex } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDuplex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duplex</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-built_in">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>使用 ES6 之前的语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Duplex } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyDuplex</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> MyDuplex))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyDuplex(options);
  Duplex.call(<span class="hljs-built_in">this</span>, options);
}
util.inherits(MyDuplex, Duplex);</code></pre>
<p>使用简化的构造函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Duplex } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myDuplex = <span class="hljs-keyword">new</span> Duplex({
  <span class="hljs-function"><span class="hljs-title">read</span>(<span class="hljs-params">size</span>)</span> {
    <span class="hljs-comment">// ...</span>
  },
  <span class="hljs-function"><span class="hljs-title">write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<h5>双工流的例子<span><a class="mark" href="#stream_an_example_duplex_stream" id="stream_an_example_duplex_stream">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="an_example_duplex_stream">
                <a href="stream/an_example_duplex_stream.html" class="tip_trans">中英对照</a>
                </p>
<p>下面举例说明了一个双工流的简单示例，它封装了一个可以写入数据的假设的底层源对象，并且可以从中读取数据，尽管使用的是与 Node.js 流不兼容的 API。
下面举例了一个双工流的简单示例，它通过可读流接口读回可写流接口的 buffer 传入的写入数据。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Duplex } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> kSource = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'source'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDuplex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duplex</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">source, options</span>)</span> {
    <span class="hljs-built_in">super</span>(options);
    <span class="hljs-built_in">this</span>[kSource] = source;
  }

  <span class="hljs-function"><span class="hljs-title">_write</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-comment">// 底层资源只处理字符串。</span>
    <span class="hljs-keyword">if</span> (Buffer.isBuffer(chunk))
      chunk = chunk.toString();
    <span class="hljs-built_in">this</span>[kSource].writeSomeData(chunk);
    callback();
  }

  <span class="hljs-function"><span class="hljs-title">_read</span>(<span class="hljs-params">size</span>)</span> {
    <span class="hljs-built_in">this</span>[kSource].fetchSomeData(size, <span class="hljs-function">(<span class="hljs-params">data, encoding</span>) =&gt;</span> {
      <span class="hljs-built_in">this</span>.push(Buffer.from(data, encoding));
    });
  }
}</code></pre>
<p>双工流最重要的方面是，可读端和可写端相互独立于彼此地共存在同一个对象实例中。</p>
<h5>对象模式的双工流<span><a class="mark" href="#stream_object_mode_duplex_streams" id="stream_object_mode_duplex_streams">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="object_mode_duplex_streams">
                <a href="stream/object_mode_duplex_streams.html" class="tip_trans">中英对照</a>
                </p>
<p>对双工流来说，可以使用 <code>readableObjectMode</code> 和&nbsp;<code>writableObjectMode</code> 选项来分别设置可读端和可写端的 <code>objectMode</code>。</p>
<p>在下面的例子中，创建了一个变换流（双工流的一种），对象模式的可写端接收 JavaScript 数值，并在可读端转换为十六进制字符串。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Transform } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 转换流也是双工流。</span>
<span class="hljs-keyword">const</span> myTransform = <span class="hljs-keyword">new</span> Transform({
  <span class="hljs-attr">writableObjectMode</span>: <span class="hljs-literal">true</span>,

  <span class="hljs-function"><span class="hljs-title">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-comment">// 强制把 chunk 转换成数值。</span>
    chunk |= <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 将 chunk 转换成十六进制。</span>
    <span class="hljs-keyword">const</span> data = chunk.toString(<span class="hljs-number">16</span>);

    <span class="hljs-comment">// 推送数据到可读队列。</span>
    callback(<span class="hljs-literal">null</span>, <span class="hljs-string">'0'</span>.repeat(data.length % <span class="hljs-number">2</span>) + data);
  }
});

myTransform.setEncoding(<span class="hljs-string">'ascii'</span>);
myTransform.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(chunk));

myTransform.write(<span class="hljs-number">1</span>);
<span class="hljs-comment">// 打印: 01</span>
myTransform.write(<span class="hljs-number">10</span>);
<span class="hljs-comment">// 打印: 0a</span>
myTransform.write(<span class="hljs-number">100</span>);
<span class="hljs-comment">// 打印: 64</span></code></pre>
<h4>实现转换流<span><a class="mark" href="#stream_implementing_a_transform_stream" id="stream_implementing_a_transform_stream">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="implementing_a_transform_stream">
                <a href="stream/implementing_a_transform_stream.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="stream.html#stream_class_stream_transform">转换流</a>是一种<a href="stream.html#stream_class_stream_duplex">双工流</a>，它会对输入做些计算然后输出。
例如 <a href="zlib.html">zlib</a> 流和 <a href="crypto.html">crypto</a> 流会压缩、加密或解密数据。</p>
<p>输出流的大小、数据块的数量都不一定会和输入流的一致。
例如，<code>Hash</code> 流在输入结束时只会输出一个数据块，而 <code>zlib</code> 流的输出可能比输入大很多或小很多。</p>
<p><code>stream.Transform</code> 类可用于实现了一个<a href="stream.html#stream_class_stream_transform">转换流</a>。</p>
<p><code>stream.Transform</code> 类继承自 <code>stream.Duplex</code>，并且实现了自有的 <code>writable._write()</code> 和 <a href="stream.html#stream_readable_read_size_1"><code>readable._read()</code></a> 方法。
自定义的转换流必须实现 <a href="stream.html#stream_transform_transform_chunk_encoding_callback"><code>transform._transform()</code></a> 方法，<a href="stream.html#stream_transform_flush_callback"><code>transform._flush()</code></a> 方法是可选的。</p>
<p>当使用转换流时，如果可读端的输出没有被消费，则写入流的数据可能会导致可写端被暂停。</p>
<h5><code>new stream.Transform([options])</code><span><a class="mark" href="#stream_new_stream_transform_options" id="stream_new_stream_transform_options">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="new_stream_transform_options">
                <a href="stream/new_stream_transform_options.html" class="tip_trans">中英对照</a>
                </p>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 同时传给 <code>Writable</code> 和 <code>Readable</code> 的构造函数。
<ul>
<li><code>transform</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_transform_transform_chunk_encoding_callback"><code>stream._transform()</code></a> 的实现。</li>
<li><code>flush</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 对 <a href="stream.html#stream_transform_flush_callback"><code>stream._flush()</code></a> 的实现。</li>
</ul>
</li>
</ul>
<!-- eslint-disable no-useless-constructor -->
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Transform } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Transform</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-built_in">super</span>(options);
    <span class="hljs-comment">// ...</span>
  }
}</code></pre>
<p>使用 ES6 之前的语法：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Transform } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyTransform</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> MyTransform))
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyTransform(options);
  Transform.call(<span class="hljs-built_in">this</span>, options);
}
util.inherits(MyTransform, Transform);</code></pre>
<p>使用简化的构造函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Transform } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> myTransform = <span class="hljs-keyword">new</span> Transform({
  <span class="hljs-function"><span class="hljs-title">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>)</span> {
    <span class="hljs-comment">// ...</span>
  }
});</code></pre>
<h5><code>'end'</code> 事件<span><a class="mark" href="#stream_event_end_1" id="stream_event_end_1">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="event_end_1">
                <a href="stream/event_end_1.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="stream.html#stream_event_end"><code>'end'</code></a> 事件来自 <code>stream.Readable</code> 类。
当调用了 <a href="stream.html#stream_transform_flush_callback"><code>transform._flush()</code></a> 中的回调函数并且所有数据已经输出之后，触发 <code>'end'</code> 事件。
如果出现错误，则不应触发 <code>'end'</code>。</p>
<h5><code>'finish'</code> 事件<span><a class="mark" href="#stream_event_finish_1" id="stream_event_finish_1">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="event_finish_1">
                <a href="stream/event_finish_1.html" class="tip_trans">中英对照</a>
                </p>
<p><a href="stream.html#stream_event_finish"><code>'finish'</code></a> 事件来自 <code>stream.Writable</code> 类。
当调用了 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> 并且 <a href="stream.html#stream_transform_transform_chunk_encoding_callback"><code>stream._transform()</code></a> 处理完全部数据块之后，触发 <code>'finish'</code> 事件。
如果出现错误，则不应触发 <code>'finish'</code>。</p>
<h5><code>transform._flush(callback)</code><span><a class="mark" href="#stream_transform_flush_callback" id="stream_transform_flush_callback">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="transform_flush_callback">
                <a href="stream/transform_flush_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当剩余的数据被 flush 后的回调函数。</li>
</ul>
<p>该函数不能被应用程序代码直接调用。
它应该由子类实现，且只能被内部的 <code>Readable</code> 类的方法调用。</p>
<p>某些情况下，转换操作可能需要在流的末尾发送一些额外的数据。
例如，<code>zlib</code> 压缩流时会储存一些用于优化输出的内部状态。
当流结束时，这些额外的数据需要被 flush 才算完成压缩。</p>
<p>自定义的<a href="stream.html#stream_class_stream_transform">转换流</a>的 <code>transform._flush()</code> 方法是可选的。
当没有更多数据要被消费时，就会调用这个方法，但如果是在 <a href="stream.html#stream_event_end"><code>'end'</code></a> 事件被触发之前调用则会发出可读流结束的信号。</p>
<p>在 <code>transform._flush()</code> 的实现中，<code>transform.push()</code> 可能会被调用零次或多次。
当 flush 操作完成时，必须调用 <code>callback</code> 函数。</p>
<p><code>transform._flush()</code> 方法有下划线前缀，因为它是在定义在类的内部，不应该被用户程序直接调用。</p>
<h5><code>transform._transform(chunk, encoding, callback)</code><span><a class="mark" href="#stream_transform_transform_chunk_encoding_callback" id="stream_transform_transform_chunk_encoding_callback">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="transform_transform_chunk_encoding_callback">
                <a href="stream/transform_transform_chunk_encoding_callback.html" class="tip_trans">中英对照</a>
                </p>
<ul>
<li><code>chunk</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 要转换的 <code>Buffer</code>，从传给 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 的 <code>string</code> 转换而来。
如果流的 <code>decodeStrings</code> 选项为 <code>false</code> 或者流在对象模式下运行，则数据块将不会被转换，并且将是传给 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> 的任何内容。</li>
<li><code>encoding</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 如果数据块是一个字符串，则这是编码类型。 如果数据块是一个 buffer，则为特殊值 <code>'buffer'</code>。在这种情况下忽略它。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当 <code>chunk</code> 处理完成时的回调函数。</li>
</ul>
<p>该函数不能被应用程序代码直接调用。
它应该由子类实现，且只能被内部的 <code>Readable</code> 类的方法调用。</p>
<p>所有转换流的实现都必须提供 <code>_transform()</code> 方法来接收输入并生产输出。
<code>transform._transform()</code> 的实现会处理写入的字节，进行一些计算操作，然后使用 <code>transform.push()</code> 输出到可读流。</p>
<p><code>transform.push()</code> 可能会被调用零次或多次用来从每次输入的数据块产生输出，调用的次数取决需要多少数据来产生输出的结果。</p>
<p>输入的数据块有可能不会产生任何输出。</p>
<p>当前数据被完全消费之后，必须调用 <code>callback</code> 函数。
当处理输入的过程中发生出错时，<code>callback</code> 的第一个参数传入 <code>Error</code> 对象，否则传入 <code>null</code>。
如果 <code>callback</code> 传入了第二个参数，则它会被转发到 <code>transform.push()</code>。
就像下面的例子：</p>
<pre><code class="language-js">transform.prototype._transform = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, encoding, callback</span>) </span>{
  <span class="hljs-built_in">this</span>.push(data);
  callback();
};

transform.prototype._transform = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, encoding, callback</span>) </span>{
  callback(<span class="hljs-literal">null</span>, data);
};</code></pre>
<p><code>transform._transform()</code> 方法有下划线前缀，因为它是在定义在类的内部，不应该被用户程序直接调用。</p>
<p><code>transform._transform()</code>&nbsp;不能并行调用。
流使用了队列机制，无论同步或异步的情况下，都必须先调用 <code>callback</code> 之后才能接收下一个数据块。</p>
<h5>stream.PassThrough 类<span><a class="mark" href="#stream_class_stream_passthrough" id="stream_class_stream_passthrough">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="class_stream_passthrough">
                <a href="stream/class_stream_passthrough.html" class="tip_trans">中英对照</a>
                </p>
<p><code>stream.PassThrough</code> 类是一个无关紧要的<a href="stream.html#stream_class_stream_transform">转换流</a>，只是单纯地把输入的字节原封不动地输出。
它主要用于示例或测试，但有时也会用于某些新颖的流的基本组成部分。</p>
</section><section><h3>其他注意事项<span><a class="mark" href="#stream_additional_notes" id="stream_additional_notes">#</a></span></h3>
<!--type=misc-->
<h4>流与异步生成器和异步迭代器的兼容性<span><a class="mark" href="#stream_streams_compatibility_with_async_generators_and_async_iterators" id="stream_streams_compatibility_with_async_generators_and_async_iterators">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="streams_compatibility_with_async_generators_and_async_iterators">
                <a href="stream/streams_compatibility_with_async_generators_and_async_iterators.html" class="tip_trans">中英对照</a>
                </p>
<p>借助 JavaScript 中异步生成器和迭代器的支持，异步生成器实际上是此时的一流语言级流构造。</p>
<p>下面提供了使用带有异步生成器和异步迭代器的 Node.js 流的一些常见互操作情况。</p>
<h5>使用异步迭代器消费可读流<span><a class="mark" href="#stream_consuming_readable_streams_with_async_iterators" id="stream_consuming_readable_streams_with_async_iterators">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="consuming_readable_streams_with_async_iterators">
                <a href="stream/consuming_readable_streams_with_async_iterators.html" class="tip_trans">中英对照</a>
                </p>
<pre><code class="language-js">(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> chunk <span class="hljs-keyword">of</span> readable) {
    <span class="hljs-built_in">console</span>.log(chunk);
  }
})();</code></pre>
<p>异步迭代器在流上注册一个永久的错误处理程序，以防止任何未处理的 post-destroy 错误。</p>
<h5>使用异步生成器创建可读流<span><a class="mark" href="#stream_creating_readable_streams_with_async_generators" id="stream_creating_readable_streams_with_async_generators">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="creating_readable_streams_with_async_generators">
                <a href="stream/creating_readable_streams_with_async_generators.html" class="tip_trans">中英对照</a>
                </p>
<p>我们可以使用 <code>Readable.from()</code> 实用方法从异步生成器构造 Node.js 可读流：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Readable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">generate</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">'c'</span>;
}

<span class="hljs-keyword">const</span> readable = Readable.from(generate());

readable.on(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(chunk);
});</code></pre>
<h5>从异步迭代器传送到可写流<span><a class="mark" href="#stream_piping_to_writable_streams_from_async_iterators" id="stream_piping_to_writable_streams_from_async_iterators">#</a></span></h5><p class="tip_wrap" data-item_id="piping_to_writable_streams_from_async_iterators"></p>
<p>When writing to a writable stream from an async iterator, ensure correct
handling of backpressure and errors. <a href="stream.html#stream_stream_pipeline_source_transforms_destination_callback"><code>stream.pipeline()</code></a> abstracts away
the handling of backpressure and backpressure-related errors:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-attr">pipeline</span>: pipelinePromise } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream/promises'</span>);

<span class="hljs-keyword">const</span> writable = fs.createWriteStream(<span class="hljs-string">'./file'</span>);

<span class="hljs-comment">// Callback Pattern</span>
pipeline(iterator, writable, <span class="hljs-function">(<span class="hljs-params">err, value</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(value, <span class="hljs-string">'value returned'</span>);
  }
});

<span class="hljs-comment">// Promise Pattern</span>
pipelinePromise(iterator, writable)
  .then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(value, <span class="hljs-string">'value returned'</span>);
  })
  .catch(<span class="hljs-built_in">console</span>.error);</code></pre>
<!--type=misc-->
<h4>兼容旧版本的 Node.js<span><a class="mark" href="#stream_compatibility_with_older_node_js_versions" id="stream_compatibility_with_older_node_js_versions">#</a></span></h4><p class="tip_wrap" data-item_id="compatibility_with_older_node_js_versions"></p>
<!--type=misc-->
<p>Prior to Node.js 0.10, the <code>Readable</code> stream interface was simpler, but also
less powerful and less useful.</p>
<ul>
<li>Rather than waiting for calls to the <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> method,
<a href="stream.html#stream_event_data"><code>'data'</code></a> events would begin emitting immediately. Applications that
would need to perform some amount of work to decide how to handle data
were required to store read data into buffers so the data would not be lost.</li>
<li>The <a href="stream.html#stream_readable_pause"><code>stream.pause()</code></a> method was advisory, rather than
guaranteed. This meant that it was still necessary to be prepared to receive
<a href="stream.html#stream_event_data"><code>'data'</code></a> events <em>even when the stream was in a paused state</em>.</li>
</ul>
<p>In Node.js 0.10, the <a href="stream.html#stream_class_stream_readable"><code>Readable</code></a> class was added. For backward
compatibility with older Node.js programs, <code>Readable</code> streams switch into
"flowing mode" when a <a href="stream.html#stream_event_data"><code>'data'</code></a> event handler is added, or when the
<a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> method is called. The effect is that, even
when not using the new <a href="stream.html#stream_readable_read_size"><code>stream.read()</code></a> method and
<a href="stream.html#stream_event_readable"><code>'readable'</code></a> event, it is no longer necessary to worry about losing
<a href="stream.html#stream_event_data"><code>'data'</code></a> chunks.</p>
<p>While most applications will continue to function normally, this introduces an
edge case in the following conditions:</p>
<ul>
<li>No <a href="stream.html#stream_event_data"><code>'data'</code></a> event listener is added.</li>
<li>The <a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> method is never called.</li>
<li>The stream is not piped to any writable destination.</li>
</ul>
<p>For example, consider the following code:</p>
<pre><code class="language-js"><span class="hljs-comment">// WARNING!  BROKEN!</span>
net.createServer(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {

  <span class="hljs-comment">// We add an 'end' listener, but never consume the data.</span>
  socket.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// It will never get here.</span>
    socket.end(<span class="hljs-string">'The message was received but was not processed.\n'</span>);
  });

}).listen(<span class="hljs-number">1337</span>);</code></pre>
<p>Prior to Node.js 0.10, the incoming message data would be simply discarded.
However, in Node.js 0.10 and beyond, the socket remains paused forever.</p>
<p>The workaround in this situation is to call the
<a href="stream.html#stream_readable_resume"><code>stream.resume()</code></a> method to begin the flow of data:</p>
<pre><code class="language-js"><span class="hljs-comment">// Workaround.</span>
net.createServer(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  socket.on(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    socket.end(<span class="hljs-string">'The message was received but was not processed.\n'</span>);
  });

  <span class="hljs-comment">// Start the flow of data, discarding it.</span>
  socket.resume();
}).listen(<span class="hljs-number">1337</span>);</code></pre>
<p>In addition to new <code>Readable</code> streams switching into flowing mode,
pre-0.10 style streams can be wrapped in a <code>Readable</code> class using the
<a href="stream.html#stream_readable_wrap_stream"><code>readable.wrap()</code></a> method.</p>
<h4><code>readable.read(0)</code><span><a class="mark" href="#stream_readable_read_0" id="stream_readable_read_0">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="readable_read_0">
                <a href="stream/readable_read_0.html" class="tip_trans">中英对照</a>
                </p>
<p>在某些情况下，需要触发底层可读流的刷新，但实际并不消费任何数据。
在这种情况下，可以调用 <code>readable.read(0)</code>，返回 <code>null</code>。</p>
<p>如果内部读取缓冲小于 <code>highWaterMark</code>，且流还未被读取，则调用 <code>stream.read(0)</code> 会触发调用底层的 <a href="stream.html#stream_readable_read_size_1"><code>stream._read()</code></a>。</p>
<p>虽然大多数应用程序几乎不需要这样做，但 Node.js 中会出现这种情况，尤其是在可读流类的内部。</p>
<h4><code>readable.push('')</code><span><a class="mark" href="#stream_readable_push" id="stream_readable_push">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="readable_push">
                <a href="stream/readable_push.html" class="tip_trans">中英对照</a>
                </p>
<p>不推荐使用 <code>readable.push('')</code>。</p>
<p>向一个非对象模式的流推入一个零字节的字符串、<code>Buffer</code> 或 <code>Uint8Array</code> 会产生副作用。
因为调用了 <a href="stream.html#stream_readable_push_chunk_encoding"><code>readable.push()</code></a>，该调用会结束读取进程。
然而，因为参数是一个空字符串，没有数据被添加到可读缓冲, 所以也就没有数据可供用户消费。</p>
<h4>调用 `readable.setEncoding()` 之后 `highWaterMark` 的差异<span><a class="mark" href="#stream_highwatermark_discrepancy_after_calling_readable_setencoding" id="stream_highwatermark_discrepancy_after_calling_readable_setencoding">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="highwatermark_discrepancy_after_calling_readable_setencoding">
                <a href="stream/highwatermark_discrepancy_after_calling_readable_setencoding.html" class="tip_trans">中英对照</a>
                </p>
<p>使用 <code>readable.setEncoding()</code> 会改变 <code>highWaterMark</code> 属性在非对象模式中的作用。</p>
<p>一般而言，当前缓冲的大小是以字节为单位跟 <code>highWaterMark</code> 比较的。
但是调用 <code>setEncoding()</code> 之后，会开始以字符为单位进行比较。</p>
<p>大多数情况下，使用 <code>latin1</code> 或 <code>ascii</code> 时是没有问题的。
但在处理含有多字节字符的字符串时，需要小心。</p></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  
  <!-- <script src="//cdn.staticfile.org/highlight.js/10.2.1/highlight.min.js"></script> -->
  
  


</body></html>