<!DOCTYPE html><html lang="zh-CN"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>ECMAScript 模块 | Node.js API 文档</title>
<link rel="icon" sizes="32x32" type="image/png" href="//img.nodejs.cn/favicon.png">
<link href="./_static/css/api.css?t=20220728214329" rel="stylesheet">
</head>
<body class="alt apidoc api_page_esm" id="page_api">
<div id="content" class="clearfix">
<div id="column2" class="interior">
<div id="intro" class="interior">
<a href="/" rel="nofollow">
Node.js 中文网
</a>
</div>
<div class="line"></div>
<ul>
<li><a href="documentation.html" class="nav-documentation" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis" rel="nofollow">用法与示例</a></li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" class="nav-async_hooks" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="buffer.html" class="nav-buffer" rel="nofollow">buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="addons.html" class="nav-addons" rel="nofollow">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api" rel="nofollow"><span style="font-size:14px;">C/C++插件(使用Node-API)</span></a></li>
<li><a href="embedding.html" class="nav-embedding" rel="nofollow">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" class="nav-cluster" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="cli.html" class="nav-cli" rel="nofollow">CLI<span class="api_nav_cn_name">命令行</span></a></li>
<li><a href="console.html" class="nav-console" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="crypto.html" class="nav-crypto" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="debugger.html" class="nav-debugger" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="deprecations.html" class="nav-deprecations" rel="nofollow">deprecation<span class="api_nav_cn_name">弃用</span></a></li>
<li><a href="dgram.html" class="nav-dgram" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="dns.html" class="nav-dns" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" class="nav-domain" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" class="nav-errors" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" class="nav-events" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" class="nav-fs" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" class="nav-globals" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" class="nav-http" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" class="nav-http2" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" class="nav-https" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" class="nav-inspector" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" class="nav-intl" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" class="nav-module" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="modules.html" class="nav-modules" rel="nofollow"><span style="font-size:14px;">module/cjs</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">CommonJS模块</span></a></li>
<li><a href="esm.html" class="nav-esm active" rel="nofollow"><span style="font-size:14px;">module/esm</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">ECMAScript模块</span></a></li>
<li><a href="packages.html" class="nav-packages" rel="nofollow"><span style="font-size:14px;">module/package</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">包模块</span></a></li>
<li><a href="net.html" class="nav-net" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" class="nav-os" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" class="nav-path" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="policy.html" class="nav-policy" rel="nofollow">policy<span class="api_nav_cn_name">安全策略</span></a></li>
<li><a href="process.html" class="nav-process" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" class="nav-punycode" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" class="nav-querystring" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" class="nav-readline" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" class="nav-repl" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" class="nav-report" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" class="nav-stream" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="string_decoder.html" class="nav-string_decoder" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" class="nav-timers" rel="nofollow">timers<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" class="nav-tls" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" class="nav-tracing" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" class="nav-tty" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" class="nav-url" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" class="nav-util" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" class="nav-v8" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" class="nav-vm" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" class="nav-wasi" rel="nofollow">wasi<span class="api_nav_cn_name">网络汇编系统接口</span></a></li>
<li><a href="worker_threads.html" class="nav-worker_threads" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" class="nav-zlib" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>
</div>
<div id="column1" data-id="esm" class="interior">
<header class="header">
<div class="header-container">
<h1>Node.js v12.22.12 文档</h1>
<button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
<svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
<path fill="none" d="M0 0h24v24H0z"></path>
<path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
<path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
</svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
<path d="M0 0h24v24H0z" fill="none"></path>
<path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
</svg>
</button>
</div>
<div id="gtoc">
<ul>
<li class="pinned-header">Node.js 12.22.12</li>
<li class="picker-header" id="header_toc">
<a href="#">
<span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
目录
</a>
<div class="picker"><div class="toc"><ul>
<li><a href="#modules-ecmascript-modules">ECMAScript 模块</a>
<ul>
<li><a href="#introduction">介绍</a></li>
<li><a href="#enabling">启用</a></li>
<li><a href="#packages">包</a></li>
<li><a href="#import-specifiers">import 说明符</a>
<ul>
<li><a href="#terminology">术语</a>
<ul>
<li><a href="#node-imports">node: 导入</a></li>
<li><a href="#data-imports">data: 导入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#importmeta"><code>import.meta</code></a></li>
<li><a href="#differences-between-es-modules-and-commonjs">ES 模块和 CommonJS 之间的差异</a>
<ul>
<li><a href="#mandatory-file-extensions">强制的文件扩展名</a></li>
<li><a href="#no-node_path">没有 NODE_PATH</a></li>
<li><a href="#no-require-exports-moduleexports-__filename-__dirname">No <code>require</code>, <code>exports</code>, <code>module.exports</code>, <code>__filename</code>, <code>__dirname</code></a></li>
<li><a href="#no-requireresolve">没有 require.resolve</a></li>
<li><a href="#no-requireextensions">没有 require.extensions</a></li>
<li><a href="#no-requirecache">没有 require.cache</a></li>
<li><a href="#url-based-paths">URL-based paths</a></li>
</ul>
</li>
<li><a href="#interoperability-with-commonjs">与 CommonJS 的互操作性</a>
<ul>
<li><a href="#require"><code>require</code></a></li>
<li><a href="#import-statements">import 声明</a></li>
<li><a href="#import-expressions">import() 表达式</a></li>
</ul>
</li>
<li><a href="#commonjs-namespaces">CommonJS 命名空间</a></li>
<li><a href="#builtin-modules">内置模块</a></li>
<li><a href="#commonjs-json-and-native-modules">CommonJS, JSON, and native modules</a></li>
<li><a href="#experimental-json-modules">Experimental JSON modules</a></li>
<li><a href="#experimental-wasm-modules">Experimental Wasm modules</a></li>
<li><a href="#experimental-loaders">Experimental loaders</a>
<ul>
<li><a href="#hooks">钩子</a>
<ul>
<li><a href="#resolvespecifier-context-defaultresolve"><code>resolve(specifier, context, defaultResolve)</code></a></li>
<li><a href="#getformaturl-context-defaultgetformat"><code>getFormat(url, context, defaultGetFormat)</code></a></li>
<li><a href="#getsourceurl-context-defaultgetsource"><code>getSource(url, context, defaultGetSource)</code></a></li>
<li><a href="#transformsourcesource-context-defaulttransformsource"><code>transformSource(source, context, defaultTransformSource)</code></a></li>
<li><a href="#getglobalpreloadcode"><code>getGlobalPreloadCode()</code></a></li>
<li><a href="#codedynamicinstantiatecode-hook"><code>dynamicInstantiate</code> hook</a></li>
</ul>
</li>
<li><a href="#examples">示例</a>
<ul>
<li><a href="#https-loader">HTTPS 加载器</a></li>
<li><a href="#transpiler-loader">转译器加载器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resolution-algorithm">解析算法</a>
<ul>
<li><a href="#features">特性</a></li>
<li><a href="#resolver-algorithm">解析器算法</a></li>
<li><a href="#resolver-algorithm-specification">解析器算法规范</a></li>
<li><a href="#customizing-esm-specifier-resolution-algorithm">自定义的 ESM 说明符解析算法</a></li>
</ul>
</li>
</ul>
</li>
</ul></div></div>
</li>
<li class="picker-header">
<a href="#">
<span class="collapsed-arrow">►</span><span class="expanded-arrow">▼</span>
索引
</a>
<div class="picker"><ul>
<li><a href="documentation.html" class="nav-documentation">关于本文档</a></li>
<li><a href="synopsis.html" class="nav-synopsis">用法与示例</a></li>
<li>
<a href="index.html">首页</a>
</li>
</ul>
<hr class="line">
<ul>
<li><a href="assert.html" class="nav-assert">assert 断言</a></li>
<li><a href="async_hooks.html" class="nav-async_hooks">async_hooks 异步钩子</a></li>
<li><a href="buffer.html" class="nav-buffer">buffer 缓冲区</a></li>
<li><a href="addons.html" class="nav-addons">C++插件</a></li>
<li><a href="n-api.html" class="nav-n-api">C/C++插件(使用Node-API)</a></li>
<li><a href="embedding.html" class="nav-embedding">C++嵌入器</a></li>
<li><a href="child_process.html" class="nav-child_process">child_process 子进程</a></li>
<li><a href="cluster.html" class="nav-cluster">cluster 集群</a></li>
<li><a href="cli.html" class="nav-cli">CLI 命令行</a></li>
<li><a href="console.html" class="nav-console">console 控制台</a></li>
<li><a href="crypto.html" class="nav-crypto">crypto 加密</a></li>
<li><a href="debugger.html" class="nav-debugger">debugger 调试器</a></li>
<li><a href="deprecations.html" class="nav-deprecations">deprecation 弃用</a></li>
<li><a href="dgram.html" class="nav-dgram">dgram 数据报</a></li>
<li><a href="dns.html" class="nav-dns">dns 域名服务器</a></li>
<li><a href="domain.html" class="nav-domain">domain 域</a></li>
<li><a href="errors.html" class="nav-errors">Error 错误</a></li>
<li><a href="events.html" class="nav-events">events 事件触发器</a></li>
<li><a href="fs.html" class="nav-fs">fs 文件系统</a></li>
<li><a href="globals.html" class="nav-globals">global 全局变量</a></li>
<li><a href="http.html" class="nav-http">http 超文本传输协议</a></li>
<li><a href="http2.html" class="nav-http2">http2 超文本传输协议2.0</a></li>
<li><a href="https.html" class="nav-https">https 安全超文本传输协议</a></li>
<li><a href="inspector.html" class="nav-inspector">inspector 检查器</a></li>
<li><a href="intl.html" class="nav-intl">Intl 国际化</a></li>
<li><a href="module.html" class="nav-module">module 模块</a></li>
<li><a href="modules.html" class="nav-modules">module/cjs CommonJS模块</a></li>
<li><a href="esm.html" class="nav-esm active">module/esm ECMAScript模块</a></li>
<li><a href="packages.html" class="nav-packages">module/package 包模块</a></li>
<li><a href="net.html" class="nav-net">net 网络</a></li>
<li><a href="os.html" class="nav-os">os 操作系统</a></li>
<li><a href="path.html" class="nav-path">path 路径</a></li>
<li><a href="perf_hooks.html" class="nav-perf_hooks">perf_hooks 性能钩子</a></li>
<li><a href="policy.html" class="nav-policy">policy 安全策略</a></li>
<li><a href="process.html" class="nav-process">process 进程</a></li>
<li><a href="punycode.html" class="nav-punycode">punycode 域名代码</a></li>
<li><a href="querystring.html" class="nav-querystring">querystring 查询字符串</a></li>
<li><a href="readline.html" class="nav-readline">readline 逐行读取</a></li>
<li><a href="repl.html" class="nav-repl">repl 交互式解释器</a></li>
<li><a href="report.html" class="nav-report">report 诊断报告</a></li>
<li><a href="stream.html" class="nav-stream">stream 流</a></li>
<li><a href="string_decoder.html" class="nav-string_decoder">string_decoder 字符串解码器</a></li>
<li><a href="timers.html" class="nav-timers">timers 定时器</a></li>
<li><a href="tls.html" class="nav-tls">tls 安全传输层</a></li>
<li><a href="tracing.html" class="nav-tracing">trace_events 跟踪事件</a></li>
<li><a href="tty.html" class="nav-tty">tty 终端</a></li>
<li><a href="url.html" class="nav-url">url 网址</a></li>
<li><a href="util.html" class="nav-util">util 实用工具</a></li>
<li><a href="v8.html" class="nav-v8">v8 引擎</a></li>
<li><a href="vm.html" class="nav-vm">vm 虚拟机</a></li>
<li><a href="wasi.html" class="nav-wasi">wasi 网络汇编系统接口</a></li>
<li><a href="worker_threads.html" class="nav-worker_threads">worker_threads 工作线程</a></li>
<li><a href="zlib.html" class="nav-zlib">zlib 压缩</a></li>
</ul></div>
</li>
<li class="picker-header">
<a href="#">
<span class="collapsed-arrow">&#x25ba;</span><span class="expanded-arrow">&#x25bc;</span>
其他版本
</a>
<div class="picker"><ol id="alt-docs">
<li><a href="/api/esm.html">18.7.0</a></li><li><a href="/api-v16/esm.html">16.16.0</a></li><li><a href="/api-v14/esm.html">14.20.0</a></li><li><a href="/api-v12/esm.html">12.22.12</a></li>
</ol></div>
</li>
<li>
<a href="http://api.nodejs.cn/?v=12">文档搜索</a>
</li>
</ul>
</div>
<hr>
</header>
<details id="toc" open=""><summary>目录</summary><ul>
<li><a href="#modules-ecmascript-modules">ECMAScript 模块</a>
<ul>
<li><a href="#introduction">介绍</a></li>
<li><a href="#enabling">启用</a></li>
<li><a href="#packages">包</a></li>
<li><a href="#import-specifiers">import 说明符</a>
<ul>
<li><a href="#terminology">术语</a>
<ul>
<li><a href="#node-imports">node: 导入</a></li>
<li><a href="#data-imports">data: 导入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#importmeta"><code>import.meta</code></a></li>
<li><a href="#differences-between-es-modules-and-commonjs">ES 模块和 CommonJS 之间的差异</a>
<ul>
<li><a href="#mandatory-file-extensions">强制的文件扩展名</a></li>
<li><a href="#no-node_path">没有 NODE_PATH</a></li>
<li><a href="#no-require-exports-moduleexports-__filename-__dirname">No <code>require</code>, <code>exports</code>, <code>module.exports</code>, <code>__filename</code>, <code>__dirname</code></a></li>
<li><a href="#no-requireresolve">没有 require.resolve</a></li>
<li><a href="#no-requireextensions">没有 require.extensions</a></li>
<li><a href="#no-requirecache">没有 require.cache</a></li>
<li><a href="#url-based-paths">URL-based paths</a></li>
</ul>
</li>
<li><a href="#interoperability-with-commonjs">与 CommonJS 的互操作性</a>
<ul>
<li><a href="#require"><code>require</code></a></li>
<li><a href="#import-statements">import 声明</a></li>
<li><a href="#import-expressions">import() 表达式</a></li>
</ul>
</li>
<li><a href="#commonjs-namespaces">CommonJS 命名空间</a></li>
<li><a href="#builtin-modules">内置模块</a></li>
<li><a href="#commonjs-json-and-native-modules">CommonJS, JSON, and native modules</a></li>
<li><a href="#experimental-json-modules">Experimental JSON modules</a></li>
<li><a href="#experimental-wasm-modules">Experimental Wasm modules</a></li>
<li><a href="#experimental-loaders">Experimental loaders</a>
<ul>
<li><a href="#hooks">钩子</a>
<ul>
<li><a href="#resolvespecifier-context-defaultresolve"><code>resolve(specifier, context, defaultResolve)</code></a></li>
<li><a href="#getformaturl-context-defaultgetformat"><code>getFormat(url, context, defaultGetFormat)</code></a></li>
<li><a href="#getsourceurl-context-defaultgetsource"><code>getSource(url, context, defaultGetSource)</code></a></li>
<li><a href="#transformsourcesource-context-defaulttransformsource"><code>transformSource(source, context, defaultTransformSource)</code></a></li>
<li><a href="#getglobalpreloadcode"><code>getGlobalPreloadCode()</code></a></li>
<li><a href="#codedynamicinstantiatecode-hook"><code>dynamicInstantiate</code> hook</a></li>
</ul>
</li>
<li><a href="#examples">示例</a>
<ul>
<li><a href="#https-loader">HTTPS 加载器</a></li>
<li><a href="#transpiler-loader">转译器加载器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resolution-algorithm">解析算法</a>
<ul>
<li><a href="#features">特性</a></li>
<li><a href="#resolver-algorithm">解析器算法</a></li>
<li><a href="#resolver-algorithm-specification">解析器算法规范</a></li>
<li><a href="#customizing-esm-specifier-resolution-algorithm">自定义的 ESM 说明符解析算法</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>
<div id="apicontent">
<h2>ECMAScript 模块<span><a class="mark" href="#modules-ecmascript-modules" id="modules-ecmascript-modules">#</a></span><a aria-hidden="true" class="legacy" id="esm_modules_ecmascript_modules"></a></h2><p class="tip_wrap" data-show_trans="1" data-item_id="#modules-ecmascript-modules">
<a href="esm/modules_ecmascript_modules.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.22.0</td>
<td><p>稳定模块实现。</p></td></tr>
<tr><td>v12.20.0</td>
<td><p>支持检测 CommonJS 命名导出。</p></td></tr>
<tr><td>v12.20.0</td>
<td><p>删除实验的模块警告。</p></td></tr>
<tr><td>v12.17.0</td>
<td><p>加载 ECMAScript 模块不再需要命令行标志。</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>通过 <code>package.json</code> <code>"type"</code> 字段添加对使用 <code>.js</code> 文件扩展名的 ES 模块的支持。</p></td></tr>
<tr><td>v8.5.0</td>
<td><p><span>新增于: v8.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<p></p><div class="api_stability api_stability_2"><a href="/api/documentation.html#stability-index">稳定性: 2</a> - 稳定</div><p></p>
<section><h3>介绍<span><a class="mark" href="#introduction" id="introduction">#</a></span><a aria-hidden="true" class="legacy" id="esm_introduction"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#introduction">
<a href="esm/introduction.html" class="tip_trans">中英对照</a>
</p>
<p>ECMAScript 模块是来打包 JavaScript 代码以供重用的<a href="http://url.nodejs.cn/JQY1wd" rel="nofollow" target="_blank">官方标准格式</a>。
模块使用各种 <a href="http://url.nodejs.cn/otfx5w" rel="nofollow" target="_blank"><code>import</code></a> 和 <a href="http://url.nodejs.cn/JNCjeW" rel="nofollow" target="_blank"><code>export</code></a> 语句定义。</p>
<p>以下是 ES 模块导出函数的示例：</p>
<pre><code class="language-js"><span class="hljs-comment">// addTwo.mjs</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addTwo</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">export</span> { addTwo };</code></pre>
<p>以下是 ES 模块从 <code>addTwo.mjs</code> 导入函数的示例：</p>
<pre><code class="language-js"><span class="hljs-comment">// app.mjs</span>
<span class="hljs-keyword">import</span> { addTwo } <span class="hljs-keyword">from</span> <span class="hljs-string">'./addTwo.mjs'</span>;

<span class="hljs-comment">// 打印: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addTwo</span>(<span class="hljs-number">4</span>));</code></pre>
<p>Node.js 完全支持当前指定的 ECMAScript 模块，并且提供它们与其原始模块格式 <a href="modules.html">CommonJS</a> 之间的互操作性。</p>
<p><i id="#esm_package_json_type_field"></i>
<i id="#esm_package_scope_and_file_extensions"></i>
<i id="#esm_input_type_flag"></i></p>
</section><section><h3>启用<span><a class="mark" href="#enabling" id="enabling">#</a></span><a aria-hidden="true" class="legacy" id="esm_enabling"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#enabling">
<a href="esm/enabling.html" class="tip_trans">中英对照</a>
</p>
<p>Node.js 默认将 JavaScript 代码视为 CommonJS 模块。
作者可以通过 <code>.mjs</code> 文件扩展名、<code>package.json</code> <a href="packages.html#packages_type"><code>"type"</code></a> 字段、或 <code>--input-type</code> 标志告诉 Node.js 将 JavaScript 代码视为 ECMAScript 模块。</p>
<p><i id="esm_package_entry_points"></i>
<i id="esm_main_entry_point_export"></i>
<i id="esm_subpath_exports"></i>
<i id="esm_package_exports_fallbacks"></i>
<i id="esm_exports_sugar"></i>
<i id="esm_conditional_exports"></i>
<i id="esm_nested_conditions"></i>
<i id="esm_self_referencing_a_package_using_its_name"></i>
<i id="esm_internal_package_imports"></i>
<i id="esm_dual_commonjs_es_module_packages"></i>
<i id="esm_dual_package_hazard"></i>
<i id="esm_writing_dual_packages_while_avoiding_or_minimizing_hazards"></i>
<i id="esm_approach_1_use_an_es_module_wrapper"></i>
<i id="esm_approach_2_isolate_state"></i></p>
</section><section><h3>包<span><a class="mark" href="#packages" id="packages">#</a></span><a aria-hidden="true" class="legacy" id="esm_packages"></a></h3><p class="tip_wrap"></p>
<p>This section was moved to <a href="packages.html">Modules: Packages</a>.</p>
</section><section><h3>import 说明符<span><a class="mark" href="#import-specifiers" id="import-specifiers">#</a></span><a aria-hidden="true" class="legacy" id="esm_import_specifiers"></a></h3>
<h4>术语<span><a class="mark" href="#terminology" id="terminology">#</a></span><a aria-hidden="true" class="legacy" id="esm_terminology"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#terminology">
<a href="esm/terminology.html" class="tip_trans">中英对照</a>
</p>
<p><code>import</code> 语句的说明符是 <code>from</code> 关键字之后的字符串，例如 <code>import { sep } from 'path'</code> 中的 <code>'path'</code>。
说明符也用于 <code>export from</code> 语句，并作为 <code>import()</code> 表达式的参数。</p>
<ul>
<li></li>
<li></li>
<li>
<p>相对说明符，如 <code>'./startup.js'</code> 或 <code>'../config.mjs'</code>。
它们指的是相对于导入文件位置的路径。</p>
</li>
<li>
<p>绝对说明符，如 <code>'file:///opt/nodejs/config.js'</code>。
它们直接且明确地引用完整的路径。</p>
</li>
</ul>
<h5>node: 导入<span><a class="mark" href="#node-imports" id="node-imports">#</a></span><a aria-hidden="true" class="legacy" id="esm_node_imports"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#node-imports">
<a href="esm/node_imports.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v12.20.0</span>
</div>
<p>此 URL 协议允许有效的绝对的 URL 字符串引用内置模块。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'node:fs/promises'</span>;</code></pre>
<h5>data: 导入<span><a class="mark" href="#data-imports" id="data-imports">#</a></span><a aria-hidden="true" class="legacy" id="esm_data_imports"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#data-imports">
<a href="esm/data_imports.html" class="tip_trans">中英对照</a>
</p>
<div class="api_metadata">
<span>新增于: v12.10.0</span>
</div>
<p><a href="http://url.nodejs.cn/3Lb3vH" rel="nofollow" target="_blank"><code>data:</code> URL</a> 支持使用以下 MIME 类型导入：</p>
<ul>
<li><code>text/javascript</code> 用于 ES 模块</li>
<li><code>application/json</code> 用于 JSON</li>
<li><code>application/wasm</code> 用于 Wasm</li>
</ul>
<p><code>data:</code> URL 只为内置模块解析<a href="/api-v12/esm.html#esm_terminology">裸说明符</a>和<a href="/api-v12/esm.html#esm_terminology">绝对说明符</a>。
解析<a href="/api-v12/esm.html#esm_terminology">相对说明符</a>不起作用，因为 <code>data:</code> 不是<a href="http://url.nodejs.cn/fbSryY" rel="nofollow" target="_blank">特殊协议</a>。
例如，尝试从 <code>data:text/javascript,import "./foo";</code> 加载 <code>./foo</code> 无法解析，因为 <code>data:</code> URL 没有相对解析的概念。
正在使用的 <code>data:</code> URL 示例是：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'data:text/javascript,console.log("hello!");'</span>;
<span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'data:application/json,"world!"'</span>;</code></pre>
</section><section><h3><code>import.meta</code><span><a class="mark" href="#importmeta" id="importmeta">#</a></span><a aria-hidden="true" class="legacy" id="esm_import_meta"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#importmeta">
<a href="esm/import_meta.html" class="tip_trans">中英对照</a>
</p>
<ul>
<li>
<p><a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a></p>
</li>
<li>
<p><code>url</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> 模块的绝对的 <code>file:</code> URL。</p>
</li>
</ul>
</section><section><h3>ES 模块和 CommonJS 之间的差异<span><a class="mark" href="#differences-between-es-modules-and-commonjs" id="differences-between-es-modules-and-commonjs">#</a></span><a aria-hidden="true" class="legacy" id="esm_differences_between_es_modules_and_commonjs"></a></h3>
<h4>强制的文件扩展名<span><a class="mark" href="#mandatory-file-extensions" id="mandatory-file-extensions">#</a></span><a aria-hidden="true" class="legacy" id="esm_mandatory_file_extensions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#mandatory-file-extensions">
<a href="esm/mandatory_file_extensions.html" class="tip_trans">中英对照</a>
</p>
<p>还必须完全指定目录索引（例如 <code>'./startup/index.js'</code>）。</p>
<p>此行为与 <code>import</code> 在浏览器环境中的行为方式相匹配，假设服务器是典型配置的。</p>
<h4>没有 NODE_PATH<span><a class="mark" href="#no-node_path" id="no-node_path">#</a></span><a aria-hidden="true" class="legacy" id="esm_no_node_path"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#no-node_path">
<a href="esm/no_node_path.html" class="tip_trans">中英对照</a>
</p>
<p><code>NODE_PATH</code> 不是解析 <code>import</code> 说明符的一部分。
如果需要这种行为，则使用符号链接。</p>
<h4>No <code>require</code>, <code>exports</code>, <code>module.exports</code>, <code>__filename</code>, <code>__dirname</code><span><a class="mark" href="#no-require-exports-moduleexports-__filename-__dirname" id="no-require-exports-moduleexports-__filename-__dirname">#</a></span><a aria-hidden="true" class="legacy" id="esm_no_require_exports_module_exports_filename_dirname"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#no-require-exports-moduleexports-__filename-__dirname">
<a href="esm/no_require_exports_module_exports_filename_dirname.html" class="tip_trans">中英对照</a>
</p>
<p>这些 CommonJS 变量在 ES 模块中不可用。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;
<span class="hljs-keyword">import</span> { dirname } <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;

<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);
<span class="hljs-keyword">const</span> __dirname = <span class="hljs-title function_">dirname</span>(__filename);</code></pre>
<h4>没有 require.resolve<span><a class="mark" href="#no-requireresolve" id="no-requireresolve">#</a></span><a aria-hidden="true" class="legacy" id="esm_no_require_resolve"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#no-requireresolve">
<a href="esm/no_require_resolve.html" class="tip_trans">中英对照</a>
</p>
<pre><code class="language-js">(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> dependencyAsset = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'component-lib/asset.css'</span>);
})();</code></pre>
<p><code>import.meta.resolve</code> 还接受第二个参数，它是从中解析的父模块：</p>
<pre><code class="language-js">(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// </span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">'./dep'</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);
})();</code></pre>
<h4>没有 require.extensions<span><a class="mark" href="#no-requireextensions" id="no-requireextensions">#</a></span><a aria-hidden="true" class="legacy" id="esm_no_require_extensions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#no-requireextensions">
<a href="esm/no_require_extensions.html" class="tip_trans">中英对照</a>
</p>
<p><code>require.extensions</code> 没有被 <code>import</code> 使用。
期望加载器钩子在未来可以提供这个工作流。</p>
<h4>没有 require.cache<span><a class="mark" href="#no-requirecache" id="no-requirecache">#</a></span><a aria-hidden="true" class="legacy" id="esm_no_require_cache"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#no-requirecache">
<a href="esm/no_require_cache.html" class="tip_trans">中英对照</a>
</p>
<p><code>require.cache</code> 没有被 <code>import</code> 使用。</p>
<h4>URL-based paths<span><a class="mark" href="#url-based-paths" id="url-based-paths">#</a></span><a aria-hidden="true" class="legacy" id="esm_url_based_paths"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#url-based-paths">
<a href="esm/url_based_paths.html" class="tip_trans">中英对照</a>
</p>
<p>这意味着包含 <code>#</code> 和 <code>?</code> 等特殊字符的文件需要转义。</p>
<p>如果用于解析模块的 <code>import</code> 说明符具有不同的查询或片段，则会多次加载模块。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'./foo.mjs?query=1'</span>; <span class="hljs-comment">// 加载具有 "?query=1" 查询的 ./foo.mjs</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./foo.mjs?query=2'</span>; <span class="hljs-comment">// 加载具有 "?query=2" 查询的 ./foo.mjs</span></code></pre>
</section><section><h3>与 CommonJS 的互操作性<span><a class="mark" href="#interoperability-with-commonjs" id="interoperability-with-commonjs">#</a></span><a aria-hidden="true" class="legacy" id="esm_interoperability_with_commonjs"></a></h3>
<h4><code>require</code><span><a class="mark" href="#require" id="require">#</a></span><a aria-hidden="true" class="legacy" id="esm_require"></a></h4><p class="tip_wrap"></p>
<p><code>require</code> always treats the files it references as CommonJS. This applies
whether <code>require</code> is used the traditional way within a CommonJS environment, or
in an ES module environment using <a href="module.html#module_module_createrequire_filename"><code>module.createRequire()</code></a>.</p>
<p>To include an ES module into CommonJS, use <a href="/api-v12/esm.html#esm_import_expressions"><code>import()</code></a>.</p>
<h4>import 声明<span><a class="mark" href="#import-statements" id="import-statements">#</a></span><a aria-hidden="true" class="legacy" id="esm_import_statements"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#import-statements">
<a href="esm/import_statements.html" class="tip_trans">中英对照</a>
</p>
<p><code>import</code> 语句可以引用 ES 模块或 CommonJS 模块。</p>
<p>当导入 <a href="/api-v12/esm.html#esm_commonjs_namespaces">CommonJS 模块</a> 时，提供 <code>module.exports</code> 对象作为默认导出。
命名导出可能可用，由静态分析提供，以方便更好的生态系统兼容性。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { sin, cos } <span class="hljs-keyword">from</span> <span class="hljs-string">'geometry/trigonometry-functions.mjs'</span>;</code></pre>
<h4>import() 表达式<span><a class="mark" href="#import-expressions" id="import-expressions">#</a></span><a aria-hidden="true" class="legacy" id="esm_import_expressions"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#import-expressions">
<a href="esm/import_expressions.html" class="tip_trans">中英对照</a>
</p>
<p><a href="http://url.nodejs.cn/4WGpC7" rel="nofollow" target="_blank">动态的 <code>import()</code></a> 在 CommonJS 和 ES 模块中都受支持。</p>
</section><section><h3>CommonJS 命名空间<span><a class="mark" href="#commonjs-namespaces" id="commonjs-namespaces">#</a></span><a aria-hidden="true" class="legacy" id="esm_commonjs_namespaces"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#commonjs-namespaces">
<a href="esm/commonjs_namespaces.html" class="tip_trans">中英对照</a>
</p>
<p>CommonJS 模块由可以是任何类型的 <code>module.exports</code> 对象组成。</p>
<p>当导入 CommonJS 模块时，可以使用 ES 模块默认导入或其对应的语法糖可靠地导入：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> cjs } <span class="hljs-keyword">from</span> <span class="hljs-string">'cjs'</span>;

<span class="hljs-comment">// 下面的导入语句是上面的导入语句中</span>
<span class="hljs-comment">// `{ default as cjsSugar }` 的 "语法糖"（等价但更甜）：</span>
<span class="hljs-keyword">import</span> cjsSugar <span class="hljs-keyword">from</span> <span class="hljs-string">'cjs'</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cjs);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cjs === cjsSugar);
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   &lt;module.exports&gt;</span>
<span class="hljs-comment">//   true</span></code></pre>
<p>CommonJS 模块的 ECMAScript 模块命名空间表示始终是使用 <code>default</code> 导出键指向 CommonJS <code>module.exports</code> 值的命名空间。</p>
<p>当使用 <code>import * as m from 'cjs'</code> 或动态导入时，可以直接观察到此模块命名空间外来对象：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m <span class="hljs-keyword">from</span> <span class="hljs-string">'cjs'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m === <span class="hljs-keyword">await</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">'cjs'</span>));
<span class="hljs-comment">// 打印:</span>
<span class="hljs-comment">//   [Module] { default: &lt;module.exports&gt; }</span>
<span class="hljs-comment">//   true</span></code></pre>
<p>为了更好地兼容 JS 生态系统中的现有用法，Node.js 还尝试确定每个导入的 CommonJS 模块的 CommonJS 命名导出，以使用静态分析过程将它们作为单独的 ES 模块导出提供。</p>
<p>例如，考虑编写的 CommonJS 模块：</p>
<pre><code class="language-js"><span class="hljs-comment">// cjs.cjs</span>
<span class="hljs-built_in">exports</span>.<span class="hljs-property">name</span> = <span class="hljs-string">'exported'</span>;</code></pre>
<p>前面的模块支持 ES 模块中的命名导入：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { name } <span class="hljs-keyword">from</span> <span class="hljs-string">'./cjs.cjs'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);
<span class="hljs-comment">// 打印: 'exported'</span>

<span class="hljs-keyword">import</span> cjs <span class="hljs-keyword">from</span> <span class="hljs-string">'./cjs.cjs'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cjs);
<span class="hljs-comment">// 打印: { name: 'exported' }</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m <span class="hljs-keyword">from</span> <span class="hljs-string">'./cjs.cjs'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m);
<span class="hljs-comment">// 打印: [Module] { default: { name: 'exported' }, name: 'exported' }</span></code></pre>
<p>从上一个记录模块命名空间外来对象的示例中可以看出，<code>name</code> 导出是从 <code>module.exports</code> 对象复制出来的，并在导入模块时直接设置在 ES 模块命名空间上。</p>
<p>未检测到这些命名导出的实时绑定更新或添加到 <code>module.exports</code> 的新导出。</p>
<p>命名导出的检测基于通用语法模式，但并不总是正确地检测命名导出。
在这些情况下，使用上述默认导入形式可能是更好的选择。</p>
<p>命名导出检测涵盖了许多常见的导出模式、再导出模式、以及构建工具和转译器输出。
参阅 <a href="http://url.nodejs.cn/ecpd1v" rel="nofollow" target="_blank">cjs-module-lexer</a> 以了解实现的确切语义。</p>
</section><section><h3>内置模块<span><a class="mark" href="#builtin-modules" id="builtin-modules">#</a></span><a aria-hidden="true" class="legacy" id="esm_builtin_modules"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#builtin-modules">
<a href="esm/builtin_modules.html" class="tip_trans">中英对照</a>
</p>
<p><a href="modules.html#modules_core_modules">核心模块</a>提供了其公共 API 的命名导出。
还提供了默认导出，其是 CommonJS 导出的值。
默认导出可用于修改命名导出等。
内置模块的命名导出仅通过调用 <a href="module.html#module_module_syncbuiltinesmexports"><code>module.syncBuiltinESMExports()</code></a> 进行更新。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">EventEmitter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'events'</span>;
<span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { readFile } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'./foo.txt'</span>, <span class="hljs-function">(<span class="hljs-params">err, source</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(source);
  }
});</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> fs, { readFileSync } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> { syncBuiltinESMExports } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;

fs.<span class="hljs-property">readFileSync</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello, ESM'</span>);
<span class="hljs-title function_">syncBuiltinESMExports</span>();

fs.<span class="hljs-property">readFileSync</span> === readFileSync;</code></pre>
</section><section><h3>CommonJS, JSON, and native modules<span><a class="mark" href="#commonjs-json-and-native-modules" id="commonjs-json-and-native-modules">#</a></span><a aria-hidden="true" class="legacy" id="esm_commonjs_json_and_native_modules"></a></h3><p class="tip_wrap"></p>
<p>CommonJS, JSON, and native modules can be used with
<a href="module.html#module_module_createrequire_filename"><code>module.createRequire()</code></a>.</p>
<pre><code class="language-js"><span class="hljs-comment">// cjs.cjs</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-string">'cjs'</span>;

<span class="hljs-comment">// esm.mjs</span>
<span class="hljs-keyword">import</span> { createRequire } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-built_in">require</span> = <span class="hljs-title function_">createRequire</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>);

<span class="hljs-keyword">const</span> cjs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./cjs.cjs'</span>);
cjs === <span class="hljs-string">'cjs'</span>; <span class="hljs-comment">// true</span></code></pre>
</section><section><h3>Experimental JSON modules<span><a class="mark" href="#experimental-json-modules" id="experimental-json-modules">#</a></span><a aria-hidden="true" class="legacy" id="esm_experimental_json_modules"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#experimental-json-modules">
<a href="esm/experimental_json_modules.html" class="tip_trans">中英对照</a>
</p>
<p>目前导入 JSON 模块仅支持 <code>commonjs</code> 模式，并且使用 CJS 加载器加载。
<a href="http://url.nodejs.cn/xZrkEh" rel="nofollow" target="_blank">WHATWG JSON 模块规范</a>仍在标准化中，并且通过在运行 Node.js 时包含额外的标志 <code>--experimental-json-modules</code> 进行实验性地支持。</p>
<p>当包含 <code>--experimental-json-modules</code> 标志时，<code>commonjs</code> 和 <code>module</code> 模式都使用新的实验性 JSON 加载器。
导入的 JSON 只暴露 <code>default</code>。
不支持命名导出。
在 CommonJS 缓存中创建缓存条目，以避免重复。
如果 JSON 模块已经从同一路径导入，则在 CommonJS 中返回相同的对象。</p>
<p>假设 <code>index.mjs</code> 具有</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> packageConfig <span class="hljs-keyword">from</span> <span class="hljs-string">'./package.json'</span>;</code></pre>
<p>模块需要 <code>--experimental-json-modules</code> 标志才有效。</p>
<pre><code class="language-bash">node index.mjs <span class="hljs-comment"># 失败</span>
node --experimental-json-modules index.mjs <span class="hljs-comment"># 有效</span></code></pre>
</section><section><h3>Experimental Wasm modules<span><a class="mark" href="#experimental-wasm-modules" id="experimental-wasm-modules">#</a></span><a aria-hidden="true" class="legacy" id="esm_experimental_wasm_modules"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#experimental-wasm-modules">
<a href="esm/experimental_wasm_modules.html" class="tip_trans">中英对照</a>
</p>
<p>在 <code>--experimental-wasm-modules</code> 标志下支持导入 Web Assembly 模块，允许将任何 <code>.wasm</code> 文件作为普通模块导入，同时还支持它们的模块导入。</p>
<p>此集成符合<a href="http://url.nodejs.cn/3w7yUG" rel="nofollow" target="_blank">用于 Web Assembly 的 ES 模块集成提案</a>。</p>
<p>例如，<code>index.mjs</code> 包含：</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> M <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.wasm'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(M);</code></pre>
<p>在以下条件下执行：</p>
<pre><code class="language-bash">node --experimental-wasm-modules index.mjs</code></pre>
<p>将为 <code>module.wasm</code> 的实例化提供导出接口。</p>
</section><section><h3>Experimental loaders<span><a class="mark" href="#experimental-loaders" id="experimental-loaders">#</a></span><a aria-hidden="true" class="legacy" id="esm_experimental_loaders"></a></h3><p class="tip_wrap" data-show_trans="1" data-item_id="#experimental-loaders">
<a href="esm/experimental_loaders.html" class="tip_trans">中英对照</a>
</p>
<p><strong>注意：此 API 目前正在重新设计，并将继续更改。</strong></p>
<p>要自定义默认的模块解析，则可以选择通过 Node.js 的 <code>--experimental-loader ./loader-name.mjs</code> 参数提供加载器钩子。</p>
<p>当使用钩子时，只适用于 ES 模块加载，而不适用于任何加载的 CommonJS 模块。</p>
<h4>钩子<span><a class="mark" href="#hooks" id="hooks">#</a></span><a aria-hidden="true" class="legacy" id="esm_hooks"></a></h4>
<h5><code>resolve(specifier, context, defaultResolve)</code><span><a class="mark" href="#resolvespecifier-context-defaultresolve" id="resolvespecifier-context-defaultresolve">#</a></span><a aria-hidden="true" class="legacy" id="esm_resolve_specifier_context_defaultresolve"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#resolvespecifier-context-defaultresolve">
<a href="esm/resolve_specifier_context_defaultresolve.html" class="tip_trans">中英对照</a>
</p>
<blockquote>
<p>注意：加载器 API 正在重新设计。 这个钩子可能会消失，或者它的签名可能会改变。 不要依赖下面描述的 API。</p>
</blockquote>
<ul>
<li><code>specifier</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
<li><code>context</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a>
<ul>
<li><code>conditions</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string[]&gt;</a></li>
<li><code>parentURL</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
</ul>
</li>
<li><code>defaultResolve</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a>
<ul>
<li><code>url</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
</ul>
</li>
</ul>
<p><code>resolve</code> 钩子返回给定模块说明符和父 URL 的解析文件 URL。
模块说明符是 <code>import</code> 语句或 <code>import()</code> 表达式中的字符串，父 URL 是导入此模块的 URL，如果这是应用程序的主要入口点，则为 <code>undefined</code></p>
<p><code>context</code> 上的 <code>conditions</code> 属性是适用于此解析请求的<a href="packages.html#packages_conditional_exports">条件导出</a>的条件数组。
它们可用于在别处查找条件映射或在调用默认解析逻辑时修改列表。</p>
<p>当前的<a href="packages.html#packages_conditional_exports">包导出条件</a>始终在传入钩子的 <code>context.conditions</code> 数组中。
为了在调用 <code>defaultResolve</code> 时保证默认的 Node.js 模块说明符解析行为，传给它的 <code>context.conditions</code> 数组必须包含最初传到 <code>resolve</code> 钩子的 <code>context.conditions</code> 数组的所有元素。</p>
<pre><code class="language-js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">specifier</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{
 *   conditions: !Array&lt;string&gt;,
 *   parentURL: !(string | undefined),
 * </span>}} context
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">defaultResolve</span>
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;{ url: string </span>}&gt;}
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">specifier, context, defaultResolve</span>) {
  <span class="hljs-keyword">const</span> { parentURL = <span class="hljs-literal">null</span> } = context;
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>) { <span class="hljs-comment">// 一些条件。</span>
    <span class="hljs-comment">// 对于部分或全部说明符，做一些自定义逻辑来解决。</span>
    <span class="hljs-comment">// 总是返回 {url: &lt;string&gt;} 形式的对象。</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">url</span>: parentURL ?
        <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(specifier, parentURL).<span class="hljs-property">href</span> :
        <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(specifier).<span class="hljs-property">href</span>,
    };
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &lt; <span class="hljs-number">0.5</span>) { <span class="hljs-comment">// 另一个条件。</span>
    <span class="hljs-comment">// 当调用 `defaultResolve` 时，可以修改参数。</span>
    <span class="hljs-comment">// 在这种情况下，它为匹配条件导出添加了另一个值。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultResolve</span>(specifier, {
      ...context,
      <span class="hljs-attr">conditions</span>: [...context.<span class="hljs-property">conditions</span>, <span class="hljs-string">'another-condition'</span>],
    });
  }
  <span class="hljs-comment">// 对于所有其他说明符，请遵循 Node.js。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultResolve</span>(specifier, context, defaultResolve);
}</code></pre>
<h5><code>getFormat(url, context, defaultGetFormat)</code><span><a class="mark" href="#getformaturl-context-defaultgetformat" id="getformaturl-context-defaultgetformat">#</a></span><a aria-hidden="true" class="legacy" id="esm_getformat_url_context_defaultgetformat"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#getformaturl-context-defaultgetformat">
<a href="esm/getformat_url_context_defaultgetformat.html" class="tip_trans">中英对照</a>
</p>
<blockquote>
<p>注意：加载器 API 正在重新设计。 这个钩子可能会消失，或者它的签名可能会改变。 不要依赖下面描述的 API。</p>
</blockquote>
<ul>
<li><code>url</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
<li><code>context</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a></li>
<li><code>defaultGetFormat</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a>
<ul>
<li><code>format</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
</ul>
</li>
</ul>
<p><code>getFormat</code> 钩子提供了一种方式来定义确定网址应如何解释的自定义方法。
返回的 <code>format</code> 也会影响解析时模块的可接受的源值形式。
这可以是以下之一：</p>
<table><thead><tr><th><code>format</code></th><th>描述</th><th><code>getSource</code> 或 <code>transformSource</code> 返回的 <code>source</code> 的可接受类型</th></tr></thead><tbody><tr><td><code>'builtin'</code></td><td>加载 Node.js 内置模块</td><td>不适用</td></tr><tr><td><code>'dynamic'</code></td><td>Use a <a href="/api-v12/esm.html#esm_code_dynamicinstantiate_code_hook">dynamic instantiate hook</a></td><td>不适用</td></tr><tr><td><code>'commonjs'</code></td><td>加载 Node.js CommonJS 模块</td><td>不适用</td></tr><tr><td><code>'json'</code></td><td>加载 JSON 文件</td><td>{ <a href="http://url.nodejs.cn/NmKbqJ" rel="nofollow" target="_blank"><code>string</code></a>, <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" target="_blank"><code>ArrayBuffer</code></a>, <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" target="_blank"><code>TypedArray</code></a> }</td></tr><tr><td><code>'module'</code></td><td>加载 ES 模块</td><td>{ <a href="http://url.nodejs.cn/NmKbqJ" rel="nofollow" target="_blank"><code>string</code></a>, <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" target="_blank"><code>ArrayBuffer</code></a>, <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" target="_blank"><code>TypedArray</code></a> }</td></tr><tr><td><code>'wasm'</code></td><td>加载 WebAssembly 模块</td><td>{ <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" target="_blank"><code>ArrayBuffer</code></a>, <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" target="_blank"><code>TypedArray</code></a> }</td></tr></tbody></table>
<p>注意：这些类型都对应于 ECMAScript 中定义的类。</p>
<ul>
<li>特定的 <a href="http://url.nodejs.cn/mUbfvF" rel="nofollow" target="_blank"><code>ArrayBuffer</code></a> 对象是 <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" target="_blank"><code>SharedArrayBuffer</code></a>。</li>
<li>特定的 <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" target="_blank"><code>TypedArray</code></a> 对象是 <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" target="_blank"><code>Uint8Array</code></a>。</li>
</ul>
<p>注意：如果基于文本的格式（即 <code>'json'</code>、<code>'module'</code>）的源值不是字符串，则使用 <a href="http://url.nodejs.cn/GF1K8i" rel="nofollow" target="_blank"><code>util.TextDecoder</code></a> 将其转换为字符串。</p>
<pre><code class="language-js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} context (currently empty)
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">defaultGetFormat</span>
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;{ format: string </span>}&gt;}
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFormat</span>(<span class="hljs-params">url, context, defaultGetFormat</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>) { <span class="hljs-comment">// 一些条件。</span>
    <span class="hljs-comment">// 对于部分或所有 URL，执行一些自定义逻辑来确定格式。</span>
    <span class="hljs-comment">// 始终返回 {format: &lt;string&gt;} 形式的对象，</span>
    <span class="hljs-comment">// 其中格式是上表中的字符串之一。</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">format</span>: <span class="hljs-string">'module'</span>,
    };
  }
  <span class="hljs-comment">// 所有其他 URL 都遵循 Node.js。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultGetFormat</span>(url, context, defaultGetFormat);
}</code></pre>
<h5><code>getSource(url, context, defaultGetSource)</code><span><a class="mark" href="#getsourceurl-context-defaultgetsource" id="getsourceurl-context-defaultgetsource">#</a></span><a aria-hidden="true" class="legacy" id="esm_getsource_url_context_defaultgetsource"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#getsourceurl-context-defaultgetsource">
<a href="esm/getsource_url_context_defaultgetsource.html" class="tip_trans">中英对照</a>
</p>
<blockquote>
<p>注意：加载器 API 正在重新设计。 这个钩子可能会消失，或者它的签名可能会改变。 不要依赖下面描述的 API。</p>
</blockquote>
<ul>
<li><code>url</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
<li><code>context</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a>
<ul>
<li><code>format</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
</ul>
</li>
<li><code>defaultGetSource</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type" target="_blank">&lt;Function&gt;</a></li>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a>
<ul>
<li><code>source</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type" target="_blank">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" class="type" target="_blank">&lt;Uint8Array&gt;</a></li>
</ul>
</li>
</ul>
<p><code>getSource</code> 钩子提供了一种方法来定义用于检索 ES 模块说明符的源代码的自定义方法。
这将允许加载器潜在地避免从磁盘读取文件。</p>
<pre><code class="language-js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{ format: string </span>}} context
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">defaultGetSource</span>
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;{ source: !(string | SharedArrayBuffer | Uint8Array) </span>}&gt;}
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSource</span>(<span class="hljs-params">url, context, defaultGetSource</span>) {
  <span class="hljs-keyword">const</span> { format } = context;
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>) { <span class="hljs-comment">// 一些条件。</span>
    <span class="hljs-comment">// 对于部分或所有 URL，执行一些自定义逻辑来检索源。</span>
    <span class="hljs-comment">// 总是返回 {source: &lt;string|buffer&gt;} 形式的对象。</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">source</span>: <span class="hljs-string">'...'</span>,
    };
  }
  <span class="hljs-comment">// 所有其他 URL 都遵循 Node.js。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultGetSource</span>(url, context, defaultGetSource);
}</code></pre>
<h5><code>transformSource(source, context, defaultTransformSource)</code><span><a class="mark" href="#transformsourcesource-context-defaulttransformsource" id="transformsourcesource-context-defaulttransformsource">#</a></span><a aria-hidden="true" class="legacy" id="esm_transformsource_source_context_defaulttransformsource"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#transformsourcesource-context-defaulttransformsource">
<a href="esm/transformsource_source_context_defaulttransformsource.html" class="tip_trans">中英对照</a>
</p>
<pre><code class="language-console">NODE_OPTIONS='--experimental-loader ./custom-loader.mjs' node x.js</code></pre>
<blockquote>
<p>注意：加载器 API 正在重新设计。 这个钩子可能会消失，或者它的签名可能会改变。 不要依赖下面描述的 API。</p>
</blockquote>
<ul>
<li><code>source</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type" target="_blank">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" class="type" target="_blank">&lt;Uint8Array&gt;</a></li>
<li><code>context</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a>
<ul>
<li><code>format</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
<li><code>url</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
</ul>
</li>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type" target="_blank">&lt;Object&gt;</a>
<ul>
<li><code>source</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/6J6LBy" rel="nofollow" class="type" target="_blank">&lt;SharedArrayBuffer&gt;</a> | <a href="http://url.nodejs.cn/ZbDkpm" rel="nofollow" class="type" target="_blank">&lt;Uint8Array&gt;</a></li>
</ul>
</li>
</ul>
<p><code>transformSource</code> 钩子提供了一种在加载源字符串之后但在 Node.js 对其进行任何操作之前修改加载的 ES 模块文件的源代码的方法。</p>
<p>如果此钩子用于将未知的 Node.js 文件类型转换为可执行的 JavaScript，则还需要解析钩子来注册任何未知的 Node.js 文件扩展名。
请参阅下面的<a href="/api-v12/esm.html#esm_transpiler_loader">转译加载器示例</a>。</p>
<pre><code class="language-js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">!(string | SharedArrayBuffer | Uint8Array)</span>} <span class="hljs-variable">source</span>
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">{
 *   format: string,
 *   url: string,
 * </span>}} context
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} <span class="hljs-variable">defaultTransformSource</span>
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;{ source: !(string | SharedArrayBuffer | Uint8Array) </span>}&gt;}
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">transformSource</span>(<span class="hljs-params">source, context, defaultTransformSource</span>) {
  <span class="hljs-keyword">const</span> { url, format } = context;
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span>) { <span class="hljs-comment">// 一些条件。</span>
    <span class="hljs-comment">// 对于部分或全部 URL，做一些修改源的自定义逻辑。</span>
    <span class="hljs-comment">// 总是返回 {source: &lt;string|buffer&gt;} 形式的对象。</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">source</span>: <span class="hljs-string">'...'</span>,
    };
  }
  <span class="hljs-comment">// 对于所有其他来源，请遵循 Node.js。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultTransformSource</span>(source, context, defaultTransformSource);
}</code></pre>
<h5><code>getGlobalPreloadCode()</code><span><a class="mark" href="#getglobalpreloadcode" id="getglobalpreloadcode">#</a></span><a aria-hidden="true" class="legacy" id="esm_getglobalpreloadcode"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#getglobalpreloadcode">
<a href="esm/getglobalpreloadcode.html" class="tip_trans">中英对照</a>
</p>
<blockquote>
<p>注意：加载器 API 正在重新设计。 这个钩子可能会消失，或者它的签名可能会改变。 不要依赖下面描述的 API。</p>
</blockquote>
<ul>
<li>返回: <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type" target="_blank">&lt;string&gt;</a></li>
</ul>
<p>有时可能需要在应用程序运行所在的同一全局范围内运行一些代码。
此钩子允许返回在启动时作为宽松模式脚本运行的字符串。</p>
<p>类似于 CommonJS 封装器的工作方式，代码在隐式函数范围内运行。
唯一的参数是类似 <code>require</code> 的函数，可用于加载内置函数，如 "fs"：<code>getBuiltin(request: string)</code>。</p>
<p>如果代码需要更高级的 <code>require</code> 特性，则必须使用 <code>module.createRequire()</code> 构建自己的 <code>require</code>。</p>
<pre><code class="language-js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} 在应用程序启动之前运行的代码
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getGlobalPreloadCode</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`\
globalThis.someInjectedProperty = 42;
console.log('I just set some globals!');

const { createRequire } = getBuiltin('module');

const require = createRequire(process.cwd() + '/&lt;preload&gt;');
// [...]
`</span>;
}</code></pre>
<h5><code>dynamicInstantiate</code> hook<span><a class="mark" href="#codedynamicinstantiatecode-hook" id="codedynamicinstantiatecode-hook">#</a></span><a aria-hidden="true" class="legacy" id="esm_code_dynamicinstantiate_code_hook"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#codedynamicinstantiatecode-hook">
<a href="esm/code_dynamicinstantiate_code_hook.html" class="tip_trans">中英对照</a>
</p>
<blockquote>
<p>注意：加载器 API 正在重新设计。 这个钩子可能会消失，或者它的签名可能会改变。 不要依赖下面描述的 API。</p>
</blockquote>
<pre><code class="language-js"><span class="hljs-comment">/**
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span>
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">response</span>
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">array</span>} response.exports
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">function</span>} response.execute
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">dynamicInstantiate</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">exports</span>: [<span class="hljs-string">'customExportName'</span>],
    <span class="hljs-attr">execute</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">exports</span></span>) =&gt;</span> {
      <span class="hljs-comment">// </span>
      <span class="hljs-built_in">exports</span>.<span class="hljs-property">customExportName</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'value'</span>);
    }
  };
}</code></pre>
<h4>示例<span><a class="mark" href="#examples" id="examples">#</a></span><a aria-hidden="true" class="legacy" id="esm_examples"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#examples">
<a href="esm/examples.html" class="tip_trans">中英对照</a>
</p>
<p>各种加载器钩子可以一起使用来完成对 Node.js 代码加载和评估行为的广泛定制。</p>
<h5>HTTPS 加载器<span><a class="mark" href="#https-loader" id="https-loader">#</a></span><a aria-hidden="true" class="legacy" id="esm_https_loader"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#https-loader">
<a href="esm/https_loader.html" class="tip_trans">中英对照</a>
</p>
<p>在当前的 Node.js 中，不支持以 <code>https://</code> 开头的说明符。
下面的加载器注册钩子以启用对此类说明符的基本支持。
虽然这似乎是对 Node.js 核心功能的重大改进，但实际使用这个加载器有很大的缺点：性能比从磁盘加载文件慢得多，没有缓存，也没有安全性。</p>
<pre><code class="language-js"><span class="hljs-comment">// https-loader.mjs</span>
<span class="hljs-keyword">import</span> { get } <span class="hljs-keyword">from</span> <span class="hljs-string">'https'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">specifier, context, defaultResolve</span>) {
  <span class="hljs-keyword">const</span> { parentURL = <span class="hljs-literal">null</span> } = context;

  <span class="hljs-comment">// 通常，Node.js 会在以 'https://' 开头的说明符上出错，</span>
  <span class="hljs-comment">// 因此此钩子会拦截它们并将它们转换为绝对 URL，</span>
  <span class="hljs-comment">// 以便传给下面的后面的钩子。</span>
  <span class="hljs-keyword">if</span> (specifier.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'https://'</span>)) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">url</span>: specifier
    };
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentURL &amp;&amp; parentURL.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'https://'</span>)) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">url</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(specifier, parentURL).<span class="hljs-property">href</span>
    };
  }

  <span class="hljs-comment">// 让 Node.js 处理所有其他说明符。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultResolve</span>(specifier, context, defaultResolve);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFormat</span>(<span class="hljs-params">url, context, defaultGetFormat</span>) {
  <span class="hljs-comment">// 此加载器假定所有网络提供的 JavaScript 都是 ES 模块代码。</span>
  <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'https://'</span>)) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">format</span>: <span class="hljs-string">'module'</span>
    };
  }

  <span class="hljs-comment">// 让 Node.js 处理所有其他 URL。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultGetFormat</span>(url, context, defaultGetFormat);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSource</span>(<span class="hljs-params">url, context, defaultGetSource</span>) {
  <span class="hljs-comment">// 要通过网络加载 JavaScript，</span>
  <span class="hljs-comment">// 则需要获取并返回它。</span>
  <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'https://'</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-title function_">get</span>(url, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> data = <span class="hljs-string">''</span>;
        res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> data += chunk);
        res.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({ <span class="hljs-attr">source</span>: data }));
      }).<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(err));
    });
  }

  <span class="hljs-comment">// 让 Node.js 处理所有其他 URL。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultGetSource</span>(url, context, defaultGetSource);
}</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// main.mjs</span>
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">VERSION</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'https://coffeescript.org/browser-compiler-modern/coffeescript.js'</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable constant_">VERSION</span>);</code></pre>
<p>使用前面的加载器，运行 <code>node --experimental-loader ./https-loader.mjs ./main.mjs</code> 会在 <code>main.mjs</code> 中的 URL 处按照模块打印当前版本的 CoffeeScript。</p>
<h5>转译器加载器<span><a class="mark" href="#transpiler-loader" id="transpiler-loader">#</a></span><a aria-hidden="true" class="legacy" id="esm_transpiler_loader"></a></h5><p class="tip_wrap" data-show_trans="1" data-item_id="#transpiler-loader">
<a href="esm/transpiler_loader.html" class="tip_trans">中英对照</a>
</p>
<p>可以使用 <a href="/api-v12/esm.html#esm_transformsource_source_context_defaulttransformsource"><code>transformSource</code> 钩子</a>将 Node.js 无法理解的格式的源转换为 JavaScript。
但是，在调用该钩子之前，其他钩子需要告诉 Node.js 不要在未知文件类型上抛出错误；并告诉 Node.js 如何加载这种新文件类型。</p>
<p>这比在运行 Node.js 之前转译源文件的性能要低；转译加载器应该只用于开发和测试目的。</p>
<pre><code class="language-js"><span class="hljs-comment">// coffeescript-loader.mjs</span>
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">URL</span>, pathToFileURL } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">CoffeeScript</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'coffeescript'</span>;

<span class="hljs-keyword">const</span> baseURL = <span class="hljs-title function_">pathToFileURL</span>(<span class="hljs-string">`<span class="hljs-subst">${process.cwd()}</span>/`</span>).<span class="hljs-property">href</span>;

<span class="hljs-comment">// CoffeeScript 文件以 .coffee、.litcoffee 或 .coffee.md 结尾。</span>
<span class="hljs-keyword">const</span> extensionsRegex = <span class="hljs-regexp">/\.coffee$|\.litcoffee$|\.coffee\.md$/</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">specifier, context, defaultResolve</span>) {
  <span class="hljs-keyword">const</span> { parentURL = baseURL } = context;

  <span class="hljs-comment">// Node.js 通常在未知文件扩展名上出错，</span>
  <span class="hljs-comment">// 因此返回以 CoffeeScript 文件扩展名结尾的说明符的 URL。</span>
  <span class="hljs-keyword">if</span> (extensionsRegex.<span class="hljs-title function_">test</span>(specifier)) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">url</span>: <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(specifier, parentURL).<span class="hljs-property">href</span>
    };
  }

  <span class="hljs-comment">// 让 Node.js 处理所有其他说明符。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultResolve</span>(specifier, context, defaultResolve);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFormat</span>(<span class="hljs-params">url, context, defaultGetFormat</span>) {
  <span class="hljs-comment">// 现在修补了解决以让 CoffeeScript URL 通过，</span>
  <span class="hljs-comment">// 需要告诉 Node.js 这样的 URL 应该被解释为什么格式。</span>
  <span class="hljs-comment">// 为了这个加载器的目的，所有 CoffeeScript URL 都是 ES 模块。</span>
  <span class="hljs-keyword">if</span> (extensionsRegex.<span class="hljs-title function_">test</span>(url)) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">format</span>: <span class="hljs-string">'module'</span>
    };
  }

  <span class="hljs-comment">// 让 Node.js 处理所有其他 URL。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultGetFormat</span>(url, context, defaultGetFormat);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">transformSource</span>(<span class="hljs-params">source, context, defaultTransformSource</span>) {
  <span class="hljs-keyword">const</span> { url, format } = context;

  <span class="hljs-keyword">if</span> (extensionsRegex.<span class="hljs-title function_">test</span>(url)) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">source</span>: <span class="hljs-title class_">CoffeeScript</span>.<span class="hljs-title function_">compile</span>(source, { <span class="hljs-attr">bare</span>: <span class="hljs-literal">true</span> })
    };
  }

  <span class="hljs-comment">// 让 Node.js 处理所有其他来源。</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">defaultTransformSource</span>(source, context, defaultTransformSource);
}</code></pre>
<pre><code class="language-coffee"><span class="hljs-comment"># main.coffee</span>
<span class="hljs-keyword">import</span> { scream } <span class="hljs-keyword">from</span> <span class="hljs-string">'./scream.coffee'</span>
console.log scream <span class="hljs-string">'hello, world'</span>

<span class="hljs-keyword">import</span> { version } <span class="hljs-keyword">from</span> <span class="hljs-string">'process'</span>
console.log <span class="hljs-string">"Brought to you by Node.js version <span class="hljs-subst">#{version}</span>"</span></code></pre>
<pre><code class="language-coffee"><span class="hljs-comment"># scream.coffee</span>
<span class="hljs-keyword">export</span> scream = <span class="hljs-function"><span class="hljs-params">(str)</span> -&gt;</span> str.toUpperCase()</code></pre>
<p>使用前面的加载器，运行 <code>node --experimental-loader ./coffeescript-loader.mjs main.coffee</code> 会导致 <code>main.coffee</code> 在其源代码从磁盘加载之后但在 Node.js 执行之前转换为 JavaScript；对于通过任何加载文件的 <code>import</code> 语句引用的任何 <code>.coffee</code>、<code>.litcoffee</code> 或 <code>.coffee.md</code> 文件，依此类推。</p>
</section><section><h3>解析算法<span><a class="mark" href="#resolution-algorithm" id="resolution-algorithm">#</a></span><a aria-hidden="true" class="legacy" id="esm_resolution_algorithm"></a></h3>
<h4>特性<span><a class="mark" href="#features" id="features">#</a></span><a aria-hidden="true" class="legacy" id="esm_features"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#features">
<a href="esm/features.html" class="tip_trans">中英对照</a>
</p>
<p>解析器具有以下属性：</p>
<ul>
<li>ES 模块使用的基于 FileURL 的解析</li>
<li>支持内置模块加载</li>
<li>相对和绝对的网址解析</li>
<li>没有默认的扩展名</li>
<li>没有主文件夹</li>
<li>通过 node_modules 进行裸说明符包解析查找</li>
</ul>
<h4>解析器算法<span><a class="mark" href="#resolver-algorithm" id="resolver-algorithm">#</a></span><a aria-hidden="true" class="legacy" id="esm_resolver_algorithm"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#resolver-algorithm">
<a href="esm/resolver_algorithm.html" class="tip_trans">中英对照</a>
</p>
<p>加载 ES 模块说明符的算法通过下面的 <strong>ESM_RESOLVE</strong> 方法给出。
它返回相对于 parentURL 的模块说明符的解析 URL。</p>
<p>确定解析 URL 的模块格式的算法由 <strong>ESM_FORMAT</strong> 提供，它返回任何文件的唯一模块格式。
"module" 格式为 ECMAScript 模块返回，而 "commonjs" 格式用于指示通过旧版 CommonJS 加载器加载。
其他格式，如 "addon" 可以在未来的更新中扩展。</p>
<p>在以下算法中，除非另有说明，否则所有子程序错误都将作为这些顶层程序的错误传播。</p>
<p>defaultConditions 是条件环境名称数组，<code>["node", "import"]</code>。</p>
<p>解析器可能会抛出以下错误：</p>
<ul>
<li>无效的模块说明符：模块说明符是无效的 URL、包名称、或包子路径说明符。</li>
<li>无效的包配置：package.json 配置无效或包含无效配置。</li>
<li>无效的包目标：包导出或导入为无效类型或字符串目标的包定义了目标模块。</li>
<li>未导出包路径：包导出未定义或允许给定模块的包中的目标子路径。</li>
<li>未定义包导入：包导入未定义说明符。</li>
<li>未找到模块：请求的包或模块不存在。</li>
</ul>
<h4>解析器算法规范<span><a class="mark" href="#resolver-algorithm-specification" id="resolver-algorithm-specification">#</a></span><a aria-hidden="true" class="legacy" id="esm_resolver_algorithm_specification"></a></h4><p class="tip_wrap"></p>
<p><strong>ESM_RESOLVE</strong>(<em>specifier</em>, <em>parentURL</em>)</p>
<blockquote>
<ol>
<li>Let <em>resolved</em> be <strong>undefined</strong>.</li>
<li>If <em>specifier</em> is a valid URL, then
<ol>
<li>Set <em>resolved</em> to the result of parsing and reserializing
<em>specifier</em> as a URL.</li>
</ol>
</li>
<li>Otherwise, if <em>specifier</em> starts with <em>"/"</em>, <em>"./"</em> or <em>"../"</em>, then
<ol>
<li>Set <em>resolved</em> to the URL resolution of <em>specifier</em> relative to
<em>parentURL</em>.</li>
</ol>
</li>
<li>Otherwise, if <em>specifier</em> starts with <em>"#"</em>, then
<ol>
<li>Set <em>resolved</em> to the destructured value of the result of
<strong>PACKAGE_IMPORTS_RESOLVE</strong>(<em>specifier</em>, <em>parentURL</em>,
<em>defaultConditions</em>).</li>
</ol>
</li>
<li>Otherwise,
<ol>
<li>Note: <em>specifier</em> is now a bare specifier.</li>
<li>Set <em>resolved</em> the result of
<strong>PACKAGE_RESOLVE</strong>(<em>specifier</em>, <em>parentURL</em>).</li>
</ol>
</li>
<li>If <em>resolved</em> contains any percent encodings of <em>"/"</em> or <em>"\"</em> (<em>"%2f"</em>
and <em>"%5C"</em> respectively), then
<ol>
<li>Throw an <em>Invalid Module Specifier</em> error.</li>
</ol>
</li>
<li>If the file at <em>resolved</em> is a directory, then
<ol>
<li>Throw an <em>Unsupported Directory Import</em> error.</li>
</ol>
</li>
<li>If the file at <em>resolved</em> does not exist, then
<ol>
<li>Throw a <em>Module Not Found</em> error.</li>
</ol>
</li>
<li>Set <em>resolved</em> to the real path of <em>resolved</em>.</li>
<li>Let <em>format</em> be the result of <strong>ESM_FORMAT</strong>(<em>resolved</em>).</li>
<li>Load <em>resolved</em> as module format, <em>format</em>.</li>
<li>Return <em>resolved</em>.</li>
</ol>
</blockquote>
<p><strong>PACKAGE_RESOLVE</strong>(<em>packageSpecifier</em>, <em>parentURL</em>)</p>
<blockquote>
<ol>
<li>Let <em>packageName</em> be <strong>undefined</strong>.</li>
<li>If <em>packageSpecifier</em> is an empty string, then
<ol>
<li>Throw an <em>Invalid Module Specifier</em> error.</li>
</ol>
</li>
<li>If <em>packageSpecifier</em> does not start with <em>"@"</em>, then
<ol>
<li>Set <em>packageName</em> to the substring of <em>packageSpecifier</em> until the first
<em>"/"</em> separator or the end of the string.</li>
</ol>
</li>
<li>Otherwise,
<ol>
<li>If <em>packageSpecifier</em> does not contain a <em>"/"</em> separator, then
<ol>
<li>Throw an <em>Invalid Module Specifier</em> error.</li>
</ol>
</li>
<li>Set <em>packageName</em> to the substring of <em>packageSpecifier</em>
until the second <em>"/"</em> separator or the end of the string.</li>
</ol>
</li>
<li>If <em>packageName</em> starts with <em>"."</em> or contains <em>"\"</em> or <em>"%"</em>, then
<ol>
<li>Throw an <em>Invalid Module Specifier</em> error.</li>
</ol>
</li>
<li>Let <em>packageSubpath</em> be <em>"."</em> concatenated with the substring of
<em>packageSpecifier</em> from the position at the length of <em>packageName</em>.</li>
<li>Let <em>selfUrl</em> be the result of
<strong>PACKAGE_SELF_RESOLVE</strong>(<em>packageName</em>, <em>packageSubpath</em>, <em>parentURL</em>).</li>
<li>If <em>selfUrl</em> is not <strong>undefined</strong>, return <em>selfUrl</em>.</li>
<li>If <em>packageSubpath</em> is <em>"."</em> and <em>packageName</em> is a Node.js builtin
module, then
<ol>
<li>Return the string <em>"node:"</em> concatenated with <em>packageSpecifier</em>.</li>
</ol>
</li>
<li>While <em>parentURL</em> is not the file system root,
<ol>
<li>Let <em>packageURL</em> be the URL resolution of <em>"node_modules/"</em>
concatenated with <em>packageSpecifier</em>, relative to <em>parentURL</em>.</li>
<li>Set <em>parentURL</em> to the parent folder URL of <em>parentURL</em>.</li>
<li>If the folder at <em>packageURL</em> does not exist, then
<ol>
<li>Set <em>parentURL</em> to the parent URL path of <em>parentURL</em>.</li>
<li>Continue the next loop iteration.</li>
</ol>
</li>
<li>Let <em>pjson</em> be the result of <strong>READ_PACKAGE_JSON</strong>(<em>packageURL</em>).</li>
<li>If <em>pjson</em> is not <strong>null</strong> and <em>pjson</em>.<em>exports</em> is not <strong>null</strong> or
<strong>undefined</strong>, then
<ol>
<li>Let <em>exports</em> be <em>pjson.exports</em>.</li>
<li>Return the <em>resolved</em> destructured value of the result of
<strong>PACKAGE_EXPORTS_RESOLVE</strong>(<em>packageURL</em>, <em>packageSubpath</em>,
<em>pjson.exports</em>, <em>defaultConditions</em>).</li>
</ol>
</li>
<li>Otherwise, if <em>packageSubpath</em> is equal to <em>"."</em>, then
<ol>
<li>Return the result applying the legacy <strong>LOAD_AS_DIRECTORY</strong>
CommonJS resolver to <em>packageURL</em>, throwing a <em>Module Not Found</em>
error for no resolution.</li>
</ol>
</li>
<li>Otherwise,
<ol>
<li>Return the URL resolution of <em>packageSubpath</em> in <em>packageURL</em>.</li>
</ol>
</li>
</ol>
</li>
<li>Throw a <em>Module Not Found</em> error.</li>
</ol>
</blockquote>
<p><strong>PACKAGE_SELF_RESOLVE</strong>(<em>packageName</em>, <em>packageSubpath</em>, <em>parentURL</em>)</p>
<blockquote>
<ol>
<li>Let <em>packageURL</em> be the result of <strong>READ_PACKAGE_SCOPE</strong>(<em>parentURL</em>).</li>
<li>If <em>packageURL</em> is <strong>null</strong>, then
<ol>
<li>Return <strong>undefined</strong>.</li>
</ol>
</li>
<li>Let <em>pjson</em> be the result of <strong>READ_PACKAGE_JSON</strong>(<em>packageURL</em>).</li>
<li>If <em>pjson</em> is <strong>null</strong> or if <em>pjson</em>.<em>exports</em> is <strong>null</strong> or
<strong>undefined</strong>, then
<ol>
<li>Return <strong>undefined</strong>.</li>
</ol>
</li>
<li>If <em>pjson.name</em> is equal to <em>packageName</em>, then
<ol>
<li>Return the <em>resolved</em> destructured value of the result of
<strong>PACKAGE_EXPORTS_RESOLVE</strong>(<em>packageURL</em>, <em>subpath</em>, <em>pjson.exports</em>,
<em>defaultConditions</em>).</li>
</ol>
</li>
<li>Otherwise, return <strong>undefined</strong>.</li>
</ol>
</blockquote>
<p><strong>PACKAGE_EXPORTS_RESOLVE</strong>(<em>packageURL</em>, <em>subpath</em>, <em>exports</em>, <em>conditions</em>)</p>
<blockquote>
<ol>
<li>If <em>exports</em> is an Object with both a key starting with <em>"."</em> and a key not
starting with <em>"."</em>, throw an <em>Invalid Package Configuration</em> error.</li>
<li>If <em>subpath</em> is equal to <em>"."</em>, then
<ol>
<li>Let <em>mainExport</em> be <strong>undefined</strong>.</li>
<li>If <em>exports</em> is a String or Array, or an Object containing no keys
starting with <em>"."</em>, then
<ol>
<li>Set <em>mainExport</em> to <em>exports</em>.</li>
</ol>
</li>
<li>Otherwise if <em>exports</em> is an Object containing a <em>"."</em> property, then
<ol>
<li>Set <em>mainExport</em> to <em>exports</em>[<em>"."</em>].</li>
</ol>
</li>
<li>If <em>mainExport</em> is not <strong>undefined</strong>, then
<ol>
<li>Let <em>resolved</em> be the result of <strong>PACKAGE_TARGET_RESOLVE</strong>(
<em>packageURL</em>, <em>mainExport</em>, <em>""</em>, <strong>false</strong>, <strong>false</strong>,
<em>conditions</em>).</li>
<li>If <em>resolved</em> is not <strong>null</strong> or <strong>undefined</strong>, then
<ol>
<li>Return <em>resolved</em>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise, if <em>exports</em> is an Object and all keys of <em>exports</em> start with
<em>"."</em>, then
<ol>
<li>Let <em>matchKey</em> be the string <em>"./"</em> concatenated with <em>subpath</em>.</li>
<li>Let <em>resolvedMatch</em> be result of <strong>PACKAGE_IMPORTS_EXPORTS_RESOLVE</strong>(
<em>matchKey</em>, <em>exports</em>, <em>packageURL</em>, <strong>false</strong>, <em>conditions</em>).</li>
<li>If <em>resolvedMatch</em>.<em>resolve</em> is not <strong>null</strong> or <strong>undefined</strong>, then
<ol>
<li>Return <em>resolvedMatch</em>.</li>
</ol>
</li>
</ol>
</li>
<li>Throw a <em>Package Path Not Exported</em> error.</li>
</ol>
</blockquote>
<p><strong>PACKAGE_IMPORTS_RESOLVE</strong>(<em>specifier</em>, <em>parentURL</em>, <em>conditions</em>)</p>
<blockquote>
<ol>
<li>Assert: <em>specifier</em> begins with <em>"#"</em>.</li>
<li>If <em>specifier</em> is exactly equal to <em>"#"</em> or starts with <em>"#/"</em>, then
<ol>
<li>Throw an <em>Invalid Module Specifier</em> error.</li>
</ol>
</li>
<li>Let <em>packageURL</em> be the result of <strong>READ_PACKAGE_SCOPE</strong>(<em>parentURL</em>).</li>
<li>If <em>packageURL</em> is not <strong>null</strong>, then
<ol>
<li>Let <em>pjson</em> be the result of <strong>READ_PACKAGE_JSON</strong>(<em>packageURL</em>).</li>
<li>If <em>pjson.imports</em> is a non-null Object, then
<ol>
<li>Let <em>resolvedMatch</em> be the result of
<strong>PACKAGE_IMPORTS_EXPORTS_RESOLVE</strong>(<em>specifier</em>, <em>pjson.imports</em>,
<em>packageURL</em>, <strong>true</strong>, <em>conditions</em>).</li>
<li>If <em>resolvedMatch</em>.<em>resolve</em> is not <strong>null</strong> or <strong>undefined</strong>, then
<ol>
<li>Return <em>resolvedMatch</em>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Throw a <em>Package Import Not Defined</em> error.</li>
</ol>
</blockquote>
<p><strong>PACKAGE_IMPORTS_EXPORTS_RESOLVE</strong>(<em>matchKey</em>, <em>matchObj</em>, <em>packageURL</em>,
<em>isImports</em>, <em>conditions</em>)</p>
<blockquote>
<ol>
<li>If <em>matchKey</em> is a key of <em>matchObj</em>, and does not end in <em>"*"</em>, then
<ol>
<li>Let <em>target</em> be the value of <em>matchObj</em>[<em>matchKey</em>].</li>
<li>Let <em>resolved</em> be the result of <strong>PACKAGE_TARGET_RESOLVE</strong>(
<em>packageURL</em>, <em>target</em>, <em>""</em>, <strong>false</strong>, <em>isImports</em>, <em>conditions</em>).</li>
<li>Return the object <em>{ resolved, exact: <strong>true</strong> }</em>.</li>
</ol>
</li>
<li>Let <em>expansionKeys</em> be the list of keys of <em>matchObj</em> ending in <em>"/"</em>
or <em>"*"</em>, sorted by length descending.</li>
<li>For each key <em>expansionKey</em> in <em>expansionKeys</em>, do
<ol>
<li>If <em>expansionKey</em> ends in <em>"*"</em> and <em>matchKey</em> starts with but is
not equal to the substring of <em>expansionKey</em> excluding the last <em>"*"</em>
character, then
<ol>
<li>Let <em>target</em> be the value of <em>matchObj</em>[<em>expansionKey</em>].</li>
<li>Let <em>subpath</em> be the substring of <em>matchKey</em> starting at the
index of the length of <em>expansionKey</em> minus one.</li>
<li>Let <em>resolved</em> be the result of <strong>PACKAGE_TARGET_RESOLVE</strong>(
<em>packageURL</em>, <em>target</em>, <em>subpath</em>, <strong>true</strong>, <em>isImports</em>,
<em>conditions</em>).</li>
<li>Return the object <em>{ resolved, exact: <strong>true</strong> }</em>.</li>
</ol>
</li>
<li>If <em>matchKey</em> starts with <em>expansionKey</em>, then
<ol>
<li>Let <em>target</em> be the value of <em>matchObj</em>[<em>expansionKey</em>].</li>
<li>Let <em>subpath</em> be the substring of <em>matchKey</em> starting at the
index of the length of <em>expansionKey</em>.</li>
<li>Let <em>resolved</em> be the result of <strong>PACKAGE_TARGET_RESOLVE</strong>(
<em>packageURL</em>, <em>target</em>, <em>subpath</em>, <strong>false</strong>, <em>isImports</em>,
<em>conditions</em>).</li>
<li>Return the object <em>{ resolved, exact: <strong>false</strong> }</em>.</li>
</ol>
</li>
</ol>
</li>
<li>Return the object <em>{ resolved: <strong>null</strong>, exact: <strong>true</strong> }</em>.</li>
</ol>
</blockquote>
<p><strong>PACKAGE_TARGET_RESOLVE</strong>(<em>packageURL</em>, <em>target</em>, <em>subpath</em>, <em>pattern</em>,
<em>internal</em>, <em>conditions</em>)</p>
<blockquote>
<ol>
<li>If <em>target</em> is a String, then
<ol>
<li>If <em>pattern</em> is <strong>false</strong>, <em>subpath</em> has non-zero length and <em>target</em>
does not end with <em>"/"</em>, throw an <em>Invalid Module Specifier</em> error.</li>
<li>If <em>target</em> does not start with <em>"./"</em>, then
<ol>
<li>If <em>internal</em> is <strong>true</strong> and <em>target</em> does not start with <em>"../"</em> or
<em>"/"</em> and is not a valid URL, then
<ol>
<li>If <em>pattern</em> is <strong>true</strong>, then
<ol>
<li>Return <strong>PACKAGE_RESOLVE</strong>(<em>target</em> with every instance of
<em>"*"</em> replaced by <em>subpath</em>, <em>packageURL</em> + <em>"/"</em>)_.</li>
</ol>
</li>
<li>Return <strong>PACKAGE_RESOLVE</strong>(<em>target</em> + <em>subpath</em>,
<em>packageURL</em> + <em>"/"</em>)_.</li>
</ol>
</li>
<li>Otherwise, throw an <em>Invalid Package Target</em> error.</li>
</ol>
</li>
<li>If <em>target</em> split on <em>"/"</em> or <em>"\"</em> contains any <em>"."</em>, <em>".."</em> or
<em>"node_modules"</em> segments after the first segment, throw an
<em>Invalid Package Target</em> error.</li>
<li>Let <em>resolvedTarget</em> be the URL resolution of the concatenation of
<em>packageURL</em> and <em>target</em>.</li>
<li>Assert: <em>resolvedTarget</em> is contained in <em>packageURL</em>.</li>
<li>If <em>subpath</em> split on <em>"/"</em> or <em>"\"</em> contains any <em>"."</em>, <em>".."</em> or
<em>"node_modules"</em> segments, throw an <em>Invalid Module Specifier</em> error.</li>
<li>If <em>pattern</em> is <strong>true</strong>, then
<ol>
<li>Return the URL resolution of <em>resolvedTarget</em> with every instance of
<em>"*"</em> replaced with <em>subpath</em>.</li>
</ol>
</li>
<li>Otherwise,
<ol>
<li>Return the URL resolution of the concatenation of <em>subpath</em> and
<em>resolvedTarget</em>.</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise, if <em>target</em> is a non-null Object, then
<ol>
<li>If <em>exports</em> contains any index property keys, as defined in ECMA-262
<a href="http://url.nodejs.cn/HGLN85" rel="nofollow" target="_blank">6.1.7 Array Index</a>, throw an <em>Invalid Package Configuration</em> error.</li>
<li>For each property <em>p</em> of <em>target</em>, in object insertion order as,
<ol>
<li>If <em>p</em> equals <em>"default"</em> or <em>conditions</em> contains an entry for <em>p</em>,
then
<ol>
<li>Let <em>targetValue</em> be the value of the <em>p</em> property in <em>target</em>.</li>
<li>Let <em>resolved</em> be the result of <strong>PACKAGE_TARGET_RESOLVE</strong>(
<em>packageURL</em>, <em>targetValue</em>, <em>subpath</em>, <em>pattern</em>, <em>internal</em>,
<em>conditions</em>).</li>
<li>If <em>resolved</em> is equal to <strong>undefined</strong>, continue the loop.</li>
<li>Return <em>resolved</em>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <strong>undefined</strong>.</li>
</ol>
</li>
<li>Otherwise, if <em>target</em> is an Array, then
<ol>
<li>If _target.length is zero, return <strong>null</strong>.</li>
<li>For each item <em>targetValue</em> in <em>target</em>, do
<ol>
<li>Let <em>resolved</em> be the result of <strong>PACKAGE_TARGET_RESOLVE</strong>(
<em>packageURL</em>, <em>targetValue</em>, <em>subpath</em>, <em>pattern</em>, <em>internal</em>,
<em>conditions</em>), continuing the loop on any <em>Invalid Package Target</em>
error.</li>
<li>If <em>resolved</em> is <strong>undefined</strong>, continue the loop.</li>
<li>Return <em>resolved</em>.</li>
</ol>
</li>
<li>Return or throw the last fallback resolution <strong>null</strong> return or error.</li>
</ol>
</li>
<li>Otherwise, if <em>target</em> is <em>null</em>, return <strong>null</strong>.</li>
<li>Otherwise throw an <em>Invalid Package Target</em> error.</li>
</ol>
</blockquote>
<p><strong>ESM_FORMAT</strong>(<em>url</em>)</p>
<blockquote>
<ol>
<li>Assert: <em>url</em> corresponds to an existing file.</li>
<li>Let <em>pjson</em> be the result of <strong>READ_PACKAGE_SCOPE</strong>(<em>url</em>).</li>
<li>If <em>url</em> ends in <em>".mjs"</em>, then
<ol>
<li>Return <em>"module"</em>.</li>
</ol>
</li>
<li>If <em>url</em> ends in <em>".cjs"</em>, then
<ol>
<li>Return <em>"commonjs"</em>.</li>
</ol>
</li>
<li>If <em>pjson?.type</em> exists and is <em>"module"</em>, then
<ol>
<li>If <em>url</em> ends in <em>".js"</em>, then
<ol>
<li>Return <em>"module"</em>.</li>
</ol>
</li>
<li>Throw an <em>Unsupported File Extension</em> error.</li>
</ol>
</li>
<li>Otherwise,
<ol>
<li>Throw an <em>Unsupported File Extension</em> error.</li>
</ol>
</li>
</ol>
</blockquote>
<p><strong>READ_PACKAGE_SCOPE</strong>(<em>url</em>)</p>
<blockquote>
<ol>
<li>Let <em>scopeURL</em> be <em>url</em>.</li>
<li>While <em>scopeURL</em> is not the file system root,
<ol>
<li>Set <em>scopeURL</em> to the parent URL of <em>scopeURL</em>.</li>
<li>If <em>scopeURL</em> ends in a <em>"node_modules"</em> path segment, return <strong>null</strong>.</li>
<li>Let <em>pjson</em> be the result of <strong>READ_PACKAGE_JSON</strong>(<em>scopeURL</em>).</li>
<li>If <em>pjson</em> is not <strong>null</strong>, then
<ol>
<li>Return <em>pjson</em>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <strong>null</strong>.</li>
</ol>
</blockquote>
<p><strong>READ_PACKAGE_JSON</strong>(<em>packageURL</em>)</p>
<blockquote>
<ol>
<li>Let <em>pjsonURL</em> be the resolution of <em>"package.json"</em> within <em>packageURL</em>.</li>
<li>If the file at <em>pjsonURL</em> does not exist, then
<ol>
<li>Return <strong>null</strong>.</li>
</ol>
</li>
<li>If the file at <em>packageURL</em> does not parse as valid JSON, then
<ol>
<li>Throw an <em>Invalid Package Configuration</em> error.</li>
</ol>
</li>
<li>Return the parsed JSON source of the file at <em>pjsonURL</em>.</li>
</ol>
</blockquote>
<h4>自定义的 ESM 说明符解析算法<span><a class="mark" href="#customizing-esm-specifier-resolution-algorithm" id="customizing-esm-specifier-resolution-algorithm">#</a></span><a aria-hidden="true" class="legacy" id="esm_customizing_esm_specifier_resolution_algorithm"></a></h4><p class="tip_wrap" data-show_trans="1" data-item_id="#customizing-esm-specifier-resolution-algorithm">
<a href="esm/customizing_esm_specifier_resolution_algorithm.html" class="tip_trans">中英对照</a>
</p>
<p>当前的说明符解析不支持 CommonJS 加载器的所有默认行为。
行为差异之一是文件扩展名的自动解析以及导入具有索引文件的目录的能力。</p>
<p><code>--experimental-specifier-resolution=[mode]</code> 标志可用于自定义扩展解析算法。
默认模式是 <code>explicit</code>，这需要向加载器提供模块的完整路径。
要启用自动扩展解析并从包含索引文件的目录导入，则使用 <code>node</code> 模式。</p>
<pre><code class="language-console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">node index.mjs</span>
success!
<span class="hljs-meta prompt_">$ </span><span class="language-bash">node index <span class="hljs-comment"># 失败！</span></span>
Error: Cannot find module
<span class="hljs-meta prompt_">$ </span><span class="language-bash">node --experimental-specifier-resolution=node index</span>
success!</code></pre>
</section>
</div>
</div>
</div>
<div id="scroll_top" onclick="window.scrollTo(0,0);">返回顶部</div>
<div id="wxcode_box" style="display: none;">
<div id="wxcode_img_box">
<img id="wxcode_img">
<div id="wxcode_img_tips">微信扫码登录</div>
</div>
</div>
<script>
    window._API_NAME = "esm";
    window._UPDATE_TIME = "20220728214329";
  </script>

</body></html>