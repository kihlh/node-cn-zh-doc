<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>worker_threads 工作线程 | Node.js API 文档</title>
  <link rel="icon" sizes="32x32" type="image/png" href="//static.nodejs.cn/_static/img/favicon.png">
  <link href="css/api.css?1625411165219" rel="stylesheet">
</head>

<body class="alt apidoc" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="/" rel="nofollow">
          Node.js 中文网
        </a>

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.4.1</a></li>
        </ul> -->
      <div id="biz_nav"><a title="云服务器" target="_blank" rel="nofollow"><img></a></div>
      <div class="line"></div>
      <ul>
<li><a href="assert.html" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="buffer.html" rel="nofollow">Buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="child_process.html" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="console.html" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="crypto.html" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="debugger.html" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="dgram.html" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="net.html" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="process.html" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="string_decoder.html" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" rel="nofollow">timer<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" rel="nofollow">wasi<span class="api_nav_cn_name">WebAssembly系统接口</span></a></li>
<li><a href="webcrypto.html" rel="nofollow">webcrypto<span class="api_nav_cn_name">Web加密</span></a></li>
<li><a href="worker_threads.html" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>
<hr class="line">
<ul>
<li><a href="documentation.html" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" rel="nofollow">用法与示例</a></li>
<li><a href="cli.html" rel="nofollow">命令行选项</a></li>
<li><a href="modules.html" rel="nofollow">CommonJS<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="esm.html" rel="nofollow">ECMAScript<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="packages.html" rel="nofollow">包模块</a></li>
<li><a href="addons.html" rel="nofollow">C++<span class="api_nav_cn_name">插件</span></a></li>
<li><a href="embedding.html" rel="nofollow">C++<span class="api_nav_cn_name">嵌入器</span></a></li>
<li><a href="n-api.html" rel="nofollow">N-API</a></li>
<li><a href="async_context.html" rel="nofollow">异步上下文跟踪</a></li>
<li><a href="policy.html" rel="nofollow">安全策略</a></li>
<li><a href="deprecations.html" rel="nofollow">弃用的<span class="api_nav_cn_name">API</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="worker_threads" class="interior">
      <header>
        <div class="header-container">
          <h1>Node.js v16.4.1 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li>
              <a href="./">返回文档首页</a>
            </li>
            <li>
              <a href="http://api.nodejs.cn/">搜索</a>
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#worker_threads_worker_threads">worker_threads 工作线程</a></span>
<ul>
<li><span class="stability_1"><a href="#worker_threads_worker_getenvironmentdata_key"><code>worker.getEnvironmentData(key)</code></a></span></li>
<li><a href="#worker_threads_worker_ismainthread"><code>worker.isMainThread</code></a></li>
<li><a href="#worker_threads_worker_markasuntransferable_object"><code>worker.markAsUntransferable(object)</code></a></li>
<li><a href="#worker_threads_worker_movemessageporttocontext_port_contextifiedsandbox"><code>worker.moveMessagePortToContext(port, contextifiedSandbox)</code></a></li>
<li><a href="#worker_threads_worker_parentport"><code>worker.parentPort</code></a></li>
<li><a href="#worker_threads_worker_receivemessageonport_port"><code>worker.receiveMessageOnPort(port)</code></a></li>
<li><a href="#worker_threads_worker_resourcelimits"><code>worker.resourceLimits</code></a></li>
<li><a href="#worker_threads_worker_share_env"><code>worker.SHARE_ENV</code></a></li>
<li><span class="stability_1"><a href="#worker_threads_worker_setenvironmentdata_key_value"><code>worker.setEnvironmentData(key[, value])</code></a></span></li>
<li><a href="#worker_threads_worker_threadid"><code>worker.threadId</code></a></li>
<li><a href="#worker_threads_worker_workerdata"><code>worker.workerData</code></a></li>
<li><span class="stability_1"><a href="#worker_threads_class_broadcastchannel_extends_eventtarget">继承自 EventTarget 的 BroadcastChannel 类</a></span>
<ul>
<li><a href="#worker_threads_new_broadcastchannel_name"><code>new BroadcastChannel(name)</code></a></li>
<li><a href="#worker_threads_broadcastchannel_close"><code>broadcastChannel.close()</code></a></li>
<li><a href="#worker_threads_broadcastchannel_onmessage"><code>broadcastChannel.onmessage</code></a></li>
<li><a href="#worker_threads_broadcastchannel_onmessageerror"><code>broadcastChannel.onmessageerror</code></a></li>
<li><a href="#worker_threads_broadcastchannel_postmessage_message"><code>broadcastChannel.postMessage(message)</code></a></li>
<li><a href="#worker_threads_broadcastchannel_ref"><code>broadcastChannel.ref()</code></a></li>
<li><a href="#worker_threads_broadcastchannel_unref"><code>broadcastChannel.unref()</code></a></li>
</ul>
</li>
<li><a href="#worker_threads_class_messagechannel"><code>MessageChannel</code> 类</a></li>
<li><a href="#worker_threads_class_messageport"><code>MessagePort</code> 类</a>
<ul>
<li><a href="#worker_threads_event_close"><code>'close'</code> 事件</a></li>
<li><a href="#worker_threads_event_message"><code>'message'</code> 事件</a></li>
<li><a href="#worker_threads_event_messageerror"><code>'messageerror'</code> 事件</a></li>
<li><a href="#worker_threads_port_close"><code>port.close()</code></a></li>
<li><a href="#worker_threads_port_postmessage_value_transferlist"><code>port.postMessage(value[, transferList])</code></a>
<ul>
<li><a href="#worker_threads_considerations_when_transferring_typedarrays_and_buffers">传输 TypedArray 和 Buffer 时的注意事项</a></li>
<li><a href="#worker_threads_considerations_when_cloning_objects_with_prototypes_classes_and_accessors">使用原型、类和访问器克隆对象时的注意事项</a></li>
</ul>
</li>
<li><a href="#worker_threads_port_ref"><code>port.ref()</code></a></li>
<li><a href="#worker_threads_port_start"><code>port.start()</code></a></li>
<li><a href="#worker_threads_port_unref"><code>port.unref()</code></a></li>
</ul>
</li>
<li><a href="#worker_threads_class_worker"><code>Worker</code> 类</a>
<ul>
<li><a href="#worker_threads_new_worker_filename_options"><code>new Worker(filename[, options])</code></a></li>
<li><a href="#worker_threads_event_error"><code>'error'</code> 事件</a></li>
<li><a href="#worker_threads_event_exit"><code>'exit'</code> 事件</a></li>
<li><a href="#worker_threads_event_message_1"><code>'message'</code> 事件</a></li>
<li><a href="#worker_threads_event_messageerror_1"><code>'messageerror'</code> 事件</a></li>
<li><a href="#worker_threads_event_online"><code>'online'</code> 事件</a></li>
<li><a href="#worker_threads_worker_getheapsnapshot"><code>worker.getHeapSnapshot()</code></a></li>
<li><a href="#worker_threads_worker_performance"><code>worker.performance</code></a>
<ul>
<li><a href="#worker_threads_performance_eventlooputilization_utilization1_utilization2"><code>performance.eventLoopUtilization([utilization1[, utilization2]])</code></a></li>
</ul>
</li>
<li><a href="#worker_threads_worker_postmessage_value_transferlist"><code>worker.postMessage(value[, transferList])</code></a></li>
<li><a href="#worker_threads_worker_ref"><code>worker.ref()</code></a></li>
<li><a href="#worker_threads_worker_resourcelimits_1"><code>worker.resourceLimits</code></a></li>
<li><a href="#worker_threads_worker_stderr"><code>worker.stderr</code></a></li>
<li><a href="#worker_threads_worker_stdin"><code>worker.stdin</code></a></li>
<li><a href="#worker_threads_worker_stdout"><code>worker.stdout</code></a></li>
<li><a href="#worker_threads_worker_terminate"><code>worker.terminate()</code></a></li>
<li><a href="#worker_threads_worker_threadid_1"><code>worker.threadId</code></a></li>
<li><a href="#worker_threads_worker_unref"><code>worker.unref()</code></a></li>
</ul>
</li>
<li><a href="#worker_threads_notes">注意事项</a>
<ul>
<li><a href="#worker_threads_synchronous_blocking_of_stdio">stdio 的同步阻塞</a></li>
<li><a href="#worker_threads_launching_worker_threads_from_preload_scripts">从预加载脚本启动工作线程</a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <!-- <div id="biz_content">
          <a href="http://www.tp-shop.cn/index.php?http_referer=node" target="_blank">
            <img src="//static.nodejs.cn/_static/img/ad/api_content_tpshop.jpg" />
          </a>
        </div> -->

      <div id="apicontent">
        <h2>worker_threads 工作线程<span><a class="mark" href="#worker_threads_worker_threads" id="worker_threads_worker_threads">#</a></span></h2><p class="tip_wrap" data-show_trans="1" data-item_id="worker_threads">
                <a href="worker_threads/worker_threads.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v10.5.0-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">稳定性: 2</a> - 稳定</div><p></p>
<p><strong>源代码:</strong> <a rel="nofollow" href="http://url.nodejs.cn/hpQkA1">lib/worker_threads.js</a></p>
<p><code>worker_threads</code> 模块使能够使用并行地执行 JavaScript 的线程。
要访问它：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> worker = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);</code></pre>
<p>工作线程对于执行 CPU 密集型的 JavaScript 操作非常有用。
它们对于 I/O 密集型的工作帮助不大。
Node.js 内置的异步 I/O 操作比工作线程效率更高。</p>
<p>不同于 <code>child_process</code> 或者 <code>cluster</code>，<code>worker_threads</code> 可以共享内存。
它们通过传输 <code>ArrayBuffer</code> 实例或者共享 <code>SharedArrayBuffer</code> 实例来做到。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> {
  Worker, isMainThread, parentPort, workerData
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseJSAsync</span>(<span class="hljs-params">script</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(__filename, {
        <span class="hljs-attr">workerData</span>: script
      });
      worker.on(<span class="hljs-string">'message'</span>, resolve);
      worker.on(<span class="hljs-string">'error'</span>, reject);
      worker.on(<span class="hljs-string">'exit'</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (code !== <span class="hljs-number">0</span>)
          reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`工作线程被退出码 <span class="hljs-subst">${code}</span> 停止`</span>));
      });
    });
  };
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">const</span> { parse } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'some-js-parsing-library'</span>);
  <span class="hljs-keyword">const</span> script = workerData;
  parentPort.postMessage(parse(script));
}</code></pre>
<p>上面的示例为每个 <code>parse()</code> 调用衍生一个工作线程。
在实际的实践中，为这类任务使用一个工作线程池。
否则，创建工作线程的开销可能超出其收益。</p>
<p>当实现一个工作线程池时，使用 <a href="async_hooks.html#async_hooks_class_asyncresource"><code>AsyncResource</code></a> API 来通知诊断的工具（例如为了提供异步的堆栈跟踪）关于任务及其结果之间的相关性。
查看 <code>async_hooks</code> 文档中的<a href="async_hooks.html#async-resource-worker-pool">“为一个工作线程池使用 <code>AsyncResource</code>”</a>获取一个示例实现。</p>
<p>默认情况下，工作线程继承非进程特定的选项。
查看<a href="worker_threads.html#worker_threads_new_worker_filename_options">工作线程的构造器选项</a>了解如何自定义工作线程的选项，特别是 <code>argv</code> 和 <code>execArgv</code> 选项。</p>
<section><h3><code>worker.getEnvironmentData(key)</code><span><a class="mark" href="#worker_threads_worker_getenvironmentdata_key" id="worker_threads_worker_getenvironmentdata_key">#</a></span></h3><p class="tip_wrap" data-item_id="worker_getenvironmentdata_key"></p>
<div class="api_metadata">
<span>新增于: v15.12.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#documentation_stability_index">稳定性: 1</a> - 实验</div><p></p>
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> Any arbitrary, cloneable JavaScript value that can be used as a
<a href="http://url.nodejs.cn/EnuJtG" rel="nofollow" class="type">&lt;Map&gt;</a> key.</li>
<li>返回: <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a></li>
</ul>
<p>Within a worker thread, <code>worker.getEnvironmentData()</code> returns a clone
of data passed to the spawning thread's <code>worker.setEnvironmentData()</code>.
Every new <code>Worker</code> receives its own copy of the environment data
automatically.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> {
  Worker,
  isMainThread,
  setEnvironmentData,
  getEnvironmentData,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  setEnvironmentData(<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'World!'</span>);
  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(__filename);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(getEnvironmentData(<span class="hljs-string">'Hello'</span>));  <span class="hljs-comment">// Prints 'World!'.</span>
}</code></pre>
</section><section><h3><code>worker.isMainThread</code><span><a class="mark" href="#worker_threads_worker_ismainthread" id="worker_threads_worker_ismainthread">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="worker_ismainthread">
                <a href="worker_threads/worker_ismainthread.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>如果此代码不在 <a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> 线程内运行，则为 <code>true</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Worker, isMainThread } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-comment">// 这会在工作线程实例中重新加载当前文件。</span>
  <span class="hljs-keyword">new</span> Worker(__filename);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'在工作线程中'</span>);
  <span class="hljs-built_in">console</span>.log(isMainThread);  <span class="hljs-comment">// 打印 'false'。</span>
}</code></pre>
</section><section><h3><code>worker.markAsUntransferable(object)</code><span><a class="mark" href="#worker_threads_worker_markasuntransferable_object" id="worker_threads_worker_markasuntransferable_object">#</a></span></h3><p class="tip_wrap" data-item_id="worker_markasuntransferable_object"></p>
<div class="api_metadata">
<span>新增于: v14.5.0, v12.19.0</span>
</div>
<p>Mark an object as not transferable. If <code>object</code> occurs in the transfer list of
a <a href="worker_threads.html#worker_threads_port_postmessage_value_transferlist"><code>port.postMessage()</code></a> call, it is ignored.</p>
<p>In particular, this makes sense for objects that can be cloned, rather than
transferred, and which are used by other objects on the sending side.
For example, Node.js marks the <code>ArrayBuffer</code>s it uses for its
<a href="buffer.html#buffer_static_method_buffer_allocunsafe_size"><code>Buffer</code> pool</a> with this.</p>
<p>This operation cannot be undone.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { MessageChannel, markAsUntransferable } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">const</span> pooledBuffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">8</span>);
<span class="hljs-keyword">const</span> typedArray1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(pooledBuffer);
<span class="hljs-keyword">const</span> typedArray2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>(pooledBuffer);

markAsUntransferable(pooledBuffer);

<span class="hljs-keyword">const</span> { port1 } = <span class="hljs-keyword">new</span> MessageChannel();
port1.postMessage(typedArray1, [ typedArray1.buffer ]);

<span class="hljs-comment">// The following line prints the contents of typedArray1 -- it still owns</span>
<span class="hljs-comment">// its memory and has been cloned, not transferred. Without</span>
<span class="hljs-comment">// `markAsUntransferable()`, this would print an empty Uint8Array.</span>
<span class="hljs-comment">// typedArray2 is intact as well.</span>
<span class="hljs-built_in">console</span>.log(typedArray1);
<span class="hljs-built_in">console</span>.log(typedArray2);</code></pre>
<p>There is no equivalent to this API in browsers.</p>
</section><section><h3><code>worker.moveMessagePortToContext(port, contextifiedSandbox)</code><span><a class="mark" href="#worker_threads_worker_movemessageporttocontext_port_contextifiedsandbox" id="worker_threads_worker_movemessageporttocontext_port_contextifiedsandbox">#</a></span></h3><p class="tip_wrap" data-item_id="worker_movemessageporttocontext_port_contextifiedsandbox"></p>
<div class="api_metadata">
<span>新增于: v11.13.0</span>
</div>
<ul>
<li>
<p><code>port</code> <a href="worker_threads.html#worker_threads_class_messageport" rel="nofollow" class="type">&lt;MessagePort&gt;</a> The message port to transfer.</p>
</li>
<li>
<p><code>contextifiedSandbox</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> A <a href="vm.html#vm_what_does_it_mean_to_contextify_an_object">contextified</a> object as returned by the
<code>vm.createContext()</code> method.</p>
</li>
<li>
<p>返回: <a href="worker_threads.html#worker_threads_class_messageport" rel="nofollow" class="type">&lt;MessagePort&gt;</a></p>
</li>
</ul>
<p>Transfer a <code>MessagePort</code> to a different <a href="vm.html"><code>vm</code></a> Context. The original <code>port</code>
object is rendered unusable, and the returned <code>MessagePort</code> instance
takes its place.</p>
<p>The returned <code>MessagePort</code> is an object in the target context and
inherits from its global <code>Object</code> class. Objects passed to the
<a href="http://url.nodejs.cn/4K42hk"><code>port.onmessage()</code></a> listener are also created in the target context
and inherit from its global <code>Object</code> class.</p>
<p>However, the created <code>MessagePort</code> no longer inherits from
<a href="http://url.nodejs.cn/iXXayi"><code>EventTarget</code></a>, and only <a href="http://url.nodejs.cn/4K42hk"><code>port.onmessage()</code></a> can be used to receive
events using it.</p>
</section><section><h3><code>worker.parentPort</code><span><a class="mark" href="#worker_threads_worker_parentport" id="worker_threads_worker_parentport">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="worker_parentport">
                <a href="worker_threads/worker_parentport.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="worker_threads.html#worker_threads_class_messageport" rel="nofollow" class="type">&lt;MessagePort&gt;</a></li>
</ul>
<p>如果当前线程为<a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a>工作线程, 该<a href="worker_threads.html#worker_threads_class_messageport"><code>MessagePort</code></a>端口作用于与主线交换信息。通过该端口<code>parentPort.postMessage()</code>发送的消息在主线程中将可以通过<code>worker.on('message')</code>接收。主线程中通过<code>worker.postMessage()</code>发送的消息将可以在工作线程中通过<code>parentPort.on('message')</code>接收。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Worker, isMainThread, parentPort } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(__filename);
  worker.once(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message);  <span class="hljs-comment">// Prints 'Hello, world!'.</span>
  });
  worker.postMessage(<span class="hljs-string">'Hello, world!'</span>);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// When a message from the parent thread is received, send it back:</span>
  parentPort.once(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
    parentPort.postMessage(message);
  });
}</code></pre>
</section><section><h3><code>worker.receiveMessageOnPort(port)</code><span><a class="mark" href="#worker_threads_worker_receivemessageonport_port" id="worker_threads_worker_receivemessageonport_port">#</a></span></h3><p class="tip_wrap" data-item_id="worker_receivemessageonport_port"></p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.12.0</td>
<td><p>The port argument can also refer to a <code>BroadcastChannel</code> now.</p></td></tr>
<tr><td>v12.3.0</td>
<td><p><span>新增于: v12.3.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li>
<p><code>port</code> <a href="worker_threads.html#worker_threads_class_messageport" rel="nofollow" class="type">&lt;MessagePort&gt;</a> | <a href="worker_threads.html#worker_threads_class_broadcastchannel_extends_eventtarget" rel="nofollow" class="type">&lt;BroadcastChannel&gt;</a></p>
</li>
<li>
<p>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> | <a href="http://url.nodejs.cn/8ym6ow" rel="nofollow" class="type">&lt;undefined&gt;</a></p>
</li>
</ul>
<p>Receive a single message from a given <code>MessagePort</code>. If no message is available,
<code>undefined</code> is returned, otherwise an object with a single <code>message</code> property
that contains the message payload, corresponding to the oldest message in the
<code>MessagePort</code>’s queue.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { MessageChannel, receiveMessageOnPort } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> MessageChannel();
port1.postMessage({ <span class="hljs-attr">hello</span>: <span class="hljs-string">'world'</span> });

<span class="hljs-built_in">console</span>.log(receiveMessageOnPort(port2));
<span class="hljs-comment">// Prints: { message: { hello: 'world' } }</span>
<span class="hljs-built_in">console</span>.log(receiveMessageOnPort(port2));
<span class="hljs-comment">// Prints: undefined</span></code></pre>
<p>When this function is used, no <code>'message'</code> event is emitted and the
<code>onmessage</code> listener is not invoked.</p>
</section><section><h3><code>worker.resourceLimits</code><span><a class="mark" href="#worker_threads_worker_resourcelimits" id="worker_threads_worker_resourcelimits">#</a></span></h3><p class="tip_wrap" data-item_id="worker_resourcelimits"></p>
<div class="api_metadata">
<span>新增于: v13.2.0, v12.16.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>maxYoungGenerationSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>maxOldGenerationSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>codeRangeSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>stackSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
</li>
</ul>
<p>Provides the set of JS engine resource constraints inside this Worker thread.
If the <code>resourceLimits</code> option was passed to the <a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> constructor,
this matches its values.</p>
<p>If this is used in the main thread, its value is an empty object.</p>
</section><section><h3><code>worker.SHARE_ENV</code><span><a class="mark" href="#worker_threads_worker_share_env" id="worker_threads_worker_share_env">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="worker_share_env">
                <a href="worker_threads/worker_share_env.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v11.14.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/i5E1UH" rel="nofollow" class="type">&lt;symbol&gt;</a></li>
</ul>
<p>传递给构造函数<a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a>选项对象<code>env</code>属性的值，用以指定主线程与工作线程将可共享环境变量的读写。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Worker, SHARE_ENV } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-keyword">new</span> Worker(<span class="hljs-string">'process.env.SET_IN_WORKER = "foo"'</span>, { <span class="hljs-attr">eval</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">env</span>: SHARE_ENV })
  .on(<span class="hljs-string">'exit'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(process.env.SET_IN_WORKER);  <span class="hljs-comment">// Prints 'foo'.</span>
  });</code></pre>
</section><section><h3><code>worker.setEnvironmentData(key[, value])</code><span><a class="mark" href="#worker_threads_worker_setenvironmentdata_key_value" id="worker_threads_worker_setenvironmentdata_key_value">#</a></span></h3><p class="tip_wrap" data-item_id="worker_setenvironmentdata_key_value"></p>
<div class="api_metadata">
<span>新增于: v15.12.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#documentation_stability_index">稳定性: 1</a> - 实验</div><p></p>
<ul>
<li><code>key</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> Any arbitrary, cloneable JavaScript value that can be used as a
<a href="http://url.nodejs.cn/EnuJtG" rel="nofollow" class="type">&lt;Map&gt;</a> key.</li>
<li><code>value</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> Any arbitrary, cloneable JavaScript value that will be cloned
and passed automatically to all new <code>Worker</code> instances. If <code>value</code> is passed
as <code>undefined</code>, any previously set value for the <code>key</code> will be deleted.</li>
</ul>
<p>The <code>worker.setEnvironmentData()</code> API sets the content of
<code>worker.getEnvironmentData()</code> in the current thread and all new <code>Worker</code>
instances spawned from the current context.</p>
</section><section><h3><code>worker.threadId</code><span><a class="mark" href="#worker_threads_worker_threadid" id="worker_threads_worker_threadid">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="worker_threadid">
                <a href="worker_threads/worker_threadid.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>当前线程的ID，同时在工作线程上，每个worker实例也都有唯一的ID。</p>
</section><section><h3><code>worker.workerData</code><span><a class="mark" href="#worker_threads_worker_workerdata" id="worker_threads_worker_workerdata">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="worker_workerdata">
                <a href="worker_threads/worker_workerdata.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>（工作线程中可用）指代通过主线程中传递过来的数据。
它可以是任意的JavaScript值，通过主线程构造函数中的选项对象的workerData传递。
这个数据类似Web Worker中<a href="worker_threads.html#worker_threads_port_postmessage_value_transferlist"><code>postMessage()</code></a>机制，它是拷贝传递的（所以如果是较大数据里，不建议通过此方法）。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Worker, isMainThread, workerData } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(__filename, { <span class="hljs-attr">workerData</span>: <span class="hljs-string">'Hello, world!'</span> });
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(workerData);  <span class="hljs-comment">// Prints 'Hello, world!'.</span>
}</code></pre>
</section><section><h3>继承自 EventTarget 的 BroadcastChannel 类<span><a class="mark" href="#worker_threads_class_broadcastchannel_extends_eventtarget" id="worker_threads_class_broadcastchannel_extends_eventtarget">#</a></span></h3><p class="tip_wrap" data-item_id="class_broadcastchannel_extends_eventtarget"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<p></p><div class="api_stability api_stability_1"><a href="documentation.html#documentation_stability_index">稳定性: 1</a> - 实验</div><p></p>
<p>Instances of <code>BroadcastChannel</code> allow asynchronous one-to-many communication
with all other <code>BroadcastChannel</code> instances bound to the same channel name.</p>
<pre><code class="language-js"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> {
  isMainThread,
  BroadcastChannel,
  Worker
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">const</span> bc = <span class="hljs-keyword">new</span> BroadcastChannel(<span class="hljs-string">'hello'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>;
  bc.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(event.data);
    <span class="hljs-keyword">if</span> (++c === <span class="hljs-number">10</span>) bc.close();
  };
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">10</span>; n++)
    <span class="hljs-keyword">new</span> Worker(__filename);
} <span class="hljs-keyword">else</span> {
  bc.postMessage(<span class="hljs-string">'hello from every worker'</span>);
  bc.close();
}</code></pre>
<h4><code>new BroadcastChannel(name)</code><span><a class="mark" href="#worker_threads_new_broadcastchannel_name" id="worker_threads_new_broadcastchannel_name">#</a></span></h4><p class="tip_wrap" data-item_id="new_broadcastchannel_name"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<ul>
<li><code>name</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> The name of the channel to connect to. Any JavaScript value
that can be converted to a string using <code>${name}</code> is permitted.</li>
</ul>
<h4><code>broadcastChannel.close()</code><span><a class="mark" href="#worker_threads_broadcastchannel_close" id="worker_threads_broadcastchannel_close">#</a></span></h4><p class="tip_wrap" data-item_id="broadcastchannel_close"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<p>Closes the <code>BroadcastChannel</code> connection.</p>
<h4><code>broadcastChannel.onmessage</code><span><a class="mark" href="#worker_threads_broadcastchannel_onmessage" id="worker_threads_broadcastchannel_onmessage">#</a></span></h4><p class="tip_wrap" data-item_id="broadcastchannel_onmessage"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> Invoked with a single <code>MessageEvent</code> argument
when a message is received.</li>
</ul>
<h4><code>broadcastChannel.onmessageerror</code><span><a class="mark" href="#worker_threads_broadcastchannel_onmessageerror" id="worker_threads_broadcastchannel_onmessageerror">#</a></span></h4><p class="tip_wrap" data-item_id="broadcastchannel_onmessageerror"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<ul>
<li>Type: <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> Invoked with a received message cannot be
deserialized.</li>
</ul>
<h4><code>broadcastChannel.postMessage(message)</code><span><a class="mark" href="#worker_threads_broadcastchannel_postmessage_message" id="worker_threads_broadcastchannel_postmessage_message">#</a></span></h4><p class="tip_wrap" data-item_id="broadcastchannel_postmessage_message"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<ul>
<li><code>message</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> Any cloneable JavaScript value.</li>
</ul>
<h4><code>broadcastChannel.ref()</code><span><a class="mark" href="#worker_threads_broadcastchannel_ref" id="worker_threads_broadcastchannel_ref">#</a></span></h4><p class="tip_wrap" data-item_id="broadcastchannel_ref"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<p>Opposite of <code>unref()</code>. Calling <code>ref()</code> on a previously <code>unref()</code>ed
BroadcastChannel does <em>not</em> let the program exit if it's the only active handle
left (the default behavior). If the port is <code>ref()</code>ed, calling <code>ref()</code> again
has no effect.</p>
<h4><code>broadcastChannel.unref()</code><span><a class="mark" href="#worker_threads_broadcastchannel_unref" id="worker_threads_broadcastchannel_unref">#</a></span></h4><p class="tip_wrap" data-item_id="broadcastchannel_unref"></p>
<div class="api_metadata">
<span>新增于: v15.4.0</span>
</div>
<p>Calling <code>unref()</code> on a BroadcastChannel allows the thread to exit if this
is the only active handle in the event system. If the BroadcastChannel is
already <code>unref()</code>ed calling <code>unref()</code> again has no effect.</p>
</section><section><h3><code>MessageChannel</code> 类<span><a class="mark" href="#worker_threads_class_messagechannel" id="worker_threads_class_messagechannel">#</a></span></h3><p class="tip_wrap" data-item_id="class_messagechannel"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>Instances of the <code>worker.MessageChannel</code> class represent an asynchronous,
two-way communications channel.
The <code>MessageChannel</code> has no methods of its own. <code>new MessageChannel()</code>
yields an object with <code>port1</code> and <code>port2</code> properties, which refer to linked
<a href="worker_threads.html#worker_threads_class_messageport"><code>MessagePort</code></a> instances.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { MessageChannel } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> MessageChannel();
port1.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'received'</span>, message));
port2.postMessage({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> });
<span class="hljs-comment">// Prints: received { foo: 'bar' } from the `port1.on('message')` listener</span></code></pre>
</section><section><h3><code>MessagePort</code> 类<span><a class="mark" href="#worker_threads_class_messageport" id="worker_threads_class_messageport">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_messageport">
                <a href="worker_threads/class_messageport.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.7.0</td>
<td><p>This class now inherits from <code>EventTarget</code> rather than from <code>EventEmitter</code>.</p></td></tr>
<tr><td>v10.5.0</td>
<td><p><span>新增于: v10.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li>继承自: <a href="events.html#events_class_eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>Instances of the <code>worker.MessagePort</code> class represent one end of an
asynchronous, two-way communications channel. It can be used to transfer
structured data, memory regions and other <code>MessagePort</code>s between different
<a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a>s.</p>
<p>With the exception of <code>MessagePort</code>s being [<code>EventEmitter</code>][]s rather
than <a href="http://url.nodejs.cn/iXXayi"><code>EventTarget</code></a>s, this implementation matches <a href="http://url.nodejs.cn/beVAtP">browser <code>MessagePort</code></a>s.</p>
<h4><code>'close'</code> 事件<span><a class="mark" href="#worker_threads_event_close" id="worker_threads_event_close">#</a></span></h4><p class="tip_wrap" data-item_id="event_close"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>The <code>'close'</code> event is emitted once either side of the channel has been
disconnected.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { MessageChannel } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> MessageChannel();

<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   foobar</span>
<span class="hljs-comment">//   closed!</span>
port2.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(message));
port2.on(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'closed!'</span>));

port1.postMessage(<span class="hljs-string">'foobar'</span>);
port1.close();</code></pre>
<h4><code>'message'</code> 事件<span><a class="mark" href="#worker_threads_event_message" id="worker_threads_event_message">#</a></span></h4><p class="tip_wrap" data-item_id="event_message"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><code>value</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> The transmitted value</li>
</ul>
<p>The <code>'message'</code> event is emitted for any incoming message, containing the cloned
input of <a href="worker_threads.html#worker_threads_port_postmessage_value_transferlist"><code>port.postMessage()</code></a>.</p>
<p>Listeners on this event receive a clone of the <code>value</code> parameter as passed
to <code>postMessage()</code> and no further arguments.</p>
<h4><code>'messageerror'</code> 事件<span><a class="mark" href="#worker_threads_event_messageerror" id="worker_threads_event_messageerror">#</a></span></h4><p class="tip_wrap" data-item_id="event_messageerror"></p>
<div class="api_metadata">
<span>新增于: v14.5.0, v12.19.0</span>
</div>
<ul>
<li><code>error</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> An Error object</li>
</ul>
<p>The <code>'messageerror'</code> event is emitted when deserializing a message failed.</p>
<p>Currently, this event is emitted when there is an error occurring while
instantiating the posted JS object on the receiving end. Such situations
are rare, but can happen, for instance, when certain Node.js API objects
are received in a <code>vm.Context</code> (where Node.js APIs are currently
unavailable).</p>
<h4><code>port.close()</code><span><a class="mark" href="#worker_threads_port_close" id="worker_threads_port_close">#</a></span></h4><p class="tip_wrap" data-item_id="port_close"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>Disables further sending of messages on either side of the connection.
This method can be called when no further communication will happen over this
<code>MessagePort</code>.</p>
<p>The <a href="worker_threads.html#worker_threads_event_close"><code>'close'</code> event</a> is emitted on both <code>MessagePort</code> instances that
are part of the channel.</p>
<h4><code>port.postMessage(value[, transferList])</code><span><a class="mark" href="#worker_threads_port_postmessage_value_transferlist" id="worker_threads_port_postmessage_value_transferlist">#</a></span></h4><p class="tip_wrap" data-item_id="port_postmessage_value_transferlist"></p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v15.14.0</td>
<td><p>Add 'BlockList' to the list of cloneable types.</p></td></tr>
<tr><td>v15.9.0</td>
<td><p>Add 'Histogram' types to the list of cloneable types.</p></td></tr>
<tr><td>v15.6.0</td>
<td><p>Added <code>X509Certificate</code> to the list of cloneable types.</p></td></tr>
<tr><td>v15.0.0</td>
<td><p>Added <code>CryptoKey</code> to the list of cloneable types.</p></td></tr>
<tr><td>v14.5.0, v12.19.0</td>
<td><p>Added <code>KeyObject</code> to the list of cloneable types.</p></td></tr>
<tr><td>v14.5.0, v12.19.0</td>
<td><p>Added <code>FileHandle</code> to the list of transferable types.</p></td></tr>
<tr><td>v10.5.0</td>
<td><p><span>新增于: v10.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>value</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a></li>
<li><code>transferList</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object[]&gt;</a></li>
</ul>
<p>Sends a JavaScript value to the receiving side of this channel.
<code>value</code> is transferred in a way which is compatible with
the <a href="http://url.nodejs.cn/SLsDHc">HTML structured clone algorithm</a>.</p>
<p>In particular, the significant differences to <code>JSON</code> are:</p>
<ul>
<li><code>value</code> may contain circular references.</li>
<li><code>value</code> may contain instances of builtin JS types such as <code>RegExp</code>s,
<code>BigInt</code>s, <code>Map</code>s, <code>Set</code>s, etc.</li>
<li><code>value</code> may contain typed arrays, both using <code>ArrayBuffer</code>s
and <code>SharedArrayBuffer</code>s.</li>
<li><code>value</code> may contain <a href="http://url.nodejs.cn/jrrZmy"><code>WebAssembly.Module</code></a> instances.</li>
<li><code>value</code> may not contain native (C++-backed) objects other than:
<ul>
<li><a href="webcrypto.html#webcrypto_class_cryptokey" rel="nofollow" class="type">&lt;CryptoKey&gt;</a>s,</li>
<li><a href="fs.html#fs_class_filehandle" rel="nofollow" class="type">&lt;FileHandle&gt;</a>s,</li>
<li><a href="perf_hooks.html#perf_hooks_class_histogram" rel="nofollow" class="type">&lt;Histogram&gt;</a>s,</li>
<li><a href="crypto.html#crypto_class_keyobject" rel="nofollow" class="type">&lt;KeyObject&gt;</a>s,</li>
<li><a href="worker_threads.html#worker_threads_class_messageport" rel="nofollow" class="type">&lt;MessagePort&gt;</a>s,</li>
<li><a href="net.html#net_class_net_blocklist" rel="nofollow" class="type">&lt;net.BlockList&gt;</a>s,</li>
<li><a href="net.html#net_class_net_socketaddress" rel="nofollow" class="type">&lt;net.SocketAddress&gt;</a>es,</li>
<li><a href="crypto.html#crypto_class_x509certificate" rel="nofollow" class="type">&lt;X509Certificate&gt;</a>s.</li>
</ul>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { MessageChannel } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> MessageChannel();

port1.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(message));

<span class="hljs-keyword">const</span> circularData = {};
circularData.foo = circularData;
<span class="hljs-comment">// Prints: { foo: [Circular] }</span>
port2.postMessage(circularData);</code></pre>
<p><code>transferList</code> may be a list of <a href="http://url.nodejs.cn/mUbfvF"><code>ArrayBuffer</code></a>, <a href="worker_threads.html#worker_threads_class_messageport"><code>MessagePort</code></a> and
<a href="fs.html#fs_class_filehandle"><code>FileHandle</code></a> objects.
After transferring, they are not usable on the sending side of the channel
anymore (even if they are not contained in <code>value</code>). Unlike with
<a href="child_process.html">child processes</a>, transferring handles such as network sockets is currently
not supported.</p>
<p>If <code>value</code> contains <a href="http://url.nodejs.cn/6J6LBy"><code>SharedArrayBuffer</code></a> instances, those are accessible
from either thread. They cannot be listed in <code>transferList</code>.</p>
<p><code>value</code> may still contain <code>ArrayBuffer</code> instances that are not in
<code>transferList</code>; in that case, the underlying memory is copied rather than moved.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { MessageChannel } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> MessageChannel();

port1.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(message));

<span class="hljs-keyword">const</span> uint8Array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ]);
<span class="hljs-comment">// This posts a copy of `uint8Array`:</span>
port2.postMessage(uint8Array);
<span class="hljs-comment">// This does not copy data, but renders `uint8Array` unusable:</span>
port2.postMessage(uint8Array, [ uint8Array.buffer ]);

<span class="hljs-comment">// The memory for the `sharedUint8Array` is accessible from both the</span>
<span class="hljs-comment">// original and the copy received by `.on('message')`:</span>
<span class="hljs-keyword">const</span> sharedUint8Array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-keyword">new</span> SharedArrayBuffer(<span class="hljs-number">4</span>));
port2.postMessage(sharedUint8Array);

<span class="hljs-comment">// This transfers a freshly created message port to the receiver.</span>
<span class="hljs-comment">// This can be used, for example, to create communication channels between</span>
<span class="hljs-comment">// multiple `Worker` threads that are children of the same parent thread.</span>
<span class="hljs-keyword">const</span> otherChannel = <span class="hljs-keyword">new</span> MessageChannel();
port2.postMessage({ <span class="hljs-attr">port</span>: otherChannel.port1 }, [ otherChannel.port1 ]);</code></pre>
<p>The message object is cloned immediately, and can be modified after
posting without having side effects.</p>
<p>For more information on the serialization and deserialization mechanisms
behind this API, see the <a href="v8.html#v8_serialization_api">serialization API of the <code>v8</code> module</a>.</p>
<h5>传输 TypedArray 和 Buffer 时的注意事项<span><a class="mark" href="#worker_threads_considerations_when_transferring_typedarrays_and_buffers" id="worker_threads_considerations_when_transferring_typedarrays_and_buffers">#</a></span></h5><p class="tip_wrap" data-item_id="considerations_when_transferring_typedarrays_and_buffers"></p>
<p>All <code>TypedArray</code> and <code>Buffer</code> instances are views over an underlying
<code>ArrayBuffer</code>. That is, it is the <code>ArrayBuffer</code> that actually stores
the raw data while the <code>TypedArray</code> and <code>Buffer</code> objects provide a
way of viewing and manipulating the data. It is possible and common
for multiple views to be created over the same <code>ArrayBuffer</code> instance.
Great care must be taken when using a transfer list to transfer an
<code>ArrayBuffer</code> as doing so causes all <code>TypedArray</code> and <code>Buffer</code>
instances that share that same <code>ArrayBuffer</code> to become unusable.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>);

<span class="hljs-keyword">const</span> u1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(ab);
<span class="hljs-keyword">const</span> u2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(ab);

<span class="hljs-built_in">console</span>.log(u2.length);  <span class="hljs-comment">// prints 5</span>

port.postMessage(u1, [u1.buffer]);

<span class="hljs-built_in">console</span>.log(u2.length);  <span class="hljs-comment">// prints 0</span></code></pre>
<p>For <code>Buffer</code> instances, specifically, whether the underlying
<code>ArrayBuffer</code> can be transferred or cloned depends entirely on how
instances were created, which often cannot be reliably determined.</p>
<p>An <code>ArrayBuffer</code> can be marked with <a href="worker_threads.html#worker_threads_worker_markasuntransferable_object"><code>markAsUntransferable()</code></a> to indicate
that it should always be cloned and never transferred.</p>
<p>Depending on how a <code>Buffer</code> instance was created, it may or may
not own its underlying <code>ArrayBuffer</code>. An <code>ArrayBuffer</code> must not
be transferred unless it is known that the <code>Buffer</code> instance
owns it. In particular, for <code>Buffer</code>s created from the internal
<code>Buffer</code> pool (using, for instance <code>Buffer.from()</code> or <code>Buffer.allocUnsafe()</code>),
transferring them is not possible and they are always cloned,
which sends a copy of the entire <code>Buffer</code> pool.
This behavior may come with unintended higher memory
usage and possible security concerns.</p>
<p>See <a href="buffer.html#buffer_static_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> for more details on <code>Buffer</code> pooling.</p>
<p>The <code>ArrayBuffer</code>s for <code>Buffer</code> instances created using
<code>Buffer.alloc()</code> or <code>Buffer.allocUnsafeSlow()</code> can always be
transferred but doing so renders all other existing views of
those <code>ArrayBuffer</code>s unusable.</p>
<h5>使用原型、类和访问器克隆对象时的注意事项<span><a class="mark" href="#worker_threads_considerations_when_cloning_objects_with_prototypes_classes_and_accessors" id="worker_threads_considerations_when_cloning_objects_with_prototypes_classes_and_accessors">#</a></span></h5><p class="tip_wrap" data-item_id="considerations_when_cloning_objects_with_prototypes_classes_and_accessors"></p>
<p>Because object cloning uses the <a href="http://url.nodejs.cn/SLsDHc">HTML structured clone algorithm</a>,
non-enumerable properties, property accessors, and object prototypes are
not preserved. In particular, <a href="buffer.html"><code>Buffer</code></a> objects will be read as
plain <a href="http://url.nodejs.cn/ZbDkpm"><code>Uint8Array</code></a>s on the receiving side, and instances of JavaScript
classes will be cloned as plain JavaScript objects.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'b'</span>);

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  #a = <span class="hljs-number">1</span>;
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>[b] = <span class="hljs-number">2</span>;
    <span class="hljs-built_in">this</span>.c = <span class="hljs-number">3</span>;
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title">d</span>() { <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; }
}

<span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> MessageChannel();

port1.onmessage = <span class="hljs-function">(<span class="hljs-params">{ data }</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(data);

port2.postMessage(<span class="hljs-keyword">new</span> Foo());

<span class="hljs-comment">// Prints: { c: 3 }</span></code></pre>
<p>This limitation extends to many built-in objects, such as the global <code>URL</code>
object:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { port1, port2 } = <span class="hljs-keyword">new</span> MessageChannel();

port1.onmessage = <span class="hljs-function">(<span class="hljs-params">{ data }</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(data);

port2.postMessage(<span class="hljs-keyword">new</span> URL(<span class="hljs-string">'https://example.org'</span>));

<span class="hljs-comment">// Prints: { }</span></code></pre>
<h4><code>port.ref()</code><span><a class="mark" href="#worker_threads_port_ref" id="worker_threads_port_ref">#</a></span></h4><p class="tip_wrap" data-item_id="port_ref"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>Opposite of <code>unref()</code>. Calling <code>ref()</code> on a previously <code>unref()</code>ed port does
<em>not</em> let the program exit if it's the only active handle left (the default
behavior). If the port is <code>ref()</code>ed, calling <code>ref()</code> again has no effect.</p>
<p>If listeners are attached or removed using <code>.on('message')</code>, the port
is <code>ref()</code>ed and <code>unref()</code>ed automatically depending on whether
listeners for the event exist.</p>
<h4><code>port.start()</code><span><a class="mark" href="#worker_threads_port_start" id="worker_threads_port_start">#</a></span></h4><p class="tip_wrap" data-item_id="port_start"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>Starts receiving messages on this <code>MessagePort</code>. When using this port
as an event emitter, this is called automatically once <code>'message'</code>
listeners are attached.</p>
<p>This method exists for parity with the Web <code>MessagePort</code> API. In Node.js,
it is only useful for ignoring messages when no event listener is present.
Node.js also diverges in its handling of <code>.onmessage</code>. Setting it
automatically calls <code>.start()</code>, but unsetting it lets messages queue up
until a new handler is set or the port is discarded.</p>
<h4><code>port.unref()</code><span><a class="mark" href="#worker_threads_port_unref" id="worker_threads_port_unref">#</a></span></h4><p class="tip_wrap" data-item_id="port_unref"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>Calling <code>unref()</code> on a port allows the thread to exit if this is the only
active handle in the event system. If the port is already <code>unref()</code>ed calling
<code>unref()</code> again has no effect.</p>
<p>If listeners are attached or removed using <code>.on('message')</code>, the port is
<code>ref()</code>ed and <code>unref()</code>ed automatically depending on whether
listeners for the event exist.</p>
</section><section><h3><code>Worker</code> 类<span><a class="mark" href="#worker_threads_class_worker" id="worker_threads_class_worker">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_worker">
                <a href="worker_threads/class_worker.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li>继承自: <a href="events.html#events_class_eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p><code>Worker</code> 类代表一个独立的 JavaScript 执行线程。
大多数 Node.js API 都在其中可用。</p>
<p>工作线程环境中的显着差异是：</p>
<ul>
<li>父线程可以重定向 <a href="process.html#process_process_stdin"><code>process.stdin</code></a>、<a href="process.html#process_process_stdout"><code>process.stdout</code></a> 和 <a href="process.html#process_process_stderr"><code>process.stderr</code></a>。</li>
<li><a href="worker_threads.html#worker_threads_worker_ismainthread"><code>require('worker_threads').isMainThread</code></a> 属性被设置为 <code>false</code>。</li>
<li><a href="worker_threads.html#worker_threads_worker_parentport"><code>require('worker_threads').parentPort</code></a> 消息端口可用。</li>
<li><a href="process.html#process_process_exit_code"><code>process.exit()</code></a> 不会停止整个程序，仅停止单个线程，且 <a href="process.html#process_process_abort"><code>process.abort()</code></a> 不可用。</li>
<li><a href="process.html#process_process_chdir_directory"><code>process.chdir()</code></a> 和设置群组或用户标识的 <code>process</code> 方法不可用。</li>
<li><a href="process.html#process_process_env"><code>process.env</code></a> 是父线程的环境变量的副本，除非另外指定。
对一个副本的更改将会在其他线程中不可见，并且对原生插件也不可见（除非 <a href="worker_threads.html#worker_threads_worker_share_env"><code>worker.SHARE_ENV</code></a> 作为 <code>env</code> 选项传给 <a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> 的构造函数）。</li>
<li><a href="process.html#process_process_title"><code>process.title</code></a> 无法被修改。</li>
<li>信号将不会通过 <a href="process.html#process_signal_events"><code>process.on('...')</code></a> 传递。</li>
<li>调用 <a href="worker_threads.html#worker_threads_worker_terminate"><code>worker.terminate()</code></a> 可能会随时停止执行。</li>
<li>无法访问父进程的 IPC 通道。</li>
<li>不支持 <a href="tracing.html"><code>trace_events</code></a> 模块。</li>
<li>如果原生插件满足<a href="addons.html#addons_worker_support">特定条件</a>，则只能从多个线程中加载它们。</li>
</ul>
<p>可以在其他 <code>Worker</code> 实例中创建 <code>Worker</code> 实例。</p>
<p>与 <a href="http://url.nodejs.cn/skL7X7">Web 工作线程</a>和 <a href="cluster.html"><code>cluster</code> 模块</a>一样，可以通过线程间的消息传递来实现双向通信。
在内部，一个 <code>Worker</code> 具有一对内置的 <a href="worker_threads.html#worker_threads_class_messageport"><code>MessagePort</code></a>，在创建该 <code>Worker</code> 时它们已经相互关联。
虽然父端的 <code>MessagePort</code> 对象没有直接公开，但其功能是通过父线程的 <code>Worker</code> 对象上的 <a href="worker_threads.html#worker_threads_worker_postmessage_value_transferlist"><code>worker.postMessage()</code></a> 和 <a href="worker_threads.html#worker_threads_event_message_1"><code>worker.on('message')</code></a> 事件公开的。</p>
<p>要创建自定义的消息传递通道（建议使用默认的全局通道，因为这样可以促进关联点的分离），用户可以在任一线程上创建一个 <code>MessageChannel</code> 对象，并将该 <code>MessageChannel</code> 上的 <code>MessagePort</code> 中的一个通过预先存在的通道传给另一个线程，例如全局的通道。</p>
<p>有关如何传递消息以及可以通过线程屏障成功地传输哪类 JavaScript 值的更多信息，请参见 <a href="worker_threads.html#worker_threads_port_postmessage_value_transferlist"><code>port.postMessage()</code></a>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>);
<span class="hljs-keyword">const</span> {
  Worker, MessageChannel, MessagePort, isMainThread, parentPort
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);
<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(__filename);
  <span class="hljs-keyword">const</span> subChannel = <span class="hljs-keyword">new</span> MessageChannel();
  worker.postMessage({ <span class="hljs-attr">hereIsYourPort</span>: subChannel.port1 }, [subChannel.port1]);
  subChannel.port2.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'接收到:'</span>, value);
  });
} <span class="hljs-keyword">else</span> {
  parentPort.once(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    assert(value.hereIsYourPort <span class="hljs-keyword">instanceof</span> MessagePort);
    value.hereIsYourPort.postMessage(<span class="hljs-string">'工作线程正在发送此消息'</span>);
    value.hereIsYourPort.close();
  });
}</code></pre>
<h4><code>new Worker(filename[, options])</code><span><a class="mark" href="#worker_threads_new_worker_filename_options" id="worker_threads_new_worker_filename_options">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="new_worker_filename_options">
                <a href="worker_threads/new_worker_filename_options.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.9.0</td>
<td><p>The <code>filename</code> parameter can be a WHATWG <code>URL</code> object using <code>data:</code> protocol.</p></td></tr>
<tr><td>v14.9.0</td>
<td><p>The <code>trackUnmanagedFds</code> option was set to <code>true</code> by default.</p></td></tr>
<tr><td>v14.6.0</td>
<td><p>The <code>trackUnmanagedFds</code> option was introduced.</p></td></tr>
<tr><td>v14.0.0</td>
<td><p>The <code>transferList</code> option was introduced.</p></td></tr>
<tr><td>v13.12.0</td>
<td><p>The <code>filename</code> parameter can be a WHATWG <code>URL</code> object using <code>file:</code> protocol.</p></td></tr>
<tr><td>v13.4.0, v12.16.0</td>
<td><p>The <code>argv</code> option was introduced.</p></td></tr>
<tr><td>v13.2.0, v12.16.0</td>
<td><p>The <code>resourceLimits</code> option was introduced.</p></td></tr>
<tr><td>v10.5.0</td>
<td><p><span>新增于: v10.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>filename</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 工作线程主脚本的路径。必须是以 <code>./</code> 或 <code>../</code> 开头的绝对路径或相对路径（即相对于当前工作目录）、或者使用 <code>file:</code> 或 <code>data:</code> 协议的 WHATWG <code>URL</code> 对象。
When using a <a href="http://url.nodejs.cn/3Lb3vH"><code>data:</code> URL</a>, the data is interpreted based on MIME type using the <a href="esm.html#esm_data_imports">ECMAScript module loader</a>.
如果 <code>options.eval</code> 为 <code>true</code>，则这是一个包含 JavaScript 代码而不是路径的字符串。</li>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>argv</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any[]&gt;</a> 参数列表，其将会被字符串化并附加到工作线程中的 <code>process.argv</code>。
这大部分与 <code>workerData</code> 相似，但是这些值将会在全局的 <code>process.argv</code> 中可用，就好像它们是作为 CLI 选项传给脚本一样。</li>
<li><code>env</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 如果设置，则指定工作线程中 <code>process.env</code> 的初始值。
作为一个特殊值，<a href="worker_threads.html#worker_threads_worker_share_env"><code>worker.SHARE_ENV</code></a> 可以用于指定父线程和子线程应该共享它们的环境变量。
在这种情况下，对一个线程的 <code>process.env</code> 对象的更改也会影响另一个线程。
<strong>默认值:</strong> <code>process.env</code>。</li>
<li><code>eval</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果为 <code>true</code> 且第一个参数是一个 <code>string</code>，则将构造函数的第一个参数解释为工作线程联机后执行的脚本。</li>
<li><code>execArgv</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string[]&gt;</a> 传递给工作线程的 node CLI 选项的列表。
不支持 V8 选项（例如 <code>--max-old-space-size</code>）和影响进程的选项（例如 <code>--title</code>）。
如果设置，则它将会作为工作线程内部的 <a href="process.html#process_process_execargv"><code>process.execArgv</code></a> 提供。
默认情况下，选项将会从父线程继承。</li>
<li><code>stdin</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果将其设置为 <code>true</code>，则 <code>worker.stdin</code> 将会提供一个可写流，其内容将会在工作线程中以 <code>process.stdin</code> 出现。
默认情况下，不提供任何数据。</li>
<li><code>stdout</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果将其设置为 <code>true</code>，则 <code>worker.stdout</code> 将不会自动地通过管道传递到父线程中的 <code>process.stdout</code>。</li>
<li><code>stderr</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 如果将其设置为 <code>true</code>，则 <code>worker.stderr</code> 将不会自动地通过管道传递到父线程中的 <code>process.stderr</code>。</li>
<li><code>workerData</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> 能被克隆并作为 <a href="worker_threads.html#worker_threads_worker_workerdata"><code>require('worker_threads').workerData</code></a> 的任何 JavaScript 值。
克隆将会按照 <a href="http://url.nodejs.cn/SLsDHc">HTML 结构化克隆算法</a>中描述的进行，如果对象无法被克隆（例如，因为它包含 <code>function</code>），则会抛出错误。</li>
<li><code>trackUnmanagedFds</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> If this is set to <code>true</code>, then the Worker will
track raw file descriptors managed through <a href="fs.html#fs_fs_open_path_flags_mode_callback"><code>fs.open()</code></a> and
<a href="fs.html#fs_fs_close_fd_callback"><code>fs.close()</code></a>, and close them when the Worker exits, similar to other
resources like network sockets or file descriptors managed through
the <a href="fs.html#fs_class_filehandle"><code>FileHandle</code></a> API. This option is automatically inherited by all
nested <code>Worker</code>s. <strong>默认值</strong>: <code>false</code>.</li>
<li><code>transferList</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object[]&gt;</a> If one or more <code>MessagePort</code>-like objects
are passed in <code>workerData</code>, a <code>transferList</code> is required for those
items or <a href="errors.html#errors_err_missing_message_port_in_transfer_list"><code>ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST</code></a> will be thrown.
See <a href="worker_threads.html#worker_threads_port_postmessage_value_transferlist"><code>port.postMessage()</code></a> for more information.</li>
<li><code>resourceLimits</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 新的 JS 引擎实例的一组可选的资源限制。
达到这些限制将会导致终止 <code>Worker</code> 实例。
这些限制仅影响 JS 引擎，并且不影响任何外部数据，包括 <code>ArrayBuffers</code>。
即使设置了这些限制，如果遇到全局内存不足的情况，该进程仍可能中止。
<ul>
<li><code>maxOldGenerationSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 主堆的最大大小，以 MB 为单位。</li>
<li><code>maxYoungGenerationSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 最近创建的对象的堆空间的最大大小。</li>
<li><code>codeRangeSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 用于生成代码的预分配的内存范围的大小。</li>
<li><code>stackSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> The default maximum stack size for the thread.
Small values may lead to unusable Worker instances. <strong>默认值:</strong> <code>4</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4><code>'error'</code> 事件<span><a class="mark" href="#worker_threads_event_error" id="worker_threads_event_error">#</a></span></h4><p class="tip_wrap" data-item_id="event_error"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><code>err</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
</ul>
<p>The <code>'error'</code> event is emitted if the worker thread throws an uncaught
exception. In that case, the worker is terminated.</p>
<h4><code>'exit'</code> 事件<span><a class="mark" href="#worker_threads_event_exit" id="worker_threads_event_exit">#</a></span></h4><p class="tip_wrap" data-item_id="event_exit"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><code>exitCode</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>The <code>'exit'</code> event is emitted once the worker has stopped. If the worker
exited by calling <a href="process.html#process_process_exit_code"><code>process.exit()</code></a>, the <code>exitCode</code> parameter is the
passed exit code. If the worker was terminated, the <code>exitCode</code> parameter is
<code>1</code>.</p>
<p>This is the final event emitted by any <code>Worker</code> instance.</p>
<h4><code>'message'</code> 事件<span><a class="mark" href="#worker_threads_event_message_1" id="worker_threads_event_message_1">#</a></span></h4><p class="tip_wrap" data-item_id="event_message_1"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><code>value</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a> The transmitted value</li>
</ul>
<p>The <code>'message'</code> event is emitted when the worker thread has invoked
<a href="worker_threads.html#worker_threads_worker_postmessage_value_transferlist"><code>require('worker_threads').parentPort.postMessage()</code></a>.
See the <a href="worker_threads.html#worker_threads_event_message"><code>port.on('message')</code></a> event for more details.</p>
<p>All messages sent from the worker thread are emitted before the
<a href="worker_threads.html#worker_threads_event_exit"><code>'exit'</code> event</a> is emitted on the <code>Worker</code> object.</p>
<h4><code>'messageerror'</code> 事件<span><a class="mark" href="#worker_threads_event_messageerror_1" id="worker_threads_event_messageerror_1">#</a></span></h4><p class="tip_wrap" data-item_id="event_messageerror_1"></p>
<div class="api_metadata">
<span>新增于: v14.5.0, v12.19.0</span>
</div>
<ul>
<li><code>error</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a> An Error object</li>
</ul>
<p>The <code>'messageerror'</code> event is emitted when deserializing a message failed.</p>
<h4><code>'online'</code> 事件<span><a class="mark" href="#worker_threads_event_online" id="worker_threads_event_online">#</a></span></h4><p class="tip_wrap" data-item_id="event_online"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>The <code>'online'</code> event is emitted when the worker thread has started executing
JavaScript code.</p>
<h4><code>worker.getHeapSnapshot()</code><span><a class="mark" href="#worker_threads_worker_getheapsnapshot" id="worker_threads_worker_getheapsnapshot">#</a></span></h4><p class="tip_wrap" data-item_id="worker_getheapsnapshot"></p>
<div class="api_metadata">
<span>新增于: v13.9.0, v12.17.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/ri1kj8" rel="nofollow" class="type">&lt;Promise&gt;</a> A promise for a Readable Stream containing
a V8 heap snapshot</li>
</ul>
<p>Returns a readable stream for a V8 snapshot of the current state of the Worker.
See <a href="v8.html#v8_v8_getheapsnapshot"><code>v8.getHeapSnapshot()</code></a> for more details.</p>
<p>If the Worker thread is no longer running, which may occur before the
<a href="worker_threads.html#worker_threads_event_exit"><code>'exit'</code> event</a> is emitted, the returned <code>Promise</code> is rejected
immediately with an <a href="errors.html#ERR_WORKER_NOT_RUNNING"><code>ERR_WORKER_NOT_RUNNING</code></a> error.</p>
<h4><code>worker.performance</code><span><a class="mark" href="#worker_threads_worker_performance" id="worker_threads_worker_performance">#</a></span></h4><p class="tip_wrap" data-item_id="worker_performance"></p>
<div class="api_metadata">
<span>新增于: v15.1.0, v12.22.0</span>
</div>
<p>An object that can be used to query performance information from a worker
instance. Similar to <a href="perf_hooks.html#perf_hooks_perf_hooks_performance"><code>perf_hooks.performance</code></a>.</p>
<h5><code>performance.eventLoopUtilization([utilization1[, utilization2]])</code><span><a class="mark" href="#worker_threads_performance_eventlooputilization_utilization1_utilization2" id="worker_threads_performance_eventlooputilization_utilization1_utilization2">#</a></span></h5><p class="tip_wrap" data-item_id="performance_eventlooputilization_utilization1_utilization2"></p>
<div class="api_metadata">
<span>新增于: v15.1.0, v12.22.0</span>
</div>
<ul>
<li><code>utilization1</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> The result of a previous call to
<code>eventLoopUtilization()</code>.</li>
<li><code>utilization2</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> The result of a previous call to
<code>eventLoopUtilization()</code> prior to <code>utilization1</code>.</li>
<li>Returns <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>idle</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>active</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>utilization</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
</li>
</ul>
<p>The same call as <a href="perf_hooks.html#perf_hooks_performance_eventlooputilization_utilization1_utilization2"><code>perf_hooks</code> <code>eventLoopUtilization()</code></a>, except the values
of the worker instance are returned.</p>
<p>One difference is that, unlike the main thread, bootstrapping within a worker
is done within the event loop. So the event loop utilization is
immediately available once the worker's script begins execution.</p>
<p>An <code>idle</code> time that does not increase does not indicate that the worker is
stuck in bootstrap. The following examples shows how the worker's entire
lifetime never accumulates any <code>idle</code> time, but is still be able to process
messages.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> { Worker, isMainThread, parentPort } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(__filename);
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    worker.postMessage(<span class="hljs-string">'hi'</span>);
    <span class="hljs-built_in">console</span>.log(worker.performance.eventLoopUtilization());
  }, <span class="hljs-number">100</span>).unref();
  <span class="hljs-keyword">return</span>;
}

parentPort.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'msg'</span>)).unref();
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">r</span>(<span class="hljs-params">n</span>) </span>{
  <span class="hljs-keyword">if</span> (--n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
  <span class="hljs-keyword">const</span> t = <span class="hljs-built_in">Date</span>.now();
  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - t &lt; <span class="hljs-number">300</span>);
  setImmediate(r, n);
})(<span class="hljs-number">10</span>);</code></pre>
<p>The event loop utilization of a worker is available only after the <a href="worker_threads.html#worker_threads_event_online"><code>'online'</code>
event</a> emitted, and if called before this, or after the <a href="worker_threads.html#worker_threads_event_exit"><code>'exit'</code>
event</a>, then all properties have the value of <code>0</code>.</p>
<h4><code>worker.postMessage(value[, transferList])</code><span><a class="mark" href="#worker_threads_worker_postmessage_value_transferlist" id="worker_threads_worker_postmessage_value_transferlist">#</a></span></h4><p class="tip_wrap" data-item_id="worker_postmessage_value_transferlist"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><code>value</code> <a href="http://url.nodejs.cn/6sTGdS" rel="nofollow" class="type">&lt;any&gt;</a></li>
<li><code>transferList</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object[]&gt;</a></li>
</ul>
<p>Send a message to the worker that is received via
<a href="worker_threads.html#worker_threads_event_message"><code>require('worker_threads').parentPort.on('message')</code></a>.
See <a href="worker_threads.html#worker_threads_port_postmessage_value_transferlist"><code>port.postMessage()</code></a> for more details.</p>
<h4><code>worker.ref()</code><span><a class="mark" href="#worker_threads_worker_ref" id="worker_threads_worker_ref">#</a></span></h4><p class="tip_wrap" data-item_id="worker_ref"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>Opposite of <code>unref()</code>, calling <code>ref()</code> on a previously <code>unref()</code>ed worker does
<em>not</em> let the program exit if it's the only active handle left (the default
behavior). If the worker is <code>ref()</code>ed, calling <code>ref()</code> again has
no effect.</p>
<h4><code>worker.resourceLimits</code><span><a class="mark" href="#worker_threads_worker_resourcelimits_1" id="worker_threads_worker_resourcelimits_1">#</a></span></h4><p class="tip_wrap" data-item_id="worker_resourcelimits_1"></p>
<div class="api_metadata">
<span>新增于: v13.2.0, v12.16.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a>
<ul>
<li><code>maxYoungGenerationSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>maxOldGenerationSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>codeRangeSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
<li><code>stackSizeMb</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a></li>
</ul>
</li>
</ul>
<p>Provides the set of JS engine resource constraints for this Worker thread.
If the <code>resourceLimits</code> option was passed to the <a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> constructor,
this matches its values.</p>
<p>If the worker has stopped, the return value is an empty object.</p>
<h4><code>worker.stderr</code><span><a class="mark" href="#worker_threads_worker_stderr" id="worker_threads_worker_stderr">#</a></span></h4><p class="tip_wrap" data-item_id="worker_stderr"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><a href="stream.html#stream_class_stream_readable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a></li>
</ul>
<p>This is a readable stream which contains data written to <a href="process.html#process_process_stderr"><code>process.stderr</code></a>
inside the worker thread. If <code>stderr: true</code> was not passed to the
<a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> constructor, then data is piped to the parent thread's
<a href="process.html#process_process_stderr"><code>process.stderr</code></a> stream.</p>
<h4><code>worker.stdin</code><span><a class="mark" href="#worker_threads_worker_stdin" id="worker_threads_worker_stdin">#</a></span></h4><p class="tip_wrap" data-item_id="worker_stdin"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/334hvC" rel="nofollow" class="type">&lt;null&gt;</a> | <a href="stream.html#stream_class_stream_writable" rel="nofollow" class="type">&lt;stream.Writable&gt;</a></li>
</ul>
<p>If <code>stdin: true</code> was passed to the <a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> constructor, this is a
writable stream. The data written to this stream will be made available in
the worker thread as <a href="process.html#process_process_stdin"><code>process.stdin</code></a>.</p>
<h4><code>worker.stdout</code><span><a class="mark" href="#worker_threads_worker_stdout" id="worker_threads_worker_stdout">#</a></span></h4><p class="tip_wrap" data-item_id="worker_stdout"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><a href="stream.html#stream_class_stream_readable" rel="nofollow" class="type">&lt;stream.Readable&gt;</a></li>
</ul>
<p>This is a readable stream which contains data written to <a href="process.html#process_process_stdout"><code>process.stdout</code></a>
inside the worker thread. If <code>stdout: true</code> was not passed to the
<a href="worker_threads.html#worker_threads_class_worker"><code>Worker</code></a> constructor, then data is piped to the parent thread's
<a href="process.html#process_process_stdout"><code>process.stdout</code></a> stream.</p>
<h4><code>worker.terminate()</code><span><a class="mark" href="#worker_threads_worker_terminate" id="worker_threads_worker_terminate">#</a></span></h4><p class="tip_wrap" data-item_id="worker_terminate"></p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v12.5.0</td>
<td><p>This function now returns a Promise. Passing a callback is deprecated, and was useless up to this version, as the Worker was actually terminated synchronously. Terminating is now a fully asynchronous operation.</p></td></tr>
<tr><td>v10.5.0</td>
<td><p><span>新增于: v10.5.0</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/ri1kj8" rel="nofollow" class="type">&lt;Promise&gt;</a></li>
</ul>
<p>Stop all JavaScript execution in the worker thread as soon as possible.
Returns a Promise for the exit code that is fulfilled when the
<a href="worker_threads.html#worker_threads_event_exit"><code>'exit'</code> event</a> is emitted.</p>
<h4><code>worker.threadId</code><span><a class="mark" href="#worker_threads_worker_threadid_1" id="worker_threads_worker_threadid_1">#</a></span></h4><p class="tip_wrap" data-item_id="worker_threadid_1"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<ul>
<li><a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>An integer identifier for the referenced thread. Inside the worker thread,
it is available as <a href="worker_threads.html#worker_threads_worker_threadid"><code>require('worker_threads').threadId</code></a>.
This value is unique for each <code>Worker</code> instance inside a single process.</p>
<h4><code>worker.unref()</code><span><a class="mark" href="#worker_threads_worker_unref" id="worker_threads_worker_unref">#</a></span></h4><p class="tip_wrap" data-item_id="worker_unref"></p>
<div class="api_metadata">
<span>新增于: v10.5.0</span>
</div>
<p>Calling <code>unref()</code> on a worker allows the thread to exit if this is the only
active handle in the event system. If the worker is already <code>unref()</code>ed calling
<code>unref()</code> again has no effect.</p>
</section><section><h3>注意事项<span><a class="mark" href="#worker_threads_notes" id="worker_threads_notes">#</a></span></h3>
<h4>stdio 的同步阻塞<span><a class="mark" href="#worker_threads_synchronous_blocking_of_stdio" id="worker_threads_synchronous_blocking_of_stdio">#</a></span></h4><p class="tip_wrap" data-item_id="synchronous_blocking_of_stdio"></p>
<p><code>Worker</code>s utilize message passing via <a href="worker_threads.html#worker_threads_class_messageport" rel="nofollow" class="type">&lt;MessagePort&gt;</a> to implement interactions
with <code>stdio</code>. This means that <code>stdio</code> output originating from a <code>Worker</code> can
get blocked by synchronous code on the receiving end that is blocking the
Node.js event loop.</p>

<pre><input class="js-flavor-selector" type="checkbox" checked="" aria-label="Show modern ES modules syntax"><code class="language-js mjs"><span class="hljs-keyword">import</span> {
  Worker,
  isMainThread,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'worker_threads'</span>;

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-keyword">new</span> Worker(<span class="hljs-keyword">new</span> URL(<span class="hljs-keyword">import</span>.meta.url));
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">1e10</span>; n++) {}
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// This output will be blocked by the for loop in the main thread.</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);
}</code><code class="language-js cjs"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">const</span> {
  Worker,
  isMainThread,
} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'worker_threads'</span>);

<span class="hljs-keyword">if</span> (isMainThread) {
  <span class="hljs-keyword">new</span> Worker(__filename);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">1e10</span>; n++) {}
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// This output will be blocked by the for loop in the main thread.</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'foo'</span>);
}</code></pre>
<h4>从预加载脚本启动工作线程<span><a class="mark" href="#worker_threads_launching_worker_threads_from_preload_scripts" id="worker_threads_launching_worker_threads_from_preload_scripts">#</a></span></h4><p class="tip_wrap" data-item_id="launching_worker_threads_from_preload_scripts"></p>
<p>Take care when launching worker threads from preload scripts (scripts loaded
and run using the <code>-r</code> command line flag). Unless the <code>execArgv</code> option is
explicitly set, new Worker threads automatically inherit the command line flags
from the running process and will preload the same preload scripts as the main
thread. If the preload script unconditionally launches a worker thread, every
thread spawned will spawn another until the application crashes.</p></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  
  <!-- <script src="//cdn.staticfile.org/highlight.js/10.2.1/highlight.min.js"></script> -->
  
  


</body></html>