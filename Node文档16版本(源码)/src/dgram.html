<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>dgram 数据报 | Node.js API 文档</title>
  <link rel="icon" sizes="32x32" type="image/png" href="//static.nodejs.cn/_static/img/favicon.png">
  <link href="css/api.css?1625411139166" rel="stylesheet">
</head>

<body class="alt apidoc" id="page_api">
  <div id="content" class="clearfix">
    <div id="column2" class="interior">
      <div id="intro" class="interior">
        <a href="/" rel="nofollow">
          Node.js 中文网
        </a>

      </div>
      <!-- <ul>
          <li><a href="./" class="nav-documentation">v16.4.1</a></li>
        </ul> -->
      <div id="biz_nav"><a title="云服务器" target="_blank" rel="nofollow"><img></a></div>
      <div class="line"></div>
      <ul>
<li><a href="assert.html" rel="nofollow">assert<span class="api_nav_cn_name">断言</span></a></li>
<li><a href="async_hooks.html" rel="nofollow">async_hooks<span class="api_nav_cn_name">异步钩子</span></a></li>
<li><a href="buffer.html" rel="nofollow">Buffer<span class="api_nav_cn_name">缓冲区</span></a></li>
<li><a href="child_process.html" rel="nofollow">child_process<span class="api_nav_cn_name">子进程</span></a></li>
<li><a href="cluster.html" rel="nofollow">cluster<span class="api_nav_cn_name">集群</span></a></li>
<li><a href="console.html" rel="nofollow">console<span class="api_nav_cn_name">控制台</span></a></li>
<li><a href="crypto.html" rel="nofollow">crypto<span class="api_nav_cn_name">加密</span></a></li>
<li><a href="debugger.html" rel="nofollow">debugger<span class="api_nav_cn_name">调试器</span></a></li>
<li><a href="dgram.html" rel="nofollow">dgram<span class="api_nav_cn_name">数据报</span></a></li>
<li><a href="diagnostics_channel.html" rel="nofollow"><span style="font-size:14px;">diagnostics_channel</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:2px;">诊断通道</span></a></li>
<li><a href="dns.html" rel="nofollow">dns<span class="api_nav_cn_name">域名服务器</span></a></li>
<li><a href="domain.html" rel="nofollow">domain<span class="api_nav_cn_name">域</span></a></li>
<li><a href="errors.html" rel="nofollow">Error<span class="api_nav_cn_name">错误</span></a></li>
<li><a href="events.html" rel="nofollow">events<span class="api_nav_cn_name">事件触发器</span></a></li>
<li><a href="fs.html" rel="nofollow">fs<span class="api_nav_cn_name">文件系统</span></a></li>
<li><a href="globals.html" rel="nofollow">global<span class="api_nav_cn_name">全局变量</span></a></li>
<li><a href="http.html" rel="nofollow">http<span class="api_nav_cn_name">超文本传输协议</span></a></li>
<li><a href="http2.html" rel="nofollow">http2<span class="api_nav_cn_name">超文本传输协议2.0</span></a></li>
<li><a href="https.html" rel="nofollow">https<span class="api_nav_cn_name">安全超文本传输协议</span></a></li>
<li><a href="inspector.html" rel="nofollow">inspector<span class="api_nav_cn_name">检查器</span></a></li>
<li><a href="intl.html" rel="nofollow">Intl<span class="api_nav_cn_name">国际化</span></a></li>
<li><a href="module.html" rel="nofollow">module<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="net.html" rel="nofollow">net<span class="api_nav_cn_name">网络</span></a></li>
<li><a href="os.html" rel="nofollow">os<span class="api_nav_cn_name">操作系统</span></a></li>
<li><a href="path.html" rel="nofollow">path<span class="api_nav_cn_name">路径</span></a></li>
<li><a href="perf_hooks.html" rel="nofollow">perf_hooks<span class="api_nav_cn_name">性能钩子</span></a></li>
<li><a href="process.html" rel="nofollow">process<span class="api_nav_cn_name">进程</span></a></li>
<li><a href="punycode.html" rel="nofollow">punycode<span class="api_nav_cn_name">域名代码</span></a></li>
<li><a href="querystring.html" rel="nofollow">querystring<span class="api_nav_cn_name">查询字符串</span></a></li>
<li><a href="readline.html" rel="nofollow">readline<span class="api_nav_cn_name">逐行读取</span></a></li>
<li><a href="repl.html" rel="nofollow">repl<span class="api_nav_cn_name">交互式解释器</span></a></li>
<li><a href="report.html" rel="nofollow">report<span class="api_nav_cn_name">诊断报告</span></a></li>
<li><a href="stream.html" rel="nofollow">stream<span class="api_nav_cn_name">流</span></a></li>
<li><a href="string_decoder.html" rel="nofollow"><span style="font-size:15px;">string_decoder</span><span class="api_nav_cn_name" style="font-size:12px;padding-left:6px;">字符串解码器</span></a></li>
<li><a href="timers.html" rel="nofollow">timer<span class="api_nav_cn_name">定时器</span></a></li>
<li><a href="tls.html" rel="nofollow">tls<span class="api_nav_cn_name">安全传输层</span></a></li>
<li><a href="tracing.html" rel="nofollow">trace_events<span class="api_nav_cn_name">跟踪事件</span></a></li>
<li><a href="tty.html" rel="nofollow">tty<span class="api_nav_cn_name">终端</span></a></li>
<li><a href="url.html" rel="nofollow">url<span class="api_nav_cn_name">网址</span></a></li>
<li><a href="util.html" rel="nofollow">util<span class="api_nav_cn_name">实用工具</span></a></li>
<li><a href="v8.html" rel="nofollow">v8<span class="api_nav_cn_name">引擎</span></a></li>
<li><a href="vm.html" rel="nofollow">vm<span class="api_nav_cn_name">虚拟机</span></a></li>
<li><a href="wasi.html" rel="nofollow">wasi<span class="api_nav_cn_name">WebAssembly系统接口</span></a></li>
<li><a href="webcrypto.html" rel="nofollow">webcrypto<span class="api_nav_cn_name">Web加密</span></a></li>
<li><a href="worker_threads.html" rel="nofollow">worker_threads<span class="api_nav_cn_name">工作线程</span></a></li>
<li><a href="zlib.html" rel="nofollow">zlib<span class="api_nav_cn_name">压缩</span></a></li>
</ul>
<hr class="line">
<ul>
<li><a href="documentation.html" rel="nofollow">关于本文档</a></li>
<li><a href="synopsis.html" rel="nofollow">用法与示例</a></li>
<li><a href="cli.html" rel="nofollow">命令行选项</a></li>
<li><a href="modules.html" rel="nofollow">CommonJS<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="esm.html" rel="nofollow">ECMAScript<span class="api_nav_cn_name">模块</span></a></li>
<li><a href="packages.html" rel="nofollow">包模块</a></li>
<li><a href="addons.html" rel="nofollow">C++<span class="api_nav_cn_name">插件</span></a></li>
<li><a href="embedding.html" rel="nofollow">C++<span class="api_nav_cn_name">嵌入器</span></a></li>
<li><a href="n-api.html" rel="nofollow">N-API</a></li>
<li><a href="async_context.html" rel="nofollow">异步上下文跟踪</a></li>
<li><a href="policy.html" rel="nofollow">安全策略</a></li>
<li><a href="deprecations.html" rel="nofollow">弃用的<span class="api_nav_cn_name">API</span></a></li>
</ul>

    </div>

    <div id="column1" data-id="dgram" class="interior">
      <header>
        <div class="header-container">
          <h1>Node.js v16.4.1 文档</h1>
          <button class="theme-toggle-btn" id="theme-toggle-btn" title="Toggle dark mode/light mode" aria-label="Toggle dark mode/light mode" hidden="">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" height="24" width="24">
              <path fill="none" d="M0 0h24v24H0z"></path>
              <path d="M11.1 12.08c-2.33-4.51-.5-8.48.53-10.07C6.27 2.2 1.98 6.59 1.98 12c0 .14.02.28.02.42.62-.27 1.29-.42 2-.42 1.66 0 3.18.83 4.1 2.15A4.01 4.01 0 0111 18c0 1.52-.87 2.83-2.12 3.51.98.32 2.03.5 3.11.5 3.5 0 6.58-1.8 8.37-4.52-2.36.23-6.98-.97-9.26-5.41z"></path>
              <path d="M7 16h-.18C6.4 14.84 5.3 14 4 14c-1.66 0-3 1.34-3 3s1.34 3 3 3h3c1.1 0 2-.9 2-2s-.9-2-2-2z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" height="24" width="24">
              <path d="M0 0h24v24H0z" fill="none"></path>
              <path d="M6.76 4.84l-1.8-1.79-1.41 1.41 1.79 1.79 1.42-1.41zM4 10.5H1v2h3v-2zm9-9.95h-2V3.5h2V.55zm7.45 3.91l-1.41-1.41-1.79 1.79 1.41 1.41 1.79-1.79zm-3.21 13.7l1.79 1.8 1.41-1.41-1.8-1.79-1.4 1.4zM20 10.5v2h3v-2h-3zm-8-5c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm-1 16.95h2V19.5h-2v2.95zm-7.45-3.91l1.41 1.41 1.79-1.8-1.41-1.41-1.79 1.8z"></path>
            </svg>
          </button>
        </div>
        <div id="gtoc">
          <ul>
            <li>
              <a href="./">返回文档首页</a>
            </li>
            <li>
              <a href="http://api.nodejs.cn/">搜索</a>
            </li>
          </ul>
        </div>
        <hr>
      </header>

      <details id="toc" open=""><summary>目录</summary><ul>
<li><span class="stability_2"><a href="#dgram_udp_datagram_sockets">dgram 数据报</a></span>
<ul>
<li><a href="#dgram_class_dgram_socket"><code>dgram.Socket</code> 类</a>
<ul>
<li><a href="#dgram_event_close"><code>'close'</code> 事件</a></li>
<li><a href="#dgram_event_connect"><code>'connect'</code> 事件</a></li>
<li><a href="#dgram_event_error"><code>'error'</code> 事件</a></li>
<li><a href="#dgram_event_listening"><code>'listening'</code> 事件</a></li>
<li><a href="#dgram_event_message"><code>'message'</code> 事件</a></li>
<li><a href="#dgram_socket_addmembership_multicastaddress_multicastinterface"><code>socket.addMembership(multicastAddress[, multicastInterface])</code></a></li>
<li><a href="#dgram_socket_addsourcespecificmembership_sourceaddress_groupaddress_multicastinterface"><code>socket.addSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])</code></a></li>
<li><a href="#dgram_socket_address"><code>socket.address()</code></a></li>
<li><a href="#dgram_socket_bind_port_address_callback"><code>socket.bind([port][, address][, callback])</code></a></li>
<li><a href="#dgram_socket_bind_options_callback"><code>socket.bind(options[, callback])</code></a></li>
<li><a href="#dgram_socket_close_callback"><code>socket.close([callback])</code></a></li>
<li><a href="#dgram_socket_connect_port_address_callback"><code>socket.connect(port[, address][, callback])</code></a></li>
<li><a href="#dgram_socket_disconnect"><code>socket.disconnect()</code></a></li>
<li><a href="#dgram_socket_dropmembership_multicastaddress_multicastinterface"><code>socket.dropMembership(multicastAddress[, multicastInterface])</code></a></li>
<li><a href="#dgram_socket_dropsourcespecificmembership_sourceaddress_groupaddress_multicastinterface"><code>socket.dropSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])</code></a></li>
<li><a href="#dgram_socket_getrecvbuffersize"><code>socket.getRecvBufferSize()</code></a></li>
<li><a href="#dgram_socket_getsendbuffersize"><code>socket.getSendBufferSize()</code></a></li>
<li><a href="#dgram_socket_ref"><code>socket.ref()</code></a></li>
<li><a href="#dgram_socket_remoteaddress"><code>socket.remoteAddress()</code></a></li>
<li><a href="#dgram_socket_send_msg_offset_length_port_address_callback"><code>socket.send(msg[, offset, length][, port][, address][, callback])</code></a>
<ul>
<li><a href="#dgram_note_about_udp_datagram_size">关于 UDP 数据报大小的说明</a></li>
</ul>
</li>
<li><a href="#dgram_socket_setbroadcast_flag"><code>socket.setBroadcast(flag)</code></a></li>
<li><a href="#dgram_socket_setmulticastinterface_multicastinterface"><code>socket.setMulticastInterface(multicastInterface)</code></a>
<ul>
<li><a href="#dgram_example_ipv6_outgoing_multicast_interface">IPv6 发送多播数据包</a></li>
<li><a href="#dgram_example_ipv4_outgoing_multicast_interface">IPv4 发送多播数据包</a></li>
<li><a href="#dgram_call_results">调用的结果</a></li>
</ul>
</li>
<li><a href="#dgram_socket_setmulticastloopback_flag"><code>socket.setMulticastLoopback(flag)</code></a></li>
<li><a href="#dgram_socket_setmulticastttl_ttl"><code>socket.setMulticastTTL(ttl)</code></a></li>
<li><a href="#dgram_socket_setrecvbuffersize_size"><code>socket.setRecvBufferSize(size)</code></a></li>
<li><a href="#dgram_socket_setsendbuffersize_size"><code>socket.setSendBufferSize(size)</code></a></li>
<li><a href="#dgram_socket_setttl_ttl"><code>socket.setTTL(ttl)</code></a></li>
<li><a href="#dgram_socket_unref"><code>socket.unref()</code></a></li>
</ul>
</li>
<li><a href="#dgram_dgram_module_functions">dgram 模块的函数</a>
<ul>
<li><a href="#dgram_dgram_createsocket_options_callback"><code>dgram.createSocket(options[, callback])</code></a></li>
<li><a href="#dgram_dgram_createsocket_type_callback"><code>dgram.createSocket(type[, callback])</code></a></li>
</ul>
</li>
</ul>
</li>
</ul></details>

      <!-- <div id="biz_content">
          <a href="http://www.tp-shop.cn/index.php?http_referer=node" target="_blank">
            <img src="//static.nodejs.cn/_static/img/ad/api_content_tpshop.jpg" />
          </a>
        </div> -->

      <div id="apicontent">
        <h2>dgram 数据报<span><a class="mark" href="#dgram_udp_datagram_sockets" id="dgram_udp_datagram_sockets">#</a></span></h2><p class="tip_wrap" data-show_trans="1" data-item_id="udp_datagram_sockets">
                <a href="dgram/udp_datagram_sockets.html" class="tip_trans">中英对照</a>
                </p>
<!--introduced_in=v0.10.0-->
<p></p><div class="api_stability api_stability_2"><a href="documentation.html#documentation_stability_index">稳定性: 2</a> - 稳定</div><p></p>
<!-- name=dgram -->
<p><strong>源代码:</strong> <a rel="nofollow" href="http://url.nodejs.cn/4XQYSF">lib/dgram.js</a></p>
<p><code>dgram</code> 模块提供了 UDP 数据包 socket 的实现。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> server = dgram.createSocket(<span class="hljs-string">'udp4'</span>);

server.on(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`服务器异常：\n<span class="hljs-subst">${err.stack}</span>`</span>);
  server.close();
});

server.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg, rinfo</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`服务器接收到来自 <span class="hljs-subst">${rinfo.address}</span>:<span class="hljs-subst">${rinfo.port}</span> 的 <span class="hljs-subst">${msg}</span>`</span>);
});

server.on(<span class="hljs-string">'listening'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> address = server.address();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`服务器监听 <span class="hljs-subst">${address.address}</span>:<span class="hljs-subst">${address.port}</span>`</span>);
});

server.bind(<span class="hljs-number">41234</span>);
<span class="hljs-comment">// 服务器监听 0.0.0.0:41234</span></code></pre>
<section><h3><code>dgram.Socket</code> 类<span><a class="mark" href="#dgram_class_dgram_socket" id="dgram_class_dgram_socket">#</a></span></h3><p class="tip_wrap" data-show_trans="1" data-item_id="class_dgram_socket">
                <a href="dgram/class_dgram_socket.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<ul>
<li>继承自: <a href="events.html#events_class_eventemitter" rel="nofollow" class="type">&lt;EventEmitter&gt;</a></li>
</ul>
<p>封装了数据报的功能。</p>
<p>使用 <a href="dgram.html#dgram_dgram_createsocket_options_callback"><code>dgram.createSocket()</code></a> 创建 <code>dgram.Socket</code> 的新实例。
不能使用 <code>new</code> 关键字创建 <code>dgram.Socket</code> 实例。</p>
<h4><code>'close'</code> 事件<span><a class="mark" href="#dgram_event_close" id="dgram_event_close">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="event_close">
                <a href="dgram/event_close.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<p><code>'close'</code> 事件将在使用 <a href="dgram.html#dgram_socket_close_callback"><code>close()</code></a> 关闭一个 socket 之后触发。
该事件一旦触发，则这个 socket 上将不会触发新的 <code>'message'</code> 事件。</p>
<h4><code>'connect'</code> 事件<span><a class="mark" href="#dgram_event_connect" id="dgram_event_connect">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="event_connect">
                <a href="dgram/event_connect.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.0.0</span>
</div>
<p>因 <a href="dgram.html#dgram_socket_connect_port_address_callback"><code>connect()</code></a> 调用成功而使 socket 与远程地址关联之后，则会触发 <code>'connect'</code> 事件。</p>
<h4><code>'error'</code> 事件<span><a class="mark" href="#dgram_event_error" id="dgram_event_error">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="event_error">
                <a href="dgram/event_error.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<ul>
<li><code>exception</code> <a href="http://url.nodejs.cn/qZ873x" rel="nofollow" class="type">&lt;Error&gt;</a></li>
</ul>
<p>当有任何错误发生时，<code>'error'</code> 事件将被触发。
事件发生时，事件处理函数仅会接收到一个 <code>Error</code> 对象。</p>
<h4><code>'listening'</code> 事件<span><a class="mark" href="#dgram_event_listening" id="dgram_event_listening">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="event_listening">
                <a href="dgram/event_listening.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<p>每当 <code>dgram.Socket</code> 可被寻址且可以接收数据时，就会触发 <code>'listening'</code> 事件。
这会发生在，显式地使用 <code>socket.bind()</code>、或者隐式地使用 <code>socket.send()</code> 第一次发送数据。
在 <code>dgram.Socket</code> 开始监听之前，底层的系统资源并不存在，且诸如 <code>socket.address()</code> 和 <code>socket.setTTL()</code> 之类的调用都会失败。</p>
<h4><code>'message'</code> 事件<span><a class="mark" href="#dgram_event_message" id="dgram_event_message">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="event_message">
                <a href="dgram/event_message.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<p>当有新的数据包被 socket 接收时，<code>'message'</code> 事件会被触发。<code>msg</code> 和 <code>rinfo</code> 会作为参数传递到该事件的处理函数中。</p>
<ul>
<li><code>msg</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> 消息。</li>
<li><code>rinfo</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 远程地址信息。
<ul>
<li><code>address</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 发送方地址。</li>
<li><code>family</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 地址类型 (<code>'IPv4'</code> 或 <code>'IPv6'</code>)。</li>
<li><code>port</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 发送者端口。</li>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 消息大小。</li>
</ul>
</li>
</ul>
<p>If the source address of the incoming packet is an IPv6 link-local
address, the interface name is added to the <code>address</code>. For
example, a packet received on the <code>en0</code> interface might have the
address field set to <code>'fe80::2618:1234:ab11:3b9c%en0'</code>, where <code>'%en0'</code>
is the interface name as a zone ID suffix.</p>
<h4><code>socket.addMembership(multicastAddress[, multicastInterface])</code><span><a class="mark" href="#dgram_socket_addmembership_multicastaddress_multicastinterface" id="dgram_socket_addmembership_multicastaddress_multicastinterface">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_addmembership_multicastaddress_multicastinterface">
                <a href="dgram/socket_addmembership_multicastaddress_multicastinterface.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.6.9</span>
</div>
<ul>
<li><code>multicastAddress</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>multicastInterface</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>通知内核将 <code>multicastAddress</code> 和 <code>multicastInterface</code> 提供的多路传送集合通过 <code>IP_ADD_MEMBERSHIP</code> 这个 socket 选项结合起来。
若 <code>multicastInterface</code> 参数未指定，则操作系统将会选择一个接口并向其添加成员。
要为所有可用的接口添加成员，可以在每个接口上调用一次 <code>addMembership</code> 方法。</p>
<p>When called on an unbound socket, this method will implicitly bind to a random
port, listening on all interfaces.</p>
<p>当多个 <code>cluster</code> 工作进程之间共享 UDP socket 时，则 <code>socket.addMembership()</code> 函数必须只能被调用一次，否则将会发生 <code>EADDRINUSE</code> 错误：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cluster'</span>);
<span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">if</span> (cluster.isMaster) {
  cluster.fork(); <span class="hljs-comment">// 可工作。</span>
  cluster.fork(); <span class="hljs-comment">// 失败并抛出 EADDRINUSE。</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">const</span> s = dgram.createSocket(<span class="hljs-string">'udp4'</span>);
  s.bind(<span class="hljs-number">1234</span>, <span class="hljs-function">() =&gt;</span> {
    s.addMembership(<span class="hljs-string">'224.0.0.114'</span>);
  });
}</code></pre>
<h4><code>socket.addSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])</code><span><a class="mark" href="#dgram_socket_addsourcespecificmembership_sourceaddress_groupaddress_multicastinterface" id="dgram_socket_addsourcespecificmembership_sourceaddress_groupaddress_multicastinterface">#</a></span></h4><p class="tip_wrap" data-item_id="socket_addsourcespecificmembership_sourceaddress_groupaddress_multicastinterface"></p>
<div class="api_metadata">
<span>新增于: v13.1.0, v12.16.0</span>
</div>
<ul>
<li><code>sourceAddress</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>groupAddress</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>multicastInterface</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>Tells the kernel to join a source-specific multicast channel at the given
<code>sourceAddress</code> and <code>groupAddress</code>, using the <code>multicastInterface</code> with the
<code>IP_ADD_SOURCE_MEMBERSHIP</code> socket option. If the <code>multicastInterface</code> argument
is not specified, the operating system will choose one interface and will add
membership to it. To add membership to every available interface, call
<code>socket.addSourceSpecificMembership()</code> multiple times, once per interface.</p>
<p>When called on an unbound socket, this method will implicitly bind to a random
port, listening on all interfaces.</p>
<h4><code>socket.address()</code><span><a class="mark" href="#dgram_socket_address" id="dgram_socket_address">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_address">
                <a href="dgram/socket_address.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>返回一个包含 socket 地址信息的对象。
对于 UDP socket，该对象将包含 <code>address</code>、<code>family</code> 和 <code>port</code> 属性。</p>
<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
<h4><code>socket.bind([port][, address][, callback])</code><span><a class="mark" href="#dgram_socket_bind_port_address_callback" id="dgram_socket_bind_port_address_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_bind_port_address_callback">
                <a href="dgram/socket_bind_port_address_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v0.9.1</td>
<td><p>The method was changed to an asynchronous execution model. Legacy code would need to be changed to pass a callback function to the method call.</p></td></tr>
<tr><td>v0.1.99</td>
<td><p><span>新增于: v0.1.99</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>port</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>address</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 没有参数。当绑定完成时会被调用。</li>
</ul>
<p>对于 UDP socket，该方法会令 <code>dgram.Socket</code> 在指定的 <code>port</code> 和可选的 <code>address</code> 上监听数据包信息。
若 <code>port</code> 未指定或为 <code>0</code>，操作系统会尝试绑定一个随机的端口。
若 <code>address</code> 未指定，操作系统会尝试在所有地址上监听。
绑定完成时会触发一个 <code>'listening'</code> 事件，并会调用 <code>callback</code> 方法。</p>
<p>同时监听 <code>'listening'</code> 事件和在 <code>socket.bind()</code> 方法中传入 <code>callback</code> 参数并不会带来坏处，但也不是很有用。</p>
<p>一个被绑定的数据包 socket 会令 Node.js 进程保持运行以接收数据包信息。</p>
<p>若绑定失败，一个 <code>'error'</code> 事件会被触发。
在极少数的情况下（例如尝试绑定一个已关闭的 socket），一个 <a href="errors.html#errors_class_error"><code>Error</code></a> 会被抛出。</p>
<p>一个监听 41234 端口的 UDP 服务器的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> server = dgram.createSocket(<span class="hljs-string">'udp4'</span>);

server.on(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`服务器异常：\n<span class="hljs-subst">${err.stack}</span>`</span>);
  server.close();
});

server.on(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg, rinfo</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`服务器收到：<span class="hljs-subst">${msg}</span> 来自 <span class="hljs-subst">${rinfo.address}</span>:<span class="hljs-subst">${rinfo.port}</span>`</span>);
});

server.on(<span class="hljs-string">'listening'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> address = server.address();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`服务器监听 <span class="hljs-subst">${address.address}</span>:<span class="hljs-subst">${address.port}</span>`</span>);
});

server.bind(<span class="hljs-number">41234</span>);
<span class="hljs-comment">// 打印：服务器监听 0.0.0.0:41234</span></code></pre>
<h4><code>socket.bind(options[, callback])</code><span><a class="mark" href="#dgram_socket_bind_options_callback" id="dgram_socket_bind_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_bind_options_callback">
                <a href="dgram/socket_bind_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.11.14</span>
</div>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 必要的。包含以下属性：
<ul>
<li><code>port</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>address</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>exclusive</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
<li><code>fd</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a></li>
</ul>
<p>对于 UDP socket，该方法会令 <code>dgram.Socket</code> 在指定的 <code>port</code> 和可选的 <code>address</code> 上监听数据包信息。
若 <code>port</code> 未指定或为 <code>0</code>，操作系统会尝试绑定一个随机的端口。
若 <code>address</code> 未指定，操作系统会尝试在所有地址上监听。
绑定完成时会触发一个 <code>'listening'</code> 事件，并会调用 <code>callback</code> 方法。</p>
<p><code>options</code> 对象可能包含 <code>fd</code> 属性。
当设置大于 <code>0</code> 的 <code>fd</code> 时，它将会使用给定的文件描述符封装一个现有的 socket。
在这种情况下，<code>port</code> 和 <code>address</code> 的属性将会忽略。</p>
<p>同时监听 <code>'listening'</code> 事件和在 <code>socket.bind()</code> 方法中传入 <code>callback</code> 参数并不会带来坏处，但也不是很有用。</p>
<p>在配合 <a href="cluster.html"><code>cluster</code></a> 模块使用 <code>dgram.Socket</code> 对象时，<code>options</code> 对象可能包含一个附加的 <code>exclusive</code> 属性。
当 <code>exclusive</code> 被设为 <code>false</code>（默认值）时，集群工作进程会使用相同的 socket 句柄来共享连接处理作业。
当 <code>exclusive</code> 被设为 <code>true</code> 时，该句柄将不会被共享，而尝试共享端口则会造成错误。</p>
<p>一个绑定的数据报 socket 会使 Node.js 进程持续运行以接受数据报消息。</p>
<p>如果绑定失败，一个 <code>'error'</code> 事件会产生。在极少数情况下（例如尝试绑定一个已经关闭的 socket），一个 <a href="errors.html#errors_class_error"><code>Error</code></a> 可能抛出。</p>
<p>一个不共享端口的 socket 的例子如下文所示。</p>
<pre><code class="language-js">socket.bind({
  <span class="hljs-attr">address</span>: <span class="hljs-string">'localhost'</span>,
  <span class="hljs-attr">port</span>: <span class="hljs-number">8000</span>,
  <span class="hljs-attr">exclusive</span>: <span class="hljs-literal">true</span>
});</code></pre>
<h4><code>socket.close([callback])</code><span><a class="mark" href="#dgram_socket_close_callback" id="dgram_socket_close_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_close_callback">
                <a href="dgram/socket_close_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<ul>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当 socket 已被关闭时调用。</li>
</ul>
<p>关闭该 socket 并停止监听其上的数据。
如果提供了一个回调函数，它就相当于为 <a href="dgram.html#dgram_event_close"><code>'close'</code></a> 事件添加了一个监听器。</p>
<h4><code>socket.connect(port[, address][, callback])</code><span><a class="mark" href="#dgram_socket_connect_port_address_callback" id="dgram_socket_connect_port_address_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_connect_port_address_callback">
                <a href="dgram/socket_connect_port_address_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.0.0</span>
</div>
<ul>
<li><code>port</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
<li><code>address</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当连接完成或出错时调用。</li>
</ul>
<p>为 <code>dgram.Socket</code> 关联一个远程地址和端口。
这个 socket 句柄发送的任何消息都会被发送到关联的远程地址。
而且，这个套接字会只接受来自那个远程同类的消息。
会导致一个 <a href="errors.html#errors_err_socket_dgram_is_connected"><code>ERR_SOCKET_DGRAM_IS_CONNECTED</code></a> 异常。
如果没有提供 <code>address</code>，会默认用 <code>'127.0.0.1'</code>（适用于 <code>udp4</code> 套接字）或者 <code>'::1'</code>（适用于 <code>udp6</code> 套接字）。
一旦连接完成，一个 <code>'connect'</code> 会触发，并且可选的 <code>callback</code> 也会被调用。
为了防止失败，这个 <code>callback</code> 被调用或者调用失败触发一个 <code>'error'</code> 事件。</p>
<h4><code>socket.disconnect()</code><span><a class="mark" href="#dgram_socket_disconnect" id="dgram_socket_disconnect">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_disconnect">
                <a href="dgram/socket_disconnect.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v12.0.0</span>
</div>
<p>一个将相连的 <code>dgram.Socket</code> 与远程地址断掉的同步函数。
在一个未绑定或已经断开连接的 socket 上尝试调用 <code>disconnect()</code> 会导致一个 <a href="errors.html#errors_err_socket_dgram_not_connected"><code>ERR_SOCKET_DGRAM_NOT_CONNECTED</code></a> 异常。</p>
<h4><code>socket.dropMembership(multicastAddress[, multicastInterface])</code><span><a class="mark" href="#dgram_socket_dropmembership_multicastaddress_multicastinterface" id="dgram_socket_dropmembership_multicastaddress_multicastinterface">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_dropmembership_multicastaddress_multicastinterface">
                <a href="dgram/socket_dropmembership_multicastaddress_multicastinterface.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.6.9</span>
</div>
<ul>
<li><code>multicastAddress</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>multicastInterface</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>引导内核通过 <code>IP_DROP_MEMBERSHIP</code> 这个 socket 选项删除 <code>multicastAddress</code> 指定的多路传送集合。
当 socket 被关闭或进程被终止时，该方法会被内核自动调用，所以大多数的应用都不用自行调用该方法。</p>
<p>若 <code>multicastInterface</code> 未指定，操作系统会尝试删除所有可用接口上的成员。</p>
<h4><code>socket.dropSourceSpecificMembership(sourceAddress, groupAddress[, multicastInterface])</code><span><a class="mark" href="#dgram_socket_dropsourcespecificmembership_sourceaddress_groupaddress_multicastinterface" id="dgram_socket_dropsourcespecificmembership_sourceaddress_groupaddress_multicastinterface">#</a></span></h4><p class="tip_wrap" data-item_id="socket_dropsourcespecificmembership_sourceaddress_groupaddress_multicastinterface"></p>
<div class="api_metadata">
<span>新增于: v13.1.0, v12.16.0</span>
</div>
<ul>
<li><code>sourceAddress</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>groupAddress</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
<li><code>multicastInterface</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p>Instructs the kernel to leave a source-specific multicast channel at the given
<code>sourceAddress</code> and <code>groupAddress</code> using the <code>IP_DROP_SOURCE_MEMBERSHIP</code>
socket option. This method is automatically called by the kernel when the
socket is closed or the process terminates, so most apps will never have
reason to call this.</p>
<p>If <code>multicastInterface</code> is not specified, the operating system will attempt to
drop membership on all valid interfaces.</p>
<h4><code>socket.getRecvBufferSize()</code><span><a class="mark" href="#dgram_socket_getrecvbuffersize" id="dgram_socket_getrecvbuffersize">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_getrecvbuffersize">
                <a href="dgram/socket_getrecvbuffersize.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.7.0</span>
</div>
<ul>
<li>返回 <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>SO_RCVBUF</code> socket 接收到的 buffer 的大小，以字节为单位。</li>
</ul>
<p>This method throws <a href="errors.html#errors_err_socket_buffer_size"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>
<h4><code>socket.getSendBufferSize()</code><span><a class="mark" href="#dgram_socket_getsendbuffersize" id="dgram_socket_getsendbuffersize">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_getsendbuffersize">
                <a href="dgram/socket_getsendbuffersize.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.7.0</span>
</div>
<ul>
<li>返回 <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> <code>SO_SNDBUF</code> socket 发送的 buffer 的大小，以字节为单位。</li>
</ul>
<p>This method throws <a href="errors.html#errors_err_socket_buffer_size"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>
<h4><code>socket.ref()</code><span><a class="mark" href="#dgram_socket_ref" id="dgram_socket_ref">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_ref">
                <a href="dgram/socket_ref.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div>
<ul>
<li>返回: <a href="dgram.html#dgram_class_dgram_socket" rel="nofollow" class="type">&lt;dgram.Socket&gt;</a></li>
</ul>
<p>默认情况下，绑定一个 socket 会在 socket 运行时阻止 Node.js 进程退出。
<code>socket.unref()</code> 方法用于将 socket 从维持 Node.js 进程的引用列表中解除。
<code>socket.ref()</code> 方法用于将 socket 重新添加到这个引用列表中，并恢复其默认行为。</p>
<p>多次调用 <code>socket.ref()</code> 不会有额外的作用。</p>
<p><code>socket.ref()</code> 方法返回一个对 socket 的引用，所以可以链式调用。</p>
<h4><code>socket.remoteAddress()</code><span><a class="mark" href="#dgram_socket_remoteaddress" id="dgram_socket_remoteaddress">#</a></span></h4><p class="tip_wrap" data-item_id="socket_remoteaddress"></p>
<div class="api_metadata">
<span>新增于: v12.0.0</span>
</div>
<ul>
<li>返回: <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a></li>
</ul>
<p>Returns an object containing the <code>address</code>, <code>family</code>, and <code>port</code> of the remote
endpoint. This method throws an <a href="errors.html#errors_err_socket_dgram_not_connected"><code>ERR_SOCKET_DGRAM_NOT_CONNECTED</code></a> exception
if the socket is not connected.</p>
<h4><code>socket.send(msg[, offset, length][, port][, address][, callback])</code><span><a class="mark" href="#dgram_socket_send_msg_offset_length_port_address_callback" id="dgram_socket_send_msg_offset_length_port_address_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_send_msg_offset_length_port_address_callback">
                <a href="dgram/socket_send_msg_offset_length_port_address_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v14.5.0</td>
<td><p>The <code>msg</code> parameter can now be any <code>TypedArray</code> or <code>DataView</code>.</p></td></tr>
<tr><td>v12.0.0</td>
<td><p>Added support for sending data on connected sockets.</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>msg</code> parameter can be an <code>Uint8Array</code> now.</p></td></tr>
<tr><td>v8.0.0</td>
<td><p>The <code>address</code> parameter is always optional now.</p></td></tr>
<tr><td>v6.0.0</td>
<td><p>On success, <code>callback</code> will now be called with an <code>error</code> argument of <code>null</code> rather than <code>0</code>.</p></td></tr>
<tr><td>v5.7.0</td>
<td><p>The <code>msg</code> parameter can be an array now. Also, the <code>offset</code> and <code>length</code> parameters are optional now.</p></td></tr>
<tr><td>v0.1.99</td>
<td><p><span>新增于: v0.1.99</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>msg</code> <a href="buffer.html#buffer_class_buffer" rel="nofollow" class="type">&lt;Buffer&gt;</a> | <a href="http://url.nodejs.cn/oh3CkV" rel="nofollow" class="type">&lt;TypedArray&gt;</a> | <a href="http://url.nodejs.cn/yCdVkD" rel="nofollow" class="type">&lt;DataView&gt;</a> | <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> | <a href="http://url.nodejs.cn/ZJSz23" rel="nofollow" class="type">&lt;Array&gt;</a> 要发送的消息。</li>
<li><code>offset</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 指定消息的开头在 buffer 中的偏移量。</li>
<li><code>length</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 消息的字节数。</li>
<li><code>port</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a> 目标端口。</li>
<li><code>address</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 目标主机名或 IP 地址。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 当消息被发送时会被调用。</li>
</ul>
<p>在 socket 上广播一个数据包。
对于无连接的 socket，必须指定目标的 <code>port</code> 和 <code>address</code>。
对于连接的 socket，则将会使用其关联的远程端点，因此不能设置 <code>port</code> 和 <code>address</code> 参数。</p>
<p><code>msg</code> 参数包含了要发送的消息。
根据消息的类型可以有不同的做法。
如果 <code>msg</code> 是一个 <code>Buffer</code>、<code>TypedArray</code> 或 <code>DataView</code>，则 <code>offset</code> 和 <code>length</code> 指定了消息在 <code>Buffer</code> 中对应的偏移量和字节数。
如果 <code>msg</code> 是一个<code> String</code>，那么它会被自动地按照 <code>'utf8'</code> 编码转换为 <code>Buffer</code>。
对于包含了多字节字符的消息，<code>offset</code> 和 <code>length</code> 会根据对应的<a href="buffer.html#buffer_static_method_buffer_bytelength_string_encoding">字节长度</a>进行计算，而不是根据字符的位置。
如果 <code>msg</code> 是一个数组，那么 <code>offset</code> 和 <code>length</code> 必须都不能被指定。</p>
<p><code>address</code> 参数是一个字符串。
若 <code>address</code> 的值是一个主机名，则 DNS 会被用来解析主机的地址。
若 <code>address</code> 未提供或是非真值，则 <code>'127.0.0.1'</code>（用于 <code>udp4</code> socket）或 <code>'::1'</code>（用于 <code>udp6</code> socket）会被使用。</p>
<p>若在之前 socket 未通过调用 <code>bind</code> 方法进行绑定，socket 将会被一个随机的端口号赋值并绑定到“所有接口”的地址上（对于 <code>udp4</code> socket 是 <code>'0.0.0.0'</code>，对于 <code>udp6</code> socket 是 <code>'::0'</code>）。</p>
<p>可以指定一个可选的 <code>callback</code> 方法来汇报 DNS 错误或判断可以安全地重用 <code>buf</code> 对象的时机。
在 Node.js 事件循环中，DNS 查询会对发送造成至少一个时间点的延迟。</p>
<p>确定数据包被发送的唯一方式就是指定 <code>callback</code>。
若在 <code>callback</code> 被指定的情况下有错误发生，该错误会作为 <code>callback</code> 的第一个参数。
若 <code>callback</code> 未被指定，该错误会以 <code>'error'</code> 事件的方式投射到 <code>socket</code> 对象上。</p>
<p>偏移量和长度是可选的，但如其中一个被指定则另一个也必须被指定。
另外，它们只在第一个参数是 <code>Buffer</code>、<code>TypedArray</code> 或 <code>DataView</code> 的情况下才能被使用。</p>
<p>This method throws <a href="errors.html#errors_err_socket_bad_port"><code>ERR_SOCKET_BAD_PORT</code></a> if called on an unbound socket.</p>
<p>示例，发送 UDP 包到 <code>localhost</code> 上的某个端口：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> message = Buffer.from(<span class="hljs-string">'一些字节'</span>);
<span class="hljs-keyword">const</span> client = dgram.createSocket(<span class="hljs-string">'udp4'</span>);
client.send(message, <span class="hljs-number">41234</span>, <span class="hljs-string">'localhost'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  client.close();
});</code></pre>
<p>示例，发送包含多个 buffer 的 UDP 包到 <code>127.0.0.1</code> 上的某个端口：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> buf1 = Buffer.from(<span class="hljs-string">'一些 '</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.from(<span class="hljs-string">'字节'</span>);
<span class="hljs-keyword">const</span> client = dgram.createSocket(<span class="hljs-string">'udp4'</span>);
client.send([buf1, buf2], <span class="hljs-number">41234</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  client.close();
});</code></pre>
<p>发送多个 buffer 的速度取决于应用和操作系统。
逐案运行基准来确定最佳策略。
但是一般来说，发送多个 buffer 速度更快。</p>
<p>示例，使用已连接的 socket 发送 UDP 包到 <code>localhost</code> 上的某个端口：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">'dgram'</span>);
<span class="hljs-keyword">const</span> message = Buffer.from(<span class="hljs-string">'一些字节'</span>);
<span class="hljs-keyword">const</span> client = dgram.createSocket(<span class="hljs-string">'udp4'</span>);
client.connect(<span class="hljs-number">41234</span>, <span class="hljs-string">'localhost'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  client.send(message, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    client.close();
  });
});</code></pre>
<h5>关于 UDP 数据报大小的说明<span><a class="mark" href="#dgram_note_about_udp_datagram_size" id="dgram_note_about_udp_datagram_size">#</a></span></h5><p class="tip_wrap" data-show_trans="1" data-item_id="note_about_udp_datagram_size">
                <a href="dgram/note_about_udp_datagram_size.html" class="tip_trans">中英对照</a>
                </p>
<p>IPv4/v6 数据包的最大尺寸取决于 <code>MTU</code>(Maximum Transmission Unit，最大传输单元)与 <code>Payload Length</code> 字段大小。</p>
<ul>
<li>
<p><code>Payload Length</code> 字段有 16 位宽，这意味着不能超过 64K 的包含 IP 头部和数据的负载 (65,507 字节 = 65,535 − 8 字节 UDP 头 − 20 字节 IP 头)。
通常对于环回地址来说是这样，但这个长度的数据包对于大多数的主机和网络来说不切实际。</p>
</li>
<li>
<p><code>MTU</code> 指的是数据链路层为数据包提供的最大大小。
对于任意链路，IPv4 所托管的 <code>MTU</code> 最小为 68 个字节，推荐为 576（典型地，作为拨号上网应用的推荐值），无论它们是完整地还是分块地抵达。</p>
<p>对于 IPv6，<code>MTU</code> 的最小值是 1280 个字节。但是，受托管的最小的碎片重组缓冲大小为 1500 个字节。
现今大多数的数据链路层技术（如以太网），都有 1500 的 <code>MTU</code> 最小值，因而 68 个字节显得非常小。</p>
</li>
</ul>
<p>要提前知道数据包可能经过的每个链路的 MTU 是不可能的。
发送大于接受者 <code>MTU</code> 大小的数据包将不会起作用，因为数据包会被静默地丢失，而不会通知发送者该包未抵达目的地。</p>
<h4><code>socket.setBroadcast(flag)</code><span><a class="mark" href="#dgram_socket_setbroadcast_flag" id="dgram_socket_setbroadcast_flag">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_setbroadcast_flag">
                <a href="dgram/socket_setbroadcast_flag.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.6.9</span>
</div>
<ul>
<li><code>flag</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>设置或清除 <code>SO_BROADCAST</code> socket 选项。
当设置为 <code>true</code>, UDP 包可能会被发送到一个本地接口的广播地址。</p>
<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
<h4><code>socket.setMulticastInterface(multicastInterface)</code><span><a class="mark" href="#dgram_socket_setmulticastinterface_multicastinterface" id="dgram_socket_setmulticastinterface_multicastinterface">#</a></span></h4><p class="tip_wrap" data-item_id="socket_setmulticastinterface_multicastinterface"></p>
<div class="api_metadata">
<span>新增于: v8.6.0</span>
</div>
<ul>
<li><code>multicastInterface</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a></li>
</ul>
<p><em>All references to scope in this section are referring to
<a href="http://url.nodejs.cn/8e3ofa">IPv6 Zone Indices</a>, which are defined by <a href="http://url.nodejs.cn/NoPgna">RFC 4007</a>. In string form, an IP
with a scope index is written as <code>'IP%scope'</code> where scope is an interface name
or interface number.</em></p>
<p>Sets the default outgoing multicast interface of the socket to a chosen
interface or back to system interface selection. The <code>multicastInterface</code> must
be a valid string representation of an IP from the socket's family.</p>
<p>For IPv4 sockets, this should be the IP configured for the desired physical
interface. All packets sent to multicast on the socket will be sent on the
interface determined by the most recent successful use of this call.</p>
<p>For IPv6 sockets, <code>multicastInterface</code> should include a scope to indicate the
interface as in the examples that follow. In IPv6, individual <code>send</code> calls can
also use explicit scope in addresses, so only packets sent to a multicast
address without specifying an explicit scope are affected by the most recent
successful use of this call.</p>
<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
<h5>IPv6 发送多播数据包<span><a class="mark" href="#dgram_example_ipv6_outgoing_multicast_interface" id="dgram_example_ipv6_outgoing_multicast_interface">#</a></span></h5><p class="tip_wrap" data-item_id="example_ipv6_outgoing_multicast_interface"></p>
<p>On most systems, where scope format uses the interface name:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> socket = dgram.createSocket(<span class="hljs-string">'udp6'</span>);

socket.bind(<span class="hljs-number">1234</span>, <span class="hljs-function">() =&gt;</span> {
  socket.setMulticastInterface(<span class="hljs-string">'::%eth1'</span>);
});</code></pre>
<p>On Windows, where scope format uses an interface number:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> socket = dgram.createSocket(<span class="hljs-string">'udp6'</span>);

socket.bind(<span class="hljs-number">1234</span>, <span class="hljs-function">() =&gt;</span> {
  socket.setMulticastInterface(<span class="hljs-string">'::%2'</span>);
});</code></pre>
<h5>IPv4 发送多播数据包<span><a class="mark" href="#dgram_example_ipv4_outgoing_multicast_interface" id="dgram_example_ipv4_outgoing_multicast_interface">#</a></span></h5><p class="tip_wrap" data-item_id="example_ipv4_outgoing_multicast_interface"></p>
<p>All systems use an IP of the host on the desired physical interface:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> socket = dgram.createSocket(<span class="hljs-string">'udp4'</span>);

socket.bind(<span class="hljs-number">1234</span>, <span class="hljs-function">() =&gt;</span> {
  socket.setMulticastInterface(<span class="hljs-string">'10.0.0.2'</span>);
});</code></pre>
<h5>调用的结果<span><a class="mark" href="#dgram_call_results" id="dgram_call_results">#</a></span></h5><p class="tip_wrap" data-item_id="call_results"></p>
<p>A call on a socket that is not ready to send or no longer open may throw a <em>Not
running</em> <a href="errors.html#errors_class_error"><code>Error</code></a>.</p>
<p>If <code>multicastInterface</code> can not be parsed into an IP then an <em>EINVAL</em>
<a href="errors.html#errors_class_systemerror"><code>System Error</code></a> is thrown.</p>
<p>On IPv4, if <code>multicastInterface</code> is a valid address but does not match any
interface, or if the address does not match the family then
a <a href="errors.html#errors_class_systemerror"><code>System Error</code></a> such as <code>EADDRNOTAVAIL</code> or <code>EPROTONOSUP</code> is thrown.</p>
<p>On IPv6, most errors with specifying or omitting scope will result in the socket
continuing to use (or returning to) the system's default interface selection.</p>
<p>A socket's address family's ANY address (IPv4 <code>'0.0.0.0'</code> or IPv6 <code>'::'</code>) can be
used to return control of the sockets default outgoing interface to the system
for future multicast packets.</p>
<h4><code>socket.setMulticastLoopback(flag)</code><span><a class="mark" href="#dgram_socket_setmulticastloopback_flag" id="dgram_socket_setmulticastloopback_flag">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_setmulticastloopback_flag">
                <a href="dgram/socket_setmulticastloopback_flag.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.8</span>
</div>
<ul>
<li><code>flag</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a></li>
</ul>
<p>设置或清除 <code>IP_MULTICAST_LOOP</code> socket 选项。当设置为 <code>true</code>, 多播数据包也将在本地接口接收。</p>
<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
<h4><code>socket.setMulticastTTL(ttl)</code><span><a class="mark" href="#dgram_socket_setmulticastttl_ttl" id="dgram_socket_setmulticastttl_ttl">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_setmulticastttl_ttl">
                <a href="dgram/socket_setmulticastttl_ttl.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.3.8</span>
</div>
<ul>
<li><code>ttl</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>设置 <code>IP_MULTICAST_TTL</code> 套接字选项。
一般来说，TTL 表示"生存时间"。
这里特指一个 IP 数据包传输时允许的最大跳步数，尤其是对多播传输。
当 IP 数据包每向前经过一个路由或网关时，TTL 值减 1，若经过某个路由时，TTL 值被减至 0，便不再继续向前传输。</p>
<p><code>ttl</code> 参数可以是 <code>0</code> 到 <code>255</code> 之间。
在大多数系统上，默认值是 <code>1</code>。</p>
<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
<h4><code>socket.setRecvBufferSize(size)</code><span><a class="mark" href="#dgram_socket_setrecvbuffersize_size" id="dgram_socket_setrecvbuffersize_size">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_setrecvbuffersize_size">
                <a href="dgram/socket_setrecvbuffersize_size.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.7.0</span>
</div>
<ul>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>设置 <code>SO_RCVBUF</code> socket 选项。
设置 socket 接收 buffer 的最大值，以字节为单位。</p>
<p>This method throws <a href="errors.html#errors_err_socket_buffer_size"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>
<h4><code>socket.setSendBufferSize(size)</code><span><a class="mark" href="#dgram_socket_setsendbuffersize_size" id="dgram_socket_setsendbuffersize_size">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_setsendbuffersize_size">
                <a href="dgram/socket_setsendbuffersize_size.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v8.7.0</span>
</div>
<ul>
<li><code>size</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>设置 <code>SO_SNDBUF</code> socket 选项。
设置 socket 发送 buffer 的最大值，以字节为单位。</p>
<p>This method throws <a href="errors.html#errors_err_socket_buffer_size"><code>ERR_SOCKET_BUFFER_SIZE</code></a> if called on an unbound socket.</p>
<h4><code>socket.setTTL(ttl)</code><span><a class="mark" href="#dgram_socket_setttl_ttl" id="dgram_socket_setttl_ttl">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_setttl_ttl">
                <a href="dgram/socket_setttl_ttl.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.101</span>
</div>
<ul>
<li><code>ttl</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;integer&gt;</a></li>
</ul>
<p>设置 <code>IP_TTL</code> 套接字选项。
一般来说，TTL 表示"生存时间"，这里特指一个 IP 数据包传输时允许的最大跳步数。
当 IP 数据包每向前经过一个路由或网关时，TTL 值减 1，若经过某个路由时，TTL 值被减至 0，便不再继续向前传输。
比较有代表性的是，为了进行网络情况嗅探或者多播而修改 TTL 值。</p>
<p><code>ttl</code> 参数可以是 <code>0</code> 到 <code>255</code> 之间。
在大多数系统上，默认值是 <code>64</code>。</p>
<p>This method throws <code>EBADF</code> if called on an unbound socket.</p>
<h4><code>socket.unref()</code><span><a class="mark" href="#dgram_socket_unref" id="dgram_socket_unref">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="socket_unref">
                <a href="dgram/socket_unref.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.9.1</span>
</div>
<ul>
<li>返回: <a href="dgram.html#dgram_class_dgram_socket" rel="nofollow" class="type">&lt;dgram.Socket&gt;</a></li>
</ul>
<p>默认情况下，只要 socket 是打开的，绑定一个 socket 将导致它阻塞 Node.js 进程退出。
使用 <code>socket.unref()</code> 方法可以从保持 Node.js 进程活动的引用计数中排除 socket，从而允许进程退出，尽管这个 socket 仍然在侦听。</p>
<p>多次调用 <code>socket.unref()</code> 方法将不会有任何新增的作用。</p>
<p><code>socket.unref()</code> 方法返回当前 socket 的引用，因此可以链式调用。</p>
</section><section><h3>dgram 模块的函数<span><a class="mark" href="#dgram_dgram_module_functions" id="dgram_dgram_module_functions">#</a></span></h3>
<h4><code>dgram.createSocket(options[, callback])</code><span><a class="mark" href="#dgram_dgram_createsocket_options_callback" id="dgram_dgram_createsocket_options_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="dgram_createsocket_options_callback">
                <a href="dgram/dgram_createsocket_options_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<details class="changelog"><summary>版本历史</summary>
<table>
<tbody><tr><th>版本</th><th>变更</th></tr>
<tr><td>v11.4.0</td>
<td><p>The <code>ipv6Only</code> option is supported.</p></td></tr>
<tr><td>v8.7.0</td>
<td><p>The <code>recvBufferSize</code> and <code>sendBufferSize</code> options are supported now.</p></td></tr>
<tr><td>v8.6.0</td>
<td><p>The <code>lookup</code> option is supported.</p></td></tr>
<tr><td>v0.11.13</td>
<td><p><span>新增于: v0.11.13</span></p></td></tr>
</tbody></table>
</details>
</div>
<ul>
<li><code>options</code> <a href="http://url.nodejs.cn/jzn6Ao" rel="nofollow" class="type">&lt;Object&gt;</a> 允许的选项是:
<ul>
<li><code>type</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> 套接字族. 必须是&nbsp;<code>'udp4'</code> 或&nbsp;<code>'udp6'</code>。必需填。</li>
<li><code>reuseAddr</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 若设置为 <code>true</code>，则 <a href="dgram.html#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> 会重用地址，即使另一个进程已经在其上面绑定了一个套接字。<strong>默认值:</strong> <code>false</code>。</li>
<li><code>ipv6Only</code> <a href="http://url.nodejs.cn/jFbvuT" rel="nofollow" class="type">&lt;boolean&gt;</a> 将 <code>ipv6Only</code> 设置为 <code>true</code> 将会禁用双栈支持，即绑定到地址 <code>::</code> 不会使 <code>0.0.0.0</code> 绑定。<strong>默认值:</strong> <code>false</code>。</li>
<li><code>recvBufferSize</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 设置&nbsp;<code>SO_RCVBUF</code> 套接字值。</li>
<li><code>sendBufferSize</code> <a href="http://url.nodejs.cn/SXbo1v" rel="nofollow" class="type">&lt;number&gt;</a> 设置&nbsp;<code>SO_SNDBUF</code> 套接字值。</li>
<li><code>lookup</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 自定义的查询函数。<strong>默认值:</strong>&nbsp;<a href="dns.html#dns_dns_lookup_hostname_options_callback"><code>dns.lookup()</code></a>。</li>
</ul>
</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 为&nbsp;<code>'message'</code> 事件绑定一个监听器。可选。</li>
<li>返回: <a href="dgram.html#dgram_class_dgram_socket" rel="nofollow" class="type">&lt;dgram.Socket&gt;</a></li>
</ul>
<p>创建一个 <code>dgram.Socket</code> 对象。
一旦创建了套接字，调用 <a href="dgram.html#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> 会指示套接字开始监听数据报消息。
如果 <code>address</code> 和&nbsp;<code>port</code> 没传给 &nbsp;<a href="dgram.html#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a>，那么这个方法会把这个套接字绑定到 "全部接口" 地址的一个随机端口（这适用于 <code>udp4</code> 和&nbsp;<code>udp6</code> 套接字）。
绑定的地址和端口可以通过 <a href="dgram.html#dgram_socket_address"><code>socket.address().address</code></a> 和<a href="dgram.html#dgram_socket_address"><code>socket.address().port</code></a> 来获取。</p>
<h4><code>dgram.createSocket(type[, callback])</code><span><a class="mark" href="#dgram_dgram_createsocket_type_callback" id="dgram_dgram_createsocket_type_callback">#</a></span></h4><p class="tip_wrap" data-show_trans="1" data-item_id="dgram_createsocket_type_callback">
                <a href="dgram/dgram_createsocket_type_callback.html" class="tip_trans">中英对照</a>
                </p>
<div class="api_metadata">
<span>新增于: v0.1.99</span>
</div>
<ul>
<li><code>type</code> <a href="http://url.nodejs.cn/9Tw2bK" rel="nofollow" class="type">&lt;string&gt;</a> <code>'udp4'</code> 或 <code>'udp6'</code>。</li>
<li><code>callback</code> <a href="http://url.nodejs.cn/ceTQa6" rel="nofollow" class="type">&lt;Function&gt;</a> 为&nbsp;<code>'message'</code> 事件添加一个监听器。</li>
<li>返回: <a href="dgram.html#dgram_class_dgram_socket" rel="nofollow" class="type">&lt;dgram.Socket&gt;</a></li>
</ul>
<p>创建一个特定 <code>type</code> 的 <code>dgram.Socket</code> 对象。</p>
<p>一旦套接字被创建，调用 <a href="dgram.html#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a> 会指示套接字开始监听数据报消息。
如果 <code>address</code> 和 <code>port</code> 没传给  <a href="dgram.html#dgram_socket_bind_port_address_callback"><code>socket.bind()</code></a>，那么这个方法会把这个套接字绑定到 "全部接口" 地址的一个随机端口（这适用于 <code>udp4</code> 和 <code>udp6</code> 套接字）。
绑定的地址和端口可以通过 <a href="dgram.html#dgram_socket_address"><code>socket.address().address</code></a> 和<a href="dgram.html#dgram_socket_address"><code>socket.address().port</code></a> 来获取。</p></section>
        <!-- API END -->
      </div>
    </div>
  </div>
  
  <!-- <script src="//cdn.staticfile.org/highlight.js/10.2.1/highlight.min.js"></script> -->
  
  


</body></html>